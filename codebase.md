This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-22T02:16:53.513Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
.github/
  ISSUE_TEMPLATE/
    bug_report.md
    feature_request.md
packages/
  backend/
    prisma/
      migrations/
        20241130003245_init/
          migration.sql
        20241207052011_add_language_model_and_make_language_id_optional/
          migration.sql
        20241209004222_add_settings_model/
          migration.sql
        20241220064500_add_limit_type/
          migration.sql
        20241221195000_add_category_limit/
          migration.sql
        migration_lock.toml
      schema.prisma
    public/
      css/
        components/
          forms.css
          languages.css
          messages.css
          tables.css
        layout/
          sections.css
        styles.css
      js/
        categories.js
        foodItems.js
        languages.js
        main.js
        settings.js
        translations.js
        utils.js
      index.html
    src/
      config/
        languageConfig.ts
      middleware/
        errorHandler.ts
        requestLogger.ts
      routes/
        categoryRoutes.ts
        foodItemRoutes.ts
        languageRoutes.ts
        settingsRoutes.ts
        translationRoutes.ts
      services/
        openai/
          __tests__/
            OpenAIService.test.ts
          OpenAIService.ts
        CategoryService.ts
        FoodItemService.ts
        LanguageService.ts
        TranslationService.ts
      tests/
        utils/
          dbHelpers.ts
          testFactories.ts
          testHelpers.ts
        categoryRoutes.test.ts
        CategoryService.test.ts
        foodItemRoutes.test.ts
        FoodItemService.test.ts
        languageRoutes.test.ts
        limitType.test.ts
        settings.test.ts
        settingsRoutes.test.ts
        setup.ts
        translationRoutes.test.ts
        TranslationService.test.ts
      utils/
        ApiError.ts
        ApiResponse.ts
        errorConstants.ts
        errorHandler.ts
      index.ts
    .env.example
    jest-setup.js
    jest.config.js
    package.json
    tsconfig.json
  frontend/
    package.json
.gitignore
CHANGELOG.md
LICENSE
package.json
project-overview.md
project-structure.md
project-tree.txt
README.md
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path=".github/ISSUE_TEMPLATE/bug_report.md">
---
name: Bug report
about: Create a report to help us improve
title: '[BUG] '
labels: bug
assignees: ''

---

### Description
A clear and concise description of what the bug is.

### Steps to Reproduce
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

### Expected Behavior
A clear and concise description of what you expected to happen.

### Actual Behavior
What actually happens instead of the expected behavior.

### Environment
- Browser: [e.g., Chrome, Safari]
- Version: [e.g., 22]
- OS: [e.g., macOS, Windows]
- Node version:
- Other relevant config:

### Logs/Screenshots
```
[Add relevant logs here]
```

### Investigation Progress
- [ ] Step 1
- [ ] Step 2

### Additional Context
Add any other context about the problem here.

### Related Changes
- List any related changes, commits, or PRs
</file>

<file path=".github/ISSUE_TEMPLATE/feature_request.md">
---
name: Feature request
about: Suggest an idea for this project
title: '[FEATURE] '
labels: enhancement
assignees: ''

---

### Problem Statement
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

### Proposed Solution
A clear and concise description of what you want to happen.

### Alternative Solutions
A clear and concise description of any alternative solutions or features you've considered.

### Additional Context
Add any other context or screenshots about the feature request here.

### Implementation Checklist
- [ ] Task 1
- [ ] Task 2

### Impact Analysis
Describe the impact this feature would have on:
- Performance
- Security
- User Experience
- Maintenance
</file>

<file path="packages/backend/prisma/migrations/20241130003245_init/migration.sql">
-- CreateTable
CREATE TABLE "Category" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "name" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- CreateTable
CREATE TABLE "FoodItem" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "name" TEXT NOT NULL,
    "categoryId" INTEGER NOT NULL,
    "imageUrl" TEXT,
    "thumbnailUrl" TEXT,
    "itemLimit" INTEGER,
    "inStock" BOOLEAN NOT NULL DEFAULT true,
    "mustGo" BOOLEAN NOT NULL DEFAULT false,
    "lowSupply" BOOLEAN NOT NULL DEFAULT false,
    "kosher" BOOLEAN NOT NULL DEFAULT false,
    "halal" BOOLEAN NOT NULL DEFAULT false,
    "vegetarian" BOOLEAN NOT NULL DEFAULT false,
    "vegan" BOOLEAN NOT NULL DEFAULT false,
    "glutenFree" BOOLEAN NOT NULL DEFAULT false,
    "organic" BOOLEAN NOT NULL DEFAULT false,
    "readyToEat" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "FoodItem_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "Translation" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "language" TEXT NOT NULL,
    "translatedText" TEXT NOT NULL,
    "categoryId" INTEGER,
    "foodItemId" INTEGER,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "Translation_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "Translation_foodItemId_fkey" FOREIGN KEY ("foodItemId") REFERENCES "FoodItem" ("id") ON DELETE SET NULL ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "CustomField" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "key" TEXT NOT NULL,
    "value" TEXT NOT NULL,
    "foodItemId" INTEGER NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "CustomField_foodItemId_fkey" FOREIGN KEY ("foodItemId") REFERENCES "FoodItem" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateIndex
CREATE INDEX "FoodItem_categoryId_idx" ON "FoodItem"("categoryId");

-- CreateIndex
CREATE UNIQUE INDEX "Translation_language_categoryId_key" ON "Translation"("language", "categoryId");

-- CreateIndex
CREATE UNIQUE INDEX "Translation_language_foodItemId_key" ON "Translation"("language", "foodItemId");

-- CreateIndex
CREATE INDEX "CustomField_foodItemId_idx" ON "CustomField"("foodItemId");
</file>

<file path="packages/backend/prisma/migrations/20241207052011_add_language_model_and_make_language_id_optional/migration.sql">
/*
  Warnings:

  - You are about to drop the column `language` on the `Translation` table. All the data in the column will be lost.

*/
-- CreateTable
CREATE TABLE "Language" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "code" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "active" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- RedefineTables
PRAGMA defer_foreign_keys=ON;
PRAGMA foreign_keys=OFF;
CREATE TABLE "new_Translation" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "translatedText" TEXT NOT NULL,
    "categoryId" INTEGER,
    "foodItemId" INTEGER,
    "languageId" INTEGER,
    "isAutomatic" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "Translation_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "Translation_foodItemId_fkey" FOREIGN KEY ("foodItemId") REFERENCES "FoodItem" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "Translation_languageId_fkey" FOREIGN KEY ("languageId") REFERENCES "Language" ("id") ON DELETE SET NULL ON UPDATE CASCADE
);
INSERT INTO "new_Translation" ("categoryId", "createdAt", "foodItemId", "id", "translatedText", "updatedAt") SELECT "categoryId", "createdAt", "foodItemId", "id", "translatedText", "updatedAt" FROM "Translation";
DROP TABLE "Translation";
ALTER TABLE "new_Translation" RENAME TO "Translation";
CREATE INDEX "Translation_languageId_idx" ON "Translation"("languageId");
CREATE UNIQUE INDEX "Translation_languageId_categoryId_key" ON "Translation"("languageId", "categoryId");
CREATE UNIQUE INDEX "Translation_languageId_foodItemId_key" ON "Translation"("languageId", "foodItemId");
PRAGMA foreign_keys=ON;
PRAGMA defer_foreign_keys=OFF;

-- CreateIndex
CREATE UNIQUE INDEX "Language_code_key" ON "Language"("code");
</file>

<file path="packages/backend/prisma/migrations/20241209004222_add_settings_model/migration.sql">
-- CreateTable
CREATE TABLE "Settings" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT DEFAULT 1,
    "globalUpperLimit" INTEGER NOT NULL DEFAULT 10,
    "updatedAt" DATETIME NOT NULL
);
</file>

<file path="packages/backend/prisma/migrations/20241220064500_add_limit_type/migration.sql">
-- Add limitType field to FoodItem
ALTER TABLE FoodItem ADD COLUMN limitType TEXT DEFAULT 'perHousehold';
</file>

<file path="packages/backend/prisma/migrations/20241221195000_add_category_limit/migration.sql">
-- CreateTable
CREATE TABLE "_prisma_new_Category" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "name" TEXT NOT NULL,
    "itemLimit" INTEGER NOT NULL DEFAULT 0,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- Copy data
INSERT INTO "_prisma_new_Category" ("id", "name", "createdAt", "updatedAt")
SELECT "id", "name", "createdAt", "updatedAt" FROM "Category";

-- Drop old table and rename new
DROP TABLE "Category";
ALTER TABLE "_prisma_new_Category" RENAME TO "Category";
</file>

<file path="packages/backend/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "sqlite"
</file>

<file path="packages/backend/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Category {
  id          Int           @id @default(autoincrement())
  name        String        // English name as base
  itemLimit   Int          @default(0)  // New field for category item limit
  items       FoodItem[]
  translations Translation[]
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model FoodItem {
  id            Int           @id @default(autoincrement())
  name          String        // English name as base
  categoryId    Int
  category      Category      @relation(fields: [categoryId], references: [id])
  translations  Translation[]
  
  // Image handling
  imageUrl      String?
  thumbnailUrl  String?
  
  // Inventory management
  itemLimit     Int?
  limitType     String        @default("perHousehold")  // "perHousehold" or "perPerson"
  inStock       Boolean       @default(true)
  mustGo        Boolean       @default(false)
  lowSupply     Boolean       @default(false)
  
  // Dietary attributes
  kosher        Boolean       @default(false)
  halal         Boolean       @default(false)
  vegetarian    Boolean       @default(false)
  vegan         Boolean       @default(false)
  glutenFree    Boolean       @default(false)
  
  // Quality attributes
  organic       Boolean       @default(false)
  readyToEat    Boolean       @default(false)
  
  // Custom fields for flexibility
  customFields  CustomField[]
  
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  @@index([categoryId])
}

model Translation {
  id             Int       @id @default(autoincrement())
  translatedText String
  categoryId     Int?
  category       Category? @relation(fields: [categoryId], references: [id])
  foodItemId     Int?
  foodItem       FoodItem? @relation(fields: [foodItemId], references: [id])
  languageId     Int?
  language       Language? @relation(fields: [languageId], references: [id])
  isAutomatic    Boolean   @default(false)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  @@unique([languageId, categoryId])
  @@unique([languageId, foodItemId])
  @@index([languageId])
}

model Language {
  id           Int           @id @default(autoincrement())
  code         String        @unique  // ISO 639-1 language code (e.g., "en", "es", "zh")
  name         String        // Display name (e.g., "English", "Spanish", "Chinese")
  active       Boolean       @default(true)
  translations Translation[]
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
}

model CustomField {
  id          Int       @id @default(autoincrement())
  key         String
  value       String
  foodItemId  Int
  foodItem    FoodItem  @relation(fields: [foodItemId], references: [id])
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  @@index([foodItemId])
}

model Settings {
  id              Int      @id @default(1)
  globalUpperLimit Int     @default(10)
  updatedAt       DateTime @updatedAt
}
</file>

<file path="packages/backend/public/css/components/forms.css">
.form__group {
    margin: 10px 0;
}

.toggle-group {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin: 10px 0;
}

.toggle-group__label {
    display: flex;
    align-items: center;
    gap: 5px;
}

.limit-options {
    display: flex;
    align-items: center;
    gap: 20px;
}

.lang-select {
    display: flex;
    align-items: center;
    gap: 10px;
}

.lang-select__label {
    width: 120px;
}
</file>

<file path="packages/backend/public/css/components/languages.css">
.language-grid {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 10px;
    margin: 20px 0;
}

.language-item {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 0.9em;
}

.translation-type {
    display: flex;
    gap: 20px;
}
</file>

<file path="packages/backend/public/css/components/messages.css">
.message-area {
    margin-bottom: 1rem;
    min-height: 2rem;
}

.message {
    padding: 0.75rem 1rem;
    margin: 0.5rem 0;
    border-radius: 4px;
}

.message--success {
    background-color: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
}

.message--error {
    background-color: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
}

.message--warning {
    background-color: #fff3cd;
    color: #856404;
    border: 1px solid #ffeeba;
}

.message--info {
    background-color: #d1ecf1;
    color: #0c5460;
    border: 1px solid #bee5eb;
}

.message--note {
    background-color: #e2e3e5;
    color: #383d41;
    border: 1px solid #d6d8db;
    font-size: 0.9em;
}
</file>

<file path="packages/backend/public/css/components/tables.css">
.table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
}

.table__cell {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
}

.table__header {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
    background-color: #f8f9fa;
}
</file>

<file path="packages/backend/public/css/layout/sections.css">
.section {
    margin: 20px 0;
    padding: 20px;
    border: 1px solid #ccc;
}

.filter-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}
</file>

<file path="packages/backend/public/css/styles.css">
/* Base styles and imports */
@import 'components/messages.css';
@import 'components/tables.css';
@import 'components/forms.css';
@import 'components/languages.css';
@import 'layout/sections.css';

/* Global styles */
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;
    line-height: 1.4;
    color: #333;
    margin: 0;
    padding: 20px;
}

h1, h2, h3, h4 {
    margin-top: 0;
    margin-bottom: 0.5em;
}
</file>

<file path="packages/backend/public/js/categories.js">
import { showMessage, apiGet, apiPost, apiPut, apiDelete } from './utils.js';
import { managers, EVENTS } from './main.js';

export class CategoryManager {
    constructor() {
        this.form = document.getElementById('categoryForm');
        this.tableBody = document.getElementById('categoryTableBody');
        this.resetButton = document.getElementById('resetForm');
        this.itemLimitValue = document.getElementById('categoryItemLimit');
        this.setupEventListeners();
    }

    setupEventListeners() {
        this.form.addEventListener('submit', this.handleSubmit.bind(this));
        this.resetButton.addEventListener('click', () => this.resetForm());
        this.itemLimitValue.addEventListener('input', this.handleLimitValidation.bind(this));
        this.addTableEventListeners();
    }

    handleLimitValidation(e) {
        const globalUpperLimit = managers.settings.getCurrentLimit();
        let value = parseInt(e.target.value);

        if (isNaN(value) || value < 0) {
            e.target.value = 0;
        } else if (value > globalUpperLimit) {
            e.target.value = globalUpperLimit;
        }
    }

    addTableEventListeners() {
        this.tableBody.addEventListener('click', (e) => {
            const target = e.target;
            if (target.classList.contains('edit-btn')) {
                this.editCategory(
                    parseInt(target.dataset.id),
                    target.dataset.name,
                    parseInt(target.dataset.limit || '0')
                );
            } else if (target.classList.contains('delete-btn')) {
                this.deleteCategory(parseInt(target.dataset.id));
            }
        });
    }

    async handleSubmit(e) {
        e.preventDefault();
        const name = document.getElementById('categoryName').value.trim();
        const itemLimit = parseInt(document.getElementById('categoryItemLimit').value) || 0;
        const id = document.getElementById('categoryId').value;

        try {
            const data = { name, itemLimit };
            if (id) {
                await apiPut(`/api/categories/${id}`, data);
                showMessage('Category updated successfully', 'success', 'category');
            } else {
                await apiPost('/api/categories', data);
                showMessage('Category created successfully', 'success', 'category');
            }
            this.resetForm();
            await this.loadCategories();
            
            // Dispatch event for other managers
            document.dispatchEvent(new Event(EVENTS.CATEGORY_UPDATED));
        } catch (error) {
            showMessage(error.message || 'An error occurred', 'error', 'category');
        }
    }

    async loadCategories() {
        try {
            const data = await apiGet('/api/categories');
            if (data && data.data) {
                this.displayCategories(data.data);
            }
        } catch (error) {
            showMessage(error.message || 'Error loading categories', 'error', 'category');
        }
    }

    displayCategories(categories) {
        if (!Array.isArray(categories)) {
            this.tableBody.innerHTML = '<tr><td colspan="4">No categories available</td></tr>';
            return;
        }

        this.tableBody.innerHTML = categories.map(category => `
            <tr>
                <td class="table__cell">${category.name}</td>
                <td class="table__cell">${this.formatLimit(category.itemLimit)}</td>
                <td class="table__cell">${new Date(category.createdAt).toLocaleDateString()}</td>
                <td class="table__cell">
                    <button class="edit-btn" 
                            data-id="${category.id}" 
                            data-name="${category.name}"
                            data-limit="${category.itemLimit || 0}">Edit</button>
                    <button class="delete-btn" data-id="${category.id}">Delete</button>
                </td>
            </tr>
        `).join('');
    }

    formatLimit(limit) {
        const limitNum = parseInt(limit);
        return isNaN(limitNum) || limitNum === 0 ? 'No Limit' : limitNum.toString();
    }

    async deleteCategory(id) {
        if (!confirm('Are you sure you want to delete this category?')) return;

        try {
            await apiDelete(`/api/categories/${id}`);
            showMessage('Category deleted successfully', 'success', 'category');
            await this.loadCategories();
            
            // Dispatch event for other managers
            document.dispatchEvent(new Event(EVENTS.CATEGORY_UPDATED));
        } catch (error) {
            showMessage(error.message || 'Error deleting category', 'error', 'category');
        }
    }

    editCategory(id, name, itemLimit) {
        document.getElementById('categoryId').value = id;
        document.getElementById('categoryName').value = name || '';
        document.getElementById('categoryItemLimit').value = itemLimit || 0;
        this.form.querySelector('button[type="submit"]').textContent = 'Update Category';
    }

    resetForm() {
        this.form.reset();
        document.getElementById('categoryId').value = '';
        document.getElementById('categoryItemLimit').value = '0';
        this.form.querySelector('button[type="submit"]').textContent = 'Add Category';
    }
}
</file>

<file path="packages/backend/public/js/foodItems.js">
import { showMessage, apiGet, apiPost, apiPut, apiDelete } from './utils.js';
import { managers } from './main.js';

export class FoodItemManager {
    constructor(settingsManager) {
        this.settingsManager = settingsManager;
        this.form = document.getElementById('foodItemForm');
        this.tableBody = document.getElementById('foodItemTableBody');
        this.itemLimitValue = document.getElementById('itemLimitValue');
        this.resetButton = document.getElementById('resetFoodItemForm');
        this.categorySelect = document.getElementById('foodItemCategory');
        this.setupEventListeners();
        this.init();
    }

    async init() {
        await this.loadCategories();
        if (this.categorySelect.options.length === 0) {
            this.displayNoCategories();
        }
    }

    setupEventListeners() {
        this.form.addEventListener('submit', this.handleSubmit.bind(this));
        this.resetButton.addEventListener('click', () => this.resetForm());
        this.itemLimitValue.addEventListener('input', this.handleLimitValidation.bind(this));
    }

    displayNoCategories() {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'Please create a category first';
        this.categorySelect.appendChild(option);
        
        this.form.querySelector('button[type="submit"]').disabled = true;
        showMessage('Please create at least one category before adding food items', 'warning', 'foodItem');
    }

    async loadCategories() {
        try {
            const data = await apiGet('/api/categories');
            this.categorySelect.innerHTML = '';
            
            if (!data.data || data.data.length === 0) {
                this.displayNoCategories();
                return;
            }

            this.form.querySelector('button[type="submit"]').disabled = false;
            
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select a category';
            this.categorySelect.appendChild(defaultOption);

            data.data.forEach(category => {
                const option = document.createElement('option');
                option.value = category.id;
                option.textContent = category.name;
                this.categorySelect.appendChild(option);
            });
        } catch (error) {
            showMessage(error.message, 'error', 'foodItem');
        }
    }

    handleLimitValidation(e) {
        const globalUpperLimit = this.settingsManager.getCurrentLimit();
        let value = parseInt(e.target.value);

        if (isNaN(value) || value < 0) {
            e.target.value = 0;
        } else if (value > globalUpperLimit) {
            e.target.value = globalUpperLimit;
        }
    }

    async handleSubmit(e) {
        e.preventDefault();
        const data = this.collectFormData();
        const id = document.getElementById('foodItemId').value;

        try {
            if (id) {
                await apiPut(`/api/food-items/${id}`, data);
                showMessage('Food item updated successfully', 'success', 'foodItem');
            } else {
                await apiPost('/api/food-items', data);
                showMessage('Food item created successfully', 'success', 'foodItem');
            }
            this.resetForm();
            await this.loadFoodItems();
        } catch (error) {
            showMessage(error.message, 'error', 'foodItem');
        }
    }

    collectFormData() {
        const limitType = document.querySelector('input[name="limitType"]:checked').value;
        let itemLimit = parseInt(this.itemLimitValue.value);
        if (isNaN(itemLimit)) itemLimit = 0;
        if (itemLimit < 0) itemLimit = 0;

        const globalUpperLimit = this.settingsManager.getCurrentLimit();
        if (itemLimit > globalUpperLimit) itemLimit = globalUpperLimit;

        return {
            name: document.getElementById('foodItemName').value.trim(),
            categoryId: parseInt(document.getElementById('foodItemCategory').value),
            itemLimit,
            limitType,
            inStock: document.getElementById('foodItemInStock').checked,
            mustGo: document.getElementById('foodItemMustGo').checked,
            lowSupply: document.getElementById('foodItemLowSupply').checked,
            kosher: document.getElementById('foodItemKosher').checked,
            halal: document.getElementById('foodItemHalal').checked,
            vegetarian: document.getElementById('foodItemVegetarian').checked,
            vegan: document.getElementById('foodItemVegan').checked,
            glutenFree: document.getElementById('foodItemGlutenFree').checked,
            organic: document.getElementById('foodItemOrganic').checked,
            readyToEat: document.getElementById('foodItemReadyToEat').checked
        };
    }

    async loadFoodItems() {
        try {
            await this.loadCategories();
            const data = await apiGet('/api/food-items?includeOutOfStock=true');
            this.displayFoodItems(data.data);
            if (managers.translations) {
                await managers.translations.loadTranslations();
            }
        } catch (error) {
            showMessage(error.message, 'error', 'foodItem');
        }
    }

    displayFoodItems(foodItems) {
        if (!Array.isArray(foodItems) || foodItems.length === 0) {
            this.tableBody.innerHTML = '<tr><td colspan="7">No food items found</td></tr>';
            return;
        }

        this.tableBody.innerHTML = foodItems
            .map(item => this.createFoodItemRow(item))
            .join('');

        this.addTableEventListeners();
    }

    createFoodItemRow(item) {
        const status = this.formatStatus(item);
        const dietary = this.formatDietary(item);
        const limitDisplay = this.formatLimit(item);

        const itemData = {
            id: item.id,
            name: item.name,
            categoryId: item.category?.id,
            itemLimit: item.itemLimit,
            limitType: item.limitType,
            inStock: item.inStock,
            mustGo: item.mustGo,
            lowSupply: item.lowSupply,
            kosher: item.kosher,
            halal: item.halal,
            vegetarian: item.vegetarian,
            vegan: item.vegan,
            glutenFree: item.glutenFree,
            organic: item.organic,
            readyToEat: item.readyToEat
        };

        const itemDataString = JSON.stringify(itemData).replace(/'/g, "\\'");

        return `
            <tr>
                <td>${item.name}</td>
                <td>${item.category?.name || 'Unknown'}</td>
                <td>${status || 'None'}</td>
                <td>${dietary || 'None'}</td>
                <td>${limitDisplay}</td>
                <td>${new Date(item.createdAt).toLocaleDateString()}</td>
                <td>
                    <button class="edit-food-item-btn" data-item='${itemDataString}'>
                        Edit
                    </button>
                    <button class="delete-food-item-btn" data-id="${item.id}">
                        Delete
                    </button>
                </td>
            </tr>
        `;
    }

    addTableEventListeners() {
        this.tableBody.querySelectorAll('.edit-food-item-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const itemData = btn.getAttribute('data-item');
                this.editFoodItem(itemData);
            });
        });

        this.tableBody.querySelectorAll('.delete-food-item-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const { id } = btn.dataset;
                this.deleteFoodItem(id);
            });
        });
    }

    formatStatus(item) {
        return [
            item.inStock ? 'In Stock' : 'Out of Stock',
            item.mustGo ? 'Must Go' : '',
            item.lowSupply ? 'Low Supply' : '',
            item.readyToEat ? 'Ready to Eat' : ''
        ].filter(Boolean).join(', ');
    }

    formatDietary(item) {
        return [
            item.kosher ? 'Kosher' : '',
            item.halal ? 'Halal' : '',
            item.vegetarian ? 'Vegetarian' : '',
            item.vegan ? 'Vegan' : '',
            item.glutenFree ? 'GF' : '',
            item.organic ? 'Organic' : ''
        ].filter(Boolean).join(', ');
    }

    formatLimit(item) {
        if (item.itemLimit === 0) {
            return 'No Limit';
        }
        const limitType = item.limitType === 'perPerson' ? 'Per Person' : 'Per Household';
        return `${item.itemLimit} ${limitType}`;
    }

    editFoodItem(itemData) {
        const data = typeof itemData === 'string' ? JSON.parse(itemData) : itemData;
        this.populateForm(data);
        this.form.querySelector('button[type="submit"]').textContent = 'Update Food Item';
    }

    populateForm(data) {
        document.getElementById('foodItemId').value = data.id;
        document.getElementById('foodItemName').value = data.name;
        document.getElementById('foodItemCategory').value = data.categoryId;
        document.getElementById('foodItemInStock').checked = data.inStock;
        document.getElementById('foodItemMustGo').checked = data.mustGo;
        document.getElementById('foodItemLowSupply').checked = data.lowSupply;
        document.getElementById('foodItemKosher').checked = data.kosher;
        document.getElementById('foodItemHalal').checked = data.halal;
        document.getElementById('foodItemVegetarian').checked = data.vegetarian;
        document.getElementById('foodItemVegan').checked = data.vegan;
        document.getElementById('foodItemGlutenFree').checked = data.glutenFree;
        document.getElementById('foodItemOrganic').checked = data.organic;
        document.getElementById('foodItemReadyToEat').checked = data.readyToEat;

        const globalUpperLimit = this.settingsManager.getCurrentLimit();
        const limitTypeInputs = document.querySelectorAll('input[name="limitType"]');
        
        limitTypeInputs.forEach(r => {
            r.checked = (r.value === data.limitType);
        });

        const limitValue = Math.min(data.itemLimit, globalUpperLimit);
        this.itemLimitValue.value = limitValue;
    }

    async deleteFoodItem(id) {
        if (!confirm('Are you sure you want to delete this food item?')) return;
        
        try {
            await apiDelete(`/api/food-items/${id}`);
            showMessage('Food item deleted successfully', 'success', 'foodItem');
            await this.loadFoodItems();
        } catch (error) {
            showMessage(error.message, 'error', 'foodItem');
        }
    }

    resetForm() {
        this.form.reset();
        document.getElementById('foodItemId').value = '';
        this.form.querySelector('button[type="submit"]').textContent = 'Add Food Item';
    }
}
</file>

<file path="packages/backend/public/js/languages.js">
import { showMessage, apiGet, apiPost } from './utils.js';

export class LanguageManager {
    constructor() {
        this.languageTableBody = document.getElementById('languageTableBody');
        this.updateLanguagesBtn = document.getElementById('updateLanguages');
        this.languageGrid = document.querySelector('.language-grid');
        this.filterSelect = document.getElementById('languageFilter');
        this.setupEventListeners();
    }

    setupEventListeners() {
        this.updateLanguagesBtn.addEventListener('click', () => this.handleLanguageUpdate());
        this.filterSelect.addEventListener('change', () => this.loadLanguages());
    }

    async loadLanguages() {
        try {
            const data = await apiGet('/api/languages');
            const languages = this.filterLanguages(data.data);
            this.displayLanguages(languages);
            this.displayLanguageToggles(data.data);
        } catch (error) {
            showMessage(error.message, 'error', 'language');
        }
    }

    filterLanguages(languages) {
        const filterValue = this.filterSelect.value;
        switch (filterValue) {
            case 'active':
                return languages.filter(lang => lang.active);
            case 'inactive':
                return languages.filter(lang => !lang.active);
            default:
                return languages;
        }
    }

    displayLanguageToggles(languages) {
        this.languageGrid.innerHTML = languages.map(lang => `
            <div class="language-toggle">
                <label>
                    <input type="checkbox" 
                           class="language-checkbox" 
                           data-code="${lang.code}"
                           data-name="${lang.name}"
                           ${lang.active ? 'checked' : ''}>
                    ${lang.name}
                </label>
            </div>
        `).join('');
    }

    async handleLanguageUpdate() {
        try {
            const languages = Array.from(document.querySelectorAll('.language-checkbox'))
                .filter(checkbox => checkbox.checked)
                .map(checkbox => ({
                    code: checkbox.dataset.code,
                    name: checkbox.dataset.name
                }));

            await apiPost('/api/languages/bulk', { languages });
            showMessage('Language settings updated successfully', 'success', 'language');
            await this.loadLanguages();
            document.dispatchEvent(new Event('languagesUpdated'));
        } catch (error) {
            showMessage(error.message, 'error', 'language');
        }
    }

    displayLanguages(languages) {
        if (!Array.isArray(languages)) {
            showMessage('Invalid language data received', 'error', 'language');
            return;
        }

        this.languageTableBody.innerHTML = languages
            .map(lang => this.createLanguageRow(lang))
            .join('');
    }

    createLanguageRow(language) {
        return `
            <tr>
                <td class="table__cell">${language.code}</td>
                <td class="table__cell">${language.name}</td>
                <td class="table__cell">${language.active ? 'Active' : 'Inactive'}</td>
            </tr>
        `;
    }
}
</file>

<file path="packages/backend/public/js/main.js">
export const managers = {
    settings: null,
    languages: null,
    categories: null,
    foodItems: null,
    translations: null
};

// Create custom event for category changes
export const EVENTS = {
    CATEGORY_UPDATED: 'categoryUpdated'
};

document.addEventListener('DOMContentLoaded', async () => {
    try {
        const { SettingsManager } = await import('./settings.js');
        const { LanguageManager } = await import('./languages.js');
        const { CategoryManager } = await import('./categories.js');
        const { FoodItemManager } = await import('./foodItems.js');
        const { TranslationManager } = await import('./translations.js');

        managers.settings = new SettingsManager();
        managers.languages = new LanguageManager();
        managers.categories = new CategoryManager();
        managers.foodItems = new FoodItemManager(managers.settings);
        managers.translations = new TranslationManager();
        
        await managers.settings.loadGlobalSettings();
        await managers.languages.loadLanguages();
        await managers.categories.loadCategories();
        await managers.foodItems.loadFoodItems();
        await managers.translations.loadTranslations();

        // Set up event listeners for cross-manager communication
        document.addEventListener(EVENTS.CATEGORY_UPDATED, async () => {
            if (managers.foodItems) {
                await managers.foodItems.loadCategories();
            }
        });

    } catch (error) {
        console.error('Error during initialization:', error);
    }
});
</file>

<file path="packages/backend/public/js/settings.js">
import { showMessage, apiGet, apiPost } from './utils.js';

export class SettingsManager {
    constructor() {
        this.globalUpperLimitInput = document.getElementById('globalUpperLimit');
        this.saveGlobalLimitBtn = document.getElementById('saveGlobalLimit');
        this.setupEventListeners();
    }

    setupEventListeners() {
        this.saveGlobalLimitBtn.addEventListener('click', () => this.saveGlobalSettings());
        this.globalUpperLimitInput.addEventListener('input', this.handleInputValidation.bind(this));
        this.globalUpperLimitInput.setAttribute('type', 'number');
        this.globalUpperLimitInput.setAttribute('min', '1');
    }

    async loadGlobalSettings() {
        try {
            const data = await apiGet('/api/settings');
            this.globalUpperLimitInput.value = data.data.globalUpperLimit;
        } catch (error) {
            showMessage(error.message, 'error', 'settings');
        }
    }

    async saveGlobalSettings() {
        const globalUpperLimit = parseInt(this.globalUpperLimitInput.value);
        if (isNaN(globalUpperLimit) || globalUpperLimit < 1) {
            showMessage('Global upper limit must be at least 1', 'error', 'settings');
            this.globalUpperLimitInput.value = 1;
            return;
        }

        try {
            await apiPost('/api/settings', { globalUpperLimit });
            showMessage('Global upper limit saved successfully', 'success', 'settings');
        } catch (error) {
            showMessage(error.message, 'error', 'settings');
        }
    }

    handleInputValidation(e) {
        const value = parseInt(e.target.value);
        if (value < 1) {
            e.target.value = 1;
        }
    }

    getCurrentLimit() {
        return parseInt(this.globalUpperLimitInput.value) || 10;
    }
}
</file>

<file path="packages/backend/public/js/translations.js">
import { showMessage, apiGet, apiPut, apiDelete } from './utils.js';

export class TranslationManager {
    constructor() {
        this.translationTableBody = document.getElementById('translationTableBody');
        this.translationTypeRadios = document.querySelectorAll('input[name="translationType"]');
        this.filterLanguageSelect = document.getElementById('filterLanguage');
        this.setupEventListeners();
        this.currentType = 'category';
        this.loadLanguagesFilter();
    }

    async loadLanguagesFilter() {
        try {
            const data = await apiGet('/api/languages');
            this.updateLanguageFilter(data.data);
        } catch (error) {
            showMessage(error.message, 'error', 'translation');
        }
    }

    updateLanguageFilter(languages) {
        if (!this.filterLanguageSelect) return;
        
        const currentValue = this.filterLanguageSelect.value;
        this.filterLanguageSelect.innerHTML = `
            <option value="">All Languages</option>
            ${languages
                .map(lang => `<option value="${lang.code}" ${lang.code === currentValue ? 'selected' : ''}>${lang.name}</option>`)
                .join('')}
        `;
    }

    isTypeCategory() {
        return this.currentType === 'category';
    }

    isTypeFoodItem() {
        return this.currentType === 'foodItem';
    }

    setupEventListeners() {
        this.translationTypeRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                this.currentType = radio.value;
                this.loadTranslations();
            });
        });

        this.filterLanguageSelect.addEventListener('change', () => {
            this.loadTranslations();
        });

        document.addEventListener('languagesUpdated', () => {
            this.loadLanguagesFilter();
            this.loadTranslations();
        });

        this.addTableEventListeners();
    }

    addTableEventListeners() {
        this.translationTableBody.addEventListener('click', async (e) => {
            const target = e.target;
            if (target.classList.contains('edit-translation-btn')) {
                await this.handleEditTranslation(target);
            } else if (target.classList.contains('delete-translation-btn')) {
                await this.handleDeleteTranslation(target);
            }
        });
    }

    async loadTranslations() {
        try {
            const type = this.currentType;
            const languageCode = this.filterLanguageSelect.value;
            const queryParams = new URLSearchParams({ type });
            if (languageCode) {
                queryParams.append('languageCode', languageCode);
            }
            
            const response = await apiGet(`/api/translations?${queryParams}`);
            this.displayTranslations(response.data);
        } catch (error) {
            showMessage(error.message, 'error', 'translation');
        }
    }

    displayTranslations(translations) {
        this.translationTableBody.innerHTML = '';
        if (!translations || translations.length === 0) {
            this.translationTableBody.innerHTML = '<tr><td colspan="6">No translations found</td></tr>';
            return;
        }
        translations.forEach(translation => {
            const row = this.createTranslationRow(translation);
            this.translationTableBody.appendChild(row);
        });
    }

    createTranslationRow(translation) {
        const row = document.createElement('tr');
        const originalText = translation.category ? translation.category.name : 
                           (translation.foodItem ? translation.foodItem.name : '');
        
        row.innerHTML = `
            <td class="table__cell">${originalText}</td>
            <td class="table__cell">${translation.language.name}</td>
            <td class="table__cell">${translation.translatedText}</td>
            <td class="table__cell">${translation.category ? 'Category' : 'Food Item'}</td>
            <td class="table__cell">${new Date(translation.createdAt).toLocaleDateString()}</td>
            <td class="table__cell">
                <button class="edit-translation-btn" 
                        data-id="${translation.id}"
                        data-current-text="${translation.translatedText}">
                    Edit
                </button>
                <button class="delete-translation-btn" data-id="${translation.id}">
                    Delete
                </button>
            </td>
        `;
        
        return row;
    }

    async handleEditTranslation(button) {
        const id = button.dataset.id;
        const currentText = button.dataset.currentText;
        const newText = prompt('Enter new translation:', currentText);
        
        if (newText && newText !== currentText) {
            try {
                await apiPut(`/api/translations/${id}`, { translatedText: newText });
                showMessage('Translation updated successfully', 'success', 'translation');
                await this.loadTranslations();
            } catch (error) {
                showMessage(error.message, 'error', 'translation');
            }
        }
    }

    async handleDeleteTranslation(button) {
        const id = button.dataset.id;
        if (confirm('Are you sure you want to delete this translation?')) {
            try {
                await apiDelete(`/api/translations/${id}`);
                showMessage('Translation deleted successfully', 'success', 'translation');
                await this.loadTranslations();
            } catch (error) {
                showMessage(error.message, 'error', 'translation');
            }
        }
    }

    updateTranslationTargets() {
        this.loadTranslations();
    }
}
</file>

<file path="packages/backend/public/js/utils.js">
export function showMessage(message, type = 'info', section = null) {
    const messageArea = section ? 
        document.querySelector(`#${section}Section .message-area`) : 
        document.getElementById('messageArea');
    
    if (!messageArea) return;

    const messageElement = document.createElement('div');
    messageElement.className = `message message--${type}`;
    messageElement.textContent = message;
    
    messageArea.innerHTML = '';
    messageArea.appendChild(messageElement);

    if (type === 'success') {
        setTimeout(() => messageElement.remove(), 5000);
    }
}

export function clearMessages(section = null) {
    const messageArea = section ? 
        document.querySelector(`#${section}Section .message-area`) : 
        document.getElementById('messageArea');
    
    if (messageArea) {
        messageArea.innerHTML = '';
    }
}

export async function apiGet(endpoint) {
    try {
        const response = await fetch(endpoint);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
    } catch (error) {
        console.error('API Get Error:', error);
        throw error;
    }
}

export async function apiPost(endpoint, data) {
    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data),
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
    } catch (error) {
        console.error('API Post Error:', error);
        throw error;
    }
}

export async function apiPut(endpoint, data) {
    try {
        const response = await fetch(endpoint, {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data),
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
    } catch (error) {
        console.error('API Put Error:', error);
        throw error;
    }
}

export async function apiDelete(endpoint) {
    try {
        const response = await fetch(endpoint, {
            method: 'DELETE',
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
    } catch (error) {
        console.error('API Delete Error:', error);
        throw error;
    }
}

export function formatDate(dateString) {
    const date = new Date(dateString);
    return new Intl.DateTimeFormat('default', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
    }).format(date);
}
</file>

<file path="packages/backend/public/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Food Pantry Management - Test UI</title>
    <link rel="stylesheet" href="css/styles.css" />
</head>
<body>
    <h1>Food Pantry Management - Test UI</h1>

    <!-- Global Settings -->
    <div id="settingsSection" class="section">
        <h2>Global Settings</h2>
        <div class="message-area"></div>
        <div class="form__group">
            <label for="globalUpperLimit">Global Upper Limit for "No Limit" Items:</label>
            <input type="number" id="globalUpperLimit" value="40" min="1">
            <button id="saveGlobalLimit">Save</button>
        </div>
        <p class="message message--note">
            This setting is now stored in the backend. Adjust it and click "Save" to persist.
            The "No Limit" items will consider this upper limit for future features.
        </p>
    </div>

    <!-- Language Management Section -->
    <div id="languageSection" class="section">
        <h2>Language Management</h2>
        <div class="message-area"></div>
        <p class="message message--warning">
            Note: Language support varies by region and complexity. AI translations may contain
            errors and should be reviewed for accuracy.
        </p>
        
        <div class="language-grid">
            <!-- Languages will be dynamically populated here -->
        </div>
        
        <button id="updateLanguages">Update Language Settings</button>
        
        <div id="activeLanguages">
            <div class="filter-controls">
                <label for="languageFilter">Filter By:</label>
                <select id="languageFilter">
                    <option value="all">All Languages</option>
                    <option value="active">Active Languages</option>
                    <option value="inactive">Inactive Languages</option>
                </select>
            </div>

            <table class="table">
                <thead>
                    <tr>
                        <th class="table__header">Code</th>
                        <th class="table__header">Name</th>
                        <th class="table__header">Status</th>
                    </tr>
                </thead>
                <tbody id="languageTableBody">
                    <!-- Active languages will be loaded here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Category Management Section -->
    <div id="categorySection" class="section">
        <h2>Category Management</h2>
        <div class="message-area"></div>
        <form id="categoryForm">
            <div class="form__group">
                <label for="categoryName">Category Name:</label>
                <input type="text" id="categoryName" name="categoryName" required>
            </div>
            <div class="form__group">
                <label for="categoryItemLimit">Item Limit:</label>
                <input type="number" id="categoryItemLimit" name="categoryItemLimit" min="0" value="0">
                <p class="message message--note">
                    Set to 0 for no limit. Global Upper Limit applies as a maximum threshold.
                    This limit applies to all items within this category.
                </p>
            </div>
            <input type="hidden" id="categoryId">
            <button type="submit">Add Category</button>
            <button type="button" id="resetForm">Clear Form</button>
        </form>
        <div id="categoryList">
            <h3>Categories</h3>
            <table class="table">
                <thead>
                    <tr>
                        <th class="table__header">Name</th>
                        <th class="table__header">Item Limit</th>
                        <th class="table__header">Created</th>
                        <th class="table__header">Actions</th>
                    </tr>
                </thead>
                <tbody id="categoryTableBody">
                    <!-- Categories will be loaded here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Food Items Section -->
    <div id="foodItemSection" class="section">
        <h2>Food Item Management</h2>
        <div class="message-area"></div>
        <form id="foodItemForm">
            <div class="form__group">
                <label for="foodItemName">Item Name:</label>
                <input type="text" id="foodItemName" name="foodItemName" required>
            </div>
            <div class="form__group">
                <label for="foodItemCategory">Category:</label>
                <select id="foodItemCategory" required></select>
            </div>
            <div class="form__group">
                <label for="foodItemInStock">In Stock:</label>
                <input type="checkbox" id="foodItemInStock" name="foodItemInStock" checked>
            </div>
            <div class="form__group">
                <h4>Status Flags</h4>
                <div class="toggle-group">
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemMustGo" name="mustGo">
                        Must Go
                    </label>
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemLowSupply" name="lowSupply">
                        Low Supply
                    </label>
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemReadyToEat" name="readyToEat">
                        Ready to Eat
                    </label>
                </div>
            </div>
            <div class="form__group">
                <h4>Dietary Flags</h4>
                <div class="toggle-group">
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemKosher" name="kosher">
                        Kosher
                    </label>
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemHalal" name="halal">
                        Halal
                    </label>
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemVegetarian" name="vegetarian">
                        Vegetarian
                    </label>
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemVegan" name="vegan">
                        Vegan
                    </label>
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemGlutenFree" name="glutenFree">
                        Gluten Free
                    </label>
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemOrganic" name="organic">
                        Organic
                    </label>
                </div>
            </div>
            <div class="form__group">
                <h4>Item Limit</h4>
                <div class="limit-options">
                    <label>
                        <input type="radio" name="limitType" value="perHousehold" checked>
                        Per Household
                    </label>
                    <label>
                        <input type="radio" name="limitType" value="perPerson">
                        Per Person
                    </label>
                    <div>
                        <label for="itemLimitValue">Limit Value:</label>
                        <input type="number" id="itemLimitValue" min="0" value="0">
                        <p class="message message--note">
                            Set to 0 for no limit. Global Upper Limit applies as a maximum threshold.
                        </p>
                    </div>
                </div>
            </div>
            <input type="hidden" id="foodItemId">
            <button type="submit">Add Food Item</button>
            <button type="button" id="resetFoodItemForm">Clear Form</button>
        </form>
        <div id="foodItemList">
            <h3>Food Items</h3>
            <table class="table">
                <thead>
                    <tr>
                        <th class="table__header">Name</th>
                        <th class="table__header">Category</th>
                        <th class="table__header">Status</th>
                        <th class="table__header">Dietary</th>
                        <th class="table__header">Limit</th>
                        <th class="table__header">Created</th>
                        <th class="table__header">Actions</th>
                    </tr>
                </thead>
                <tbody id="foodItemTableBody">
                    <!-- Food items will be loaded here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Translations Section -->
    <div id="translationSection" class="section">
        <h2>Translation Management</h2>
        <div class="message-area"></div>
        <p class="message message--note">
            Translations are automatically generated for all active languages.
            Manual edits may be overwritten during automated translation updates.
        </p>
        
        <div class="filter-controls">
            <div class="translation-type">
                <label>
                    <input type="radio" name="translationType" value="category" checked>
                    Categories
                </label>
                <label>
                    <input type="radio" name="translationType" value="foodItem">
                    Food Items
                </label>
            </div>
    
            <div class="language-filter">
                <label for="filterLanguage">Filter By Language:</label>
                <select id="filterLanguage">
                    <option value="">All Languages</option>
                </select>
            </div>
        </div>
    
        <div id="translationList">
            <table class="table">
                <thead>
                    <tr>
                        <th class="table__header">Original Text</th>
                        <th class="table__header">Language</th>
                        <th class="table__header">Translation</th>
                        <th class="table__header">Type</th>
                        <th class="table__header">Created</th>
                        <th class="table__header">Actions</th>
                    </tr>
                </thead>
                <tbody id="translationTableBody"></tbody>
            </table>
        </div>
    </div>

    <!-- Load main.js as a module, which will import other JS modules -->
    <script type="module" src="js/main.js"></script>
</body>
</html>
</file>

<file path="packages/backend/src/config/languageConfig.ts">
export const LanguageConfig = {
    DEFAULT_LANGUAGE: 'en',
    SUPPORTED_LANGUAGES: [
        { code: 'en', name: 'English' },
        { code: 'sq', name: 'Albanian' },
        { code: 'am', name: 'Amharic' },
        { code: 'ar', name: 'Arabic' },
        { code: 'hy', name: 'Armenian' },
        { code: 'bn', name: 'Bengali' },
        { code: 'bs', name: 'Bosnian' },
        { code: 'bg', name: 'Bulgarian' },
        { code: 'my', name: 'Burmese' },
        { code: 'ca', name: 'Catalan' },
        { code: 'zh', name: 'Chinese' },
        { code: 'hr', name: 'Croatian' },
        { code: 'cs', name: 'Czech' },
        { code: 'da', name: 'Danish' },
        { code: 'nl', name: 'Dutch' },
        { code: 'et', name: 'Estonian' },
        { code: 'fi', name: 'Finnish' },
        { code: 'fr', name: 'French' },
        { code: 'ka', name: 'Georgian' },
        { code: 'de', name: 'German' },
        { code: 'el', name: 'Greek' },
        { code: 'gu', name: 'Gujarati' },
        { code: 'hi', name: 'Hindi' },
        { code: 'hu', name: 'Hungarian' },
        { code: 'is', name: 'Icelandic' },
        { code: 'id', name: 'Indonesian' },
        { code: 'it', name: 'Italian' },
        { code: 'ja', name: 'Japanese' },
        { code: 'kn', name: 'Kannada' },
        { code: 'kk', name: 'Kazakh' },
        { code: 'ko', name: 'Korean' },
        { code: 'lv', name: 'Latvian' },
        { code: 'lt', name: 'Lithuanian' },
        { code: 'mk', name: 'Macedonian' },
        { code: 'ms', name: 'Malay' },
        { code: 'ml', name: 'Malayalam' },
        { code: 'mr', name: 'Marathi' },
        { code: 'mn', name: 'Mongolian' },
        { code: 'no', name: 'Norwegian' },
        { code: 'fa', name: 'Persian' },
        { code: 'pl', name: 'Polish' },
        { code: 'pt', name: 'Portuguese' },
        { code: 'pa', name: 'Punjabi' },
        { code: 'ro', name: 'Romanian' },
        { code: 'ru', name: 'Russian' },
        { code: 'sr', name: 'Serbian' },
        { code: 'sk', name: 'Slovak' },
        { code: 'sl', name: 'Slovenian' },
        { code: 'so', name: 'Somali' },
        { code: 'es', name: 'Spanish' },
        { code: 'sw', name: 'Swahili' },
        { code: 'sv', name: 'Swedish' },
        { code: 'tl', name: 'Tagalog' },
        { code: 'ta', name: 'Tamil' },
        { code: 'te', name: 'Telugu' },
        { code: 'th', name: 'Thai' },
        { code: 'tr', name: 'Turkish' },
        { code: 'uk', name: 'Ukrainian' },
        { code: 'ur', name: 'Urdu' },
        { code: 'vi', name: 'Vietnamese' }
    ]
};

export const DEFAULT_ACTIVE_LANGUAGES = ['en', 'es', 'fr', 'zh'];

export const isValidLanguageCode = (code: string): boolean => {
    return LanguageConfig.SUPPORTED_LANGUAGES.some(lang => lang.code === code);
};

export const getLanguageName = (code: string): string => {
    const language = LanguageConfig.SUPPORTED_LANGUAGES.find(lang => lang.code === code);
    return language ? language.name : code;
};

export const getDefaultLanguages = () => {
    return LanguageConfig.SUPPORTED_LANGUAGES.map(lang => ({
        ...lang,
        active: DEFAULT_ACTIVE_LANGUAGES.includes(lang.code)
    }));
};
</file>

<file path="packages/backend/src/middleware/errorHandler.ts">
import { Request, Response, NextFunction } from 'express';
import { ApiError, isApiError } from '../utils/ApiError';
import { SettingsValidationError } from '../utils/ApiError';

export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  // Handle known ApiError types
  if (isApiError(err)) {
    return res.status(err.statusCode).json({
      success: false,
      status: err.statusCode,
      message: err.message,
      stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
  }

  // Handle settings-specific errors
  if (err instanceof SettingsValidationError) {
    return res.status(400).json({
      success: false,
      status: 400,
      message: err.message,
      stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
  }

  // Handle unknown errors
  return res.status(500).json({
    success: false,
    status: 500,
    message: 'Internal Server Error',
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
  });
};
</file>

<file path="packages/backend/src/middleware/requestLogger.ts">
import { Request, Response, NextFunction } from 'express';

export const requestLogger = (req: Request, res: Response, next: NextFunction) => {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] ${req.method} ${req.url}`);
  next();
};
</file>

<file path="packages/backend/src/routes/categoryRoutes.ts">
import { Router } from 'express';
import { CategoryService } from '../services/CategoryService';
import { ApiResponse } from '../utils/ApiResponse';
import { ApiError } from '../utils/ApiError';

const router = Router();
const categoryService = new CategoryService();

// GET /categories
router.get('/', async (req, res, next) => {
    try {
        const categories = await categoryService.findAll();
        res.json(ApiResponse.success(categories));
    } catch (error) {
        next(error);
    }
});

// GET /categories/:id
router.get('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid category ID');
        }

        const category = await categoryService.findById(id);
        if (!category) {
            throw new ApiError(404, 'Category not found');
        }

        res.json(ApiResponse.success(category));
    } catch (error) {
        next(error);
    }
});

// POST /categories
router.post('/', async (req, res, next) => {
    try {
        const { name, itemLimit = 0 } = req.body;
        if (!name || name.trim() === '') {
            throw new ApiError(400, 'Category name is required');
        }

        const parsedLimit = parseInt(itemLimit);
        if (isNaN(parsedLimit) || parsedLimit < 0) {
            throw new ApiError(400, 'Item limit must be a non-negative number');
        }

        const category = await categoryService.create({ 
            name: name.trim(), 
            itemLimit: parsedLimit 
        });

        res.status(201).json(ApiResponse.success(category, 'Category created successfully'));
    } catch (error) {
        next(error);
    }
});

// PUT /categories/:id
router.put('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid category ID');
        }

        const { name, itemLimit } = req.body;
        const updateData: { name?: string; itemLimit?: number } = {};

        if (name !== undefined) {
            if (name.trim() === '') {
                throw new ApiError(400, 'Category name cannot be empty');
            }
            updateData.name = name.trim();
        }

        if (itemLimit !== undefined) {
            const parsedLimit = parseInt(itemLimit);
            if (isNaN(parsedLimit) || parsedLimit < 0) {
                throw new ApiError(400, 'Item limit must be a non-negative number');
            }
            updateData.itemLimit = parsedLimit;
        }

        const category = await categoryService.update(id, updateData);
        res.json(ApiResponse.success(category, 'Category updated successfully'));
    } catch (error) {
        next(error);
    }
});

// DELETE /categories/:id
router.delete('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid category ID');
        }

        await categoryService.delete(id);
        res.json(ApiResponse.success(null, 'Category deleted successfully'));
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="packages/backend/src/routes/foodItemRoutes.ts">
import { Router } from 'express';
import { FoodItemService } from '../services/FoodItemService';
import { ApiResponse } from '../utils/ApiResponse';
import { ApiError } from '../utils/ApiError';

const router = Router();
const foodItemService = new FoodItemService();

// GET /food-items
router.get('/', async (req, res, next) => {
  try {
    const { categoryId, includeOutOfStock, page, limit } = req.query;
    
    const params = {
      categoryId: categoryId ? parseInt(categoryId as string) : undefined,
      includeOutOfStock: includeOutOfStock === 'true',
      page: page ? parseInt(page as string) : 1,
      limit: limit ? parseInt(limit as string) : 50
    };

    const items = await foodItemService.findAll(params);
    return res.json(ApiResponse.success(items));
  } catch (error) {
    next(error);
  }
});

// GET /food-items/:id
router.get('/:id', async (req, res, next) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      throw new ApiError(400, 'Invalid food item ID');
    }

    const foodItem = await foodItemService.findById(id);
    res.json(ApiResponse.success(foodItem));
  } catch (error) {
    next(error);
  }
});

// POST /food-items
router.post('/', async (req, res, next) => {
  try {
    const { 
      name, 
      categoryId,
      itemLimit,
      inStock,
      mustGo,
      lowSupply,
      kosher,
      halal,
      vegetarian,
      vegan,
      glutenFree,
      organic,
      readyToEat,
      customFields 
    } = req.body;

    if (!name || typeof name !== 'string') {
      throw new ApiError(400, 'Name is required and must be a string');
    }

    if (!categoryId || typeof categoryId !== 'number') {
      throw new ApiError(400, 'Valid category ID is required');
    }

    const foodItem = await foodItemService.create({
      name,
      categoryId,
      itemLimit,
      inStock,
      mustGo,
      lowSupply,
      kosher,
      halal,
      vegetarian,
      vegan,
      glutenFree,
      organic,
      readyToEat,
      customFields
    });

    res.status(201).json(ApiResponse.success(foodItem, 'Food item created successfully'));
  } catch (error) {
    next(error);
  }
});

// PUT /food-items/:id
router.put('/:id', async (req, res, next) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      throw new ApiError(400, 'Invalid food item ID');
    }

    console.log('Update Food Item - Request Body:', req.body);
    console.log('Update Food Item - ID:', id);

    // Check if the item exists
    const existingItem = await foodItemService.findById(id);
    if (!existingItem) {
      throw new ApiError(404, 'Food item not found');
    }

    console.log('Existing Item Found:', existingItem);

    // Type check categoryId
    if (req.body.categoryId && typeof req.body.categoryId !== 'number') {
      console.log('Invalid categoryId type:', typeof req.body.categoryId);
      throw new ApiError(400, 'Category ID must be a number');
    }

    // Validate update data
    const updateData = {
      name: req.body.name,
      categoryId: req.body.categoryId,
      itemLimit: req.body.itemLimit,
      limitType: req.body.limitType,
      inStock: req.body.inStock,
      mustGo: req.body.mustGo,
      lowSupply: req.body.lowSupply,
      kosher: req.body.kosher,
      halal: req.body.halal,
      vegetarian: req.body.vegetarian,
      vegan: req.body.vegan,
      glutenFree: req.body.glutenFree,
      organic: req.body.organic,
      readyToEat: req.body.readyToEat
    };

    console.log('Processed Update Data:', updateData);

    const foodItem = await foodItemService.update(id, updateData);
    console.log('Update Successful:', foodItem);

    res.json(ApiResponse.success(foodItem, 'Food item updated successfully'));
  } catch (error) {
    console.error('Update Error:', error);
    next(error);
  }
});

// DELETE /food-items/:id
router.delete('/:id', async (req, res, next) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      throw new ApiError(400, 'Invalid food item ID');
    }

    // Check if the item exists
    const existingItem = await foodItemService.findById(id);
    if (!existingItem) {
      throw new ApiError(404, 'Food item not found');
    }

    await foodItemService.delete(id);
    res.json(ApiResponse.success(null, 'Food item deleted successfully'));
  } catch (error) {
    next(error);
  }
});

export default router;
</file>

<file path="packages/backend/src/routes/languageRoutes.ts">
import { Router } from 'express';
import { LanguageService } from '../services/LanguageService';
import { ApiResponse } from '../utils/ApiResponse';
import { ApiError } from '../utils/ApiError';

const router = Router();
const languageService = new LanguageService();

// GET /api/languages
router.get('/', async (req, res, next) => {
    try {
        console.log('GET /api/languages - Starting request');
        const languages = await languageService.findAll();
        console.log(`GET /api/languages - Found ${languages.length} languages`);
        res.json(ApiResponse.success(languages));
    } catch (error) {
        console.error('GET /api/languages - Error:', error);
        next(error);
    }
});

// POST /api/languages/bulk
router.post('/bulk', async (req, res, next) => {
    try {
        console.log('POST /api/languages/bulk - Starting request');
        const { languages } = req.body;
        
        if (!Array.isArray(languages)) {
            throw new ApiError(400, 'Invalid languages data');
        }

        const updatedLanguages = await languageService.bulkUpdate(languages);
        console.log(`POST /api/languages/bulk - Updated ${updatedLanguages.length} languages`);
        res.json(ApiResponse.success(updatedLanguages, 'Languages updated successfully'));
    } catch (error) {
        console.error('POST /api/languages/bulk - Error:', error);
        next(error);
    }
});

// GET /api/languages/active
router.get('/active', async (req, res, next) => {
    try {
        console.log('GET /api/languages/active - Starting request');
        const languages = await languageService.findActive();
        console.log(`GET /api/languages/active - Found ${languages.length} active languages`);
        res.json(ApiResponse.success(languages));
    } catch (error) {
        console.error('GET /api/languages/active - Error:', error);
        next(error);
    }
});

export default router;
</file>

<file path="packages/backend/src/routes/settingsRoutes.ts">
import { Router } from 'express';
import { PrismaClient } from '@prisma/client';
import { ApiResponse } from '../utils/ApiResponse';
import { SettingsValidationError } from '../utils/ApiError';

const router = Router();
const prisma = new PrismaClient();

// GET /api/settings
router.get('/', async (req, res, next) => {
    try {
        const settings = await prisma.settings.findUnique({
            where: { id: 1 }
        });

        // If no settings exist, return default value of 10
        if (!settings) {
            return res.json(ApiResponse.success({
                globalUpperLimit: 10
            }));
        }

        res.json(ApiResponse.success({
            globalUpperLimit: settings.globalUpperLimit
        }));
    } catch (error) {
        next(error);
    }
});

// POST /api/settings
router.post('/', async (req, res, next) => {
    try {
        const { globalUpperLimit } = req.body;

        // Validate input
        if (globalUpperLimit === undefined || globalUpperLimit === null) {
            throw new SettingsValidationError('Global upper limit is required');
        }

        if (typeof globalUpperLimit !== 'number' || !Number.isInteger(globalUpperLimit)) {
            throw new SettingsValidationError('Global upper limit must be an integer');
        }

        if (globalUpperLimit < 1) {
            throw new SettingsValidationError('Global upper limit must be at least 1');
        }

        const settings = await prisma.settings.upsert({
            where: { id: 1 },
            update: {
                globalUpperLimit,
                updatedAt: new Date()
            },
            create: {
                globalUpperLimit,
                id: 1
            }
        });

        res.json(ApiResponse.success(settings, 'Settings updated successfully'));
    } catch (error) {
        next(error);
    } finally {
        await prisma.$disconnect(); // Ensure Prisma disconnects after handling the request
    }
});

export default router;
</file>

<file path="packages/backend/src/routes/translationRoutes.ts">
import { Router } from 'express';
import { TranslationService } from '../services/TranslationService';
import { ApiResponse } from '../utils/ApiResponse';
import { ApiError } from '../utils/ApiError';

const router = Router();
const translationService = new TranslationService();

// GET /translations
router.get('/', async (req, res, next) => {
    try {
        const { languageCode, categoryId, foodItemId, type } = req.query;
        console.log('Translation query params:', { languageCode, categoryId, foodItemId, type });

        if (type && !['category', 'foodItem'].includes(type as string)) {
            throw new ApiError(400, 'Invalid type parameter. Must be either "category" or "foodItem"');
        }

        const params = {
            languageCode: languageCode as string,
            categoryId: categoryId ? parseInt(categoryId as string) : undefined,
            foodItemId: foodItemId ? parseInt(foodItemId as string) : undefined,
            type: type as 'category' | 'foodItem' | undefined
        };
        console.log('Processed params:', params);

        const translations = await translationService.findAll(params);
        console.log('Found translations:', translations);

        res.json(ApiResponse.success(translations));
    } catch (error) {
        console.error('Translation error:', error);
        next(error);
    }
});

// GET /translations/language/:languageCode
router.get('/language/:languageCode', async (req, res, next) => {
    try {
        const { languageCode } = req.params;
        const { categoryId, foodItemId } = req.query;

        const params = {
            categoryId: categoryId ? parseInt(categoryId as string) : undefined,
            foodItemId: foodItemId ? parseInt(foodItemId as string) : undefined
        };

        const translations = await translationService.findByLanguage(languageCode, params);
        res.json(ApiResponse.success(translations));
    } catch (error) {
        next(error);
    }
});

// POST /translations/category/:categoryId
router.post('/category/:categoryId', async (req, res, next) => {
    try {
        const categoryId = parseInt(req.params.categoryId);
        if (isNaN(categoryId)) {
            throw new ApiError(400, 'Invalid category ID');
        }

        const { languageCode, translatedText } = req.body;
        if (!languageCode || !translatedText) {
            throw new ApiError(400, 'Language code and translated text are required');
        }

        const translation = await translationService.createForCategory(categoryId, {
            languageCode,
            translatedText
        });

        res.status(201).json(ApiResponse.success(translation, 'Translation created successfully'));
    } catch (error) {
        next(error);
    }
});

// POST /translations/food-item/:foodItemId
router.post('/food-item/:foodItemId', async (req, res, next) => {
    try {
        const foodItemId = parseInt(req.params.foodItemId);
        if (isNaN(foodItemId)) {
            throw new ApiError(400, 'Invalid food item ID');
        }

        const { languageCode, translatedText } = req.body;
        if (!languageCode || !translatedText) {
            throw new ApiError(400, 'Language code and translated text are required');
        }

        const translation = await translationService.createForFoodItem(foodItemId, {
            languageCode,
            translatedText
        });

        res.status(201).json(ApiResponse.success(translation, 'Translation created successfully'));
    } catch (error) {
        next(error);
    }
});

// GET /translations/:id
router.get('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid translation ID');
        }

        const translation = await translationService.findById(id);
        res.json(ApiResponse.success(translation));
    } catch (error) {
        next(error);
    }
});

// PUT /translations/:id
router.put('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid translation ID');
        }

        const translation = await translationService.findById(id);
        if (!translation) {
            throw new ApiError(404, 'Translation not found');
        }

        const { translatedText } = req.body;
        if (!translatedText) {
            throw new ApiError(400, 'Translated text is required');
        }

        const updatedTranslation = await translationService.update(id, { translatedText });
        res.json(ApiResponse.success(updatedTranslation, 'Translation updated successfully'));
    } catch (error) {
        next(error);
    }
});

// DELETE /translations/:id
router.delete('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid translation ID');
        }

        const translation = await translationService.findById(id);
        if (!translation) {
            throw new ApiError(404, 'Translation not found');
        }

        await translationService.delete(id);
        res.json(ApiResponse.success(null, 'Translation deleted successfully'));
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="packages/backend/src/services/openai/__tests__/OpenAIService.test.ts">
import { OpenAIService } from '../OpenAIService';
import { ApiError } from '../../../utils/ApiError';

// Mock OpenAI responses
const mockCreateCompletion = jest.fn();
jest.mock('openai', () => ({
    OpenAI: jest.fn().mockImplementation(() => ({
        chat: {
            completions: {
                create: mockCreateCompletion
            }
        }
    }))
}));

describe('OpenAIService', () => {
    let service: OpenAIService;

    beforeEach(() => {
        process.env.OPENAI_API_KEY = 'test-key';
        process.env.OPENAI_MODEL = 'gpt-4o-mini';
        mockCreateCompletion.mockClear();
        service = new OpenAIService();
    });

    describe('initialization', () => {
        it('should initialize with valid API key', () => {
            expect(() => new OpenAIService()).not.toThrow();
        });

        it('should throw error when API key is missing', () => {
            delete process.env.OPENAI_API_KEY;
            expect(() => new OpenAIService()).toThrow('OpenAI API key is not configured');
        });
    });

    describe('translateText', () => {
        beforeEach(() => {
            mockCreateCompletion.mockResolvedValue({
                choices: [{ message: { content: 'manzana', role: 'assistant' } }]
            });
        });

        it('should translate text successfully', async () => {
            const result = await service.translateText('apple', 'es', 'foodItem');
            expect(result).toBe('manzana');
            expect(mockCreateCompletion).toHaveBeenCalledWith(expect.objectContaining({
                temperature: 0.3,
                max_tokens: 100
            }));
        });

        it('should handle empty responses', async () => {
            mockCreateCompletion.mockResolvedValue({
                choices: [{ message: { content: '', role: 'assistant' } }]
            });
            await expect(service.translateText('apple', 'es', 'foodItem'))
                .rejects
                .toThrow('Translation failed - empty response');
        });

        it('should handle API errors', async () => {
            mockCreateCompletion.mockRejectedValue(new Error('API Error'));
            await expect(service.translateText('apple', 'es', 'foodItem'))
                .rejects
                .toThrow('Translation failed: API Error');
        });
    });

    describe('testConnection', () => {
        it('should return true for successful connection', async () => {
            mockCreateCompletion.mockResolvedValue({
                choices: [{ message: { content: 'OK', role: 'assistant' } }]
            });
            const result = await service.testConnection();
            expect(result).toBe(true);
        });

        it('should return false for failed connection', async () => {
            mockCreateCompletion.mockRejectedValue(new Error('Connection failed'));
            const result = await service.testConnection();
            expect(result).toBe(false);
        });
    });

    describe('bulkTranslate', () => {
        const testItems = [
            { id: 1, text: 'apple' },
            { id: 2, text: 'banana' }
        ];

        beforeEach(() => {
            mockCreateCompletion
                .mockResolvedValueOnce({
                    choices: [{ message: { content: 'manzana', role: 'assistant' } }]
                })
                .mockResolvedValueOnce({
                    choices: [{ message: { content: 'plátano', role: 'assistant' } }]
                });
        });

        it('should translate multiple items successfully', async () => {
            const results = await service.bulkTranslate(testItems, 'es', 'foodItem');
            expect(results).toEqual([
                { id: 1, translation: 'manzana' },
                { id: 2, translation: 'plátano' }
            ]);
        });

        it('should handle partial failures in bulk translation', async () => {
            mockCreateCompletion
                .mockResolvedValueOnce({
                    choices: [{ message: { content: 'manzana', role: 'assistant' } }]
                })
                .mockRejectedValueOnce(new Error('API Error'));

            const results = await service.bulkTranslate(testItems, 'es', 'foodItem');
            expect(results).toEqual([
                { id: 1, translation: 'manzana' },
                { id: 2, translation: '' }
            ]);
        });

        it('should respect rate limiting with delays', async () => {
            const startTime = Date.now();
            await service.bulkTranslate(testItems, 'es', 'foodItem');
            const duration = Date.now() - startTime;
            expect(duration).toBeGreaterThanOrEqual(200); // At least 200ms delay
        });
    });
});
</file>

<file path="packages/backend/src/services/openai/OpenAIService.ts">
import { OpenAI } from 'openai';
import { ApiError } from '../../utils/ApiError';
import { LanguageConfig, getLanguageName } from '../../config/languageConfig';

export class OpenAIService {
    private client: OpenAI;
    private readonly maxRetries = 3;
    private readonly retryDelay = 1000; // 1 second

    constructor() {
        if (!process.env.OPENAI_API_KEY) {
            throw new ApiError(500, 'OpenAI API key is not configured');
        }
        this.client = new OpenAI({ 
            apiKey: process.env.OPENAI_API_KEY,
            maxRetries: this.maxRetries
        });
    }

    async translateText(
        text: string, 
        targetLanguage: string, 
        context: 'category' | 'foodItem'
    ): Promise<string> {
        const languageName = getLanguageName(targetLanguage);
        
        try {
            const systemPrompt = this.buildSystemPrompt(context, languageName);
            const response = await this.client.chat.completions.create({
                model: process.env.OPENAI_MODEL || 'gpt-4o-mini',
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: text }
                ],
                temperature: 0.3, // Lower temperature for more consistent translations
                max_tokens: 100  // Limit response length for efficiency
            });

            const translation = response.choices[0]?.message?.content?.trim();
            if (!translation) {
                throw new ApiError(500, 'Translation failed - empty response');
            }

            return translation;
        } catch (error) {
            console.error('Translation error:', error);
            throw new ApiError(500, `Translation failed: ${(error as Error).message}`);
        }
    }

    private buildSystemPrompt(context: 'category' | 'foodItem', languageName: string): string {
        const contextPrompts = {
            category: `You are a professional translator specializing in food categories. 
                      Translate the following category name to ${languageName}. 
                      Keep the translation concise and commonly used in food contexts.`,
            foodItem: `You are a professional translator specializing in food items. 
                      Translate the following food item name to ${languageName}. 
                      Use the most common term that would be recognized by native speakers.`
        };

        return contextPrompts[context];
    }

    async testConnection(): Promise<boolean> {
        try {
            const response = await this.client.chat.completions.create({
                model: process.env.OPENAI_MODEL || 'gpt-4o-mini',
                messages: [
                    { role: 'system', content: 'Respond with "OK" if you can read this.' },
                    { role: 'user', content: 'Connection test' }
                ],
                max_tokens: 5
            });
            
            return response.choices[0]?.message?.content?.includes('OK') ?? false;
        } catch (error) {
            console.error('OpenAI connection test failed:', error);
            return false;
        }
    }

    async bulkTranslate(
        items: Array<{ id: number; text: string }>, 
        targetLanguage: string, 
        context: 'category' | 'foodItem'
    ): Promise<Array<{ id: number; translation: string }>> {
        const results = [];
        
        for (const item of items) {
            try {
                const translation = await this.translateText(item.text, targetLanguage, context);
                results.push({ id: item.id, translation });
                // Add small delay between requests to respect rate limits
                await new Promise(resolve => setTimeout(resolve, 200));
            } catch (error) {
                console.error(`Translation failed for item ${item.id}:`, error);
                results.push({ id: item.id, translation: '' });
            }
        }

        return results;
    }
}
</file>

<file path="packages/backend/src/services/CategoryService.ts">
import { PrismaClient, Category } from '@prisma/client';
import { ApiError } from '../utils/ApiError';
import { TranslationService } from './TranslationService';
import { ErrorTypes, ErrorMessages } from '../utils/errorConstants';
import { handleServiceError } from '../utils/errorHandler';

export class CategoryService {
    private prisma: PrismaClient;
    private translationService: TranslationService;

    constructor() {
        this.prisma = new PrismaClient();
        this.translationService = new TranslationService();
    }

    async create(data: { name: string; itemLimit?: number }): Promise<Category> {
        try {
            // Validate itemLimit
            if (data.itemLimit !== undefined) {
                if (data.itemLimit < 0) {
                    throw new ApiError(400, 'Item limit cannot be negative');
                }
            }

            const category = await this.prisma.category.create({
                data: {
                    name: data.name,
                    itemLimit: data.itemLimit || 0
                },
                include: {
                    translations: {
                        include: {
                            language: true
                        }
                    }
                }
            });

            this.translationService.generateAutomaticTranslations(category.id, 'category')
                .catch(error => console.error('Translation generation failed:', error));

            return category;
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.CREATE_ERROR('category'));
        }
    }

    async findAll(): Promise<Category[]> {
        try {
            return await this.prisma.category.findMany({
                include: {
                    translations: {
                        include: {
                            language: true
                        }
                    }
                }
            });
        } catch (error) {
            throw handleServiceError(error, 'Error fetching categories');
        }
    }

    async findById(id: number): Promise<Category | null> {
        try {
            const category = await this.prisma.category.findUnique({
                where: { id },
                include: {
                    translations: {
                        include: {
                            language: true
                        }
                    }
                }
            });

            if (!category) {
                throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.CATEGORY_NOT_FOUND);
            }

            return category;
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.CATEGORY_NOT_FOUND);
        }
    }

    async update(id: number, data: { name?: string; itemLimit?: number }): Promise<Category> {
        try {
            const existingCategory = await this.findById(id);

            // Validate itemLimit
            if (data.itemLimit !== undefined) {
                if (data.itemLimit < 0) {
                    throw new ApiError(400, 'Item limit cannot be negative');
                }
            }

            const updated = await this.prisma.category.update({
                where: { id },
                data: {
                    name: data.name,
                    itemLimit: data.itemLimit
                },
                include: {
                    translations: {
                        include: {
                            language: true
                        }
                    }
                }
            });

            if (existingCategory && data.name && data.name !== existingCategory.name) {
                this.translationService.generateAutomaticTranslations(id, 'category')
                    .catch(error => console.error('Translation update failed:', error));
            }

            return updated;
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.UPDATE_ERROR('category'));
        }
    }

    async delete(id: number): Promise<void> {
        try {
            await this.findById(id);
            await this.prisma.category.delete({ where: { id } });
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.DELETE_ERROR('category'));
        }
    }
}
</file>

<file path="packages/backend/src/services/FoodItemService.ts">
import { PrismaClient, FoodItem, Prisma } from '@prisma/client';
import { ApiError } from '../utils/ApiError';
import { TranslationService } from './TranslationService';
import { ErrorTypes, ErrorMessages } from '../utils/errorConstants';
import { handleServiceError } from '../utils/errorHandler';

type FoodItemCreateInput = Prisma.FoodItemCreateInput;
type FoodItemUpdateInput = Prisma.FoodItemUpdateInput;

export class FoodItemService {
  private prisma: PrismaClient;
  private translationService: TranslationService;
  private testMode: boolean;

  constructor(testMode = false) {
    this.prisma = new PrismaClient();
    this.translationService = new TranslationService();
    this.testMode = testMode;
  }

  private async generateTranslations(foodItemId: number): Promise<void> {
    if (this.testMode) return;
    try {
      await this.translationService.generateAutomaticTranslations(foodItemId, 'foodItem');
    } catch (error) {
      console.error(`Failed to generate translations for food item ${foodItemId}:`, error);
    }
  }

  async create(data: {
    name: string;
    categoryId: number;
    imageUrl?: string;
    thumbnailUrl?: string;
    itemLimit?: number;
    limitType?: string;
    inStock?: boolean;
    mustGo?: boolean;
    lowSupply?: boolean;
    kosher?: boolean;
    halal?: boolean;
    vegetarian?: boolean;
    vegan?: boolean;
    glutenFree?: boolean;
    organic?: boolean;
    readyToEat?: boolean;
    customFields?: { key: string; value: string; }[];
  }): Promise<FoodItem> {
    try {
      const category = await this.prisma.category.findUnique({
        where: { id: data.categoryId }
      });

      if (!category) {
        throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_CATEGORY);
      }

      const { customFields, categoryId, ...foodItemData } = data;

      const createData: FoodItemCreateInput = {
        ...foodItemData,
        limitType: foodItemData.limitType || 'perHousehold',
        category: {
          connect: { id: categoryId }
        },
        customFields: customFields ? {
          create: customFields
        } : undefined
      };

      const foodItem = await this.prisma.foodItem.create({
        data: createData,
        include: {
          category: true,
          translations: {
            include: {
              language: true
            }
          },
          customFields: true
        }
      });

      this.generateTranslations(foodItem.id);

      return foodItem;
    } catch (error) {
      throw handleServiceError(error, ErrorMessages.CREATE_ERROR('food item'));
    }
  }

  async update(id: number, data: {
    name?: string;
    categoryId?: number;
    imageUrl?: string;
    thumbnailUrl?: string;
    itemLimit?: number;
    limitType?: string;
    inStock?: boolean;
    mustGo?: boolean;
    lowSupply?: boolean;
    kosher?: boolean;
    halal?: boolean;
    vegetarian?: boolean;
    vegan?: boolean;
    glutenFree?: boolean;
    organic?: boolean;
    readyToEat?: boolean;
    customFields?: { key: string; value: string; }[];
  }): Promise<FoodItem> {
    try {
      const existingItem = await this.prisma.foodItem.findUnique({
        where: { id },
        include: { customFields: true }
      });

      if (!existingItem) {
        throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.FOOD_ITEM_NOT_FOUND);
      }

      if (data.categoryId) {
        const category = await this.prisma.category.findUnique({
          where: { id: data.categoryId }
        });

        if (!category) {
          throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_CATEGORY);
        }
      }

      const { customFields, categoryId, ...updateData } = data;

      const prismaUpdateData: FoodItemUpdateInput = {
        ...updateData,
        ...(categoryId && {
          category: {
            connect: { id: categoryId }
          }
        })
      };

      const updatedItem = await this.prisma.foodItem.update({
        where: { id },
        data: prismaUpdateData,
        include: {
          category: true,
          translations: {
            include: {
              language: true
            }
          },
          customFields: true
        }
      });

      if (data.name && data.name !== existingItem.name) {
        this.generateTranslations(id);
      }

      return updatedItem;
    } catch (error) {
      throw handleServiceError(error, ErrorMessages.UPDATE_ERROR('food item'));
    }
  }

  async findById(id: number): Promise<FoodItem | null> {
    try {
      const item = await this.prisma.foodItem.findUnique({
        where: { id },
        include: {
          category: true,
          translations: {
            include: {
              language: true
            }
          }
        }
      });

      if (!item) {
        throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.FOOD_ITEM_NOT_FOUND);
      }

      return item;
    } catch (error) {
      throw handleServiceError(error, ErrorMessages.FOOD_ITEM_NOT_FOUND);
    }
  }

  async findAll(params: {
    categoryId?: number;
    includeOutOfStock?: boolean;
  } = {}): Promise<FoodItem[]> {
    try {
      const { categoryId, includeOutOfStock = true } = params;
      
      return await this.prisma.foodItem.findMany({
        where: {
          ...(categoryId && { categoryId }),
          ...(!includeOutOfStock && { inStock: true })
        },
        include: {
          category: true,
          translations: {
            include: {
              language: true
            }
          }
        }
      });
    } catch (error) {
      throw handleServiceError(error, 'Error fetching food items');
    }
  }

  async delete(id: number): Promise<void> {
    try {
      const existingItem = await this.findById(id);
      if (!existingItem) {
        throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.FOOD_ITEM_NOT_FOUND);
      }

      await this.prisma.foodItem.delete({
        where: { id }
      });
    } catch (error) {
      throw handleServiceError(error, ErrorMessages.DELETE_ERROR('food item'));
    }
  }
}
</file>

<file path="packages/backend/src/services/LanguageService.ts">
import { PrismaClient, Language } from '@prisma/client';
import { ApiError } from '../utils/ApiError';
import { TranslationService } from './TranslationService';
import { LanguageConfig, getDefaultLanguages } from '../config/languageConfig';

export class LanguageService {
    private prisma: PrismaClient;
    private translationService: TranslationService;
    private static initializationPromise: Promise<void> | null = null;

    constructor() {
        this.prisma = new PrismaClient();
        this.translationService = new TranslationService();
    }

    private async initializeLanguages(): Promise<void> {
        if (LanguageService.initializationPromise) {
            await LanguageService.initializationPromise;
            return;
        }

        LanguageService.initializationPromise = (async () => {
            try {
                const count = await this.prisma.language.count();
                if (count === 0) {
                    console.log('Initializing default languages...');
                    const defaultLanguages = getDefaultLanguages();
                    
                    // Insert languages one by one to handle race conditions
                    for (const lang of defaultLanguages) {
                        await this.prisma.language.upsert({
                            where: { code: lang.code },
                            create: {
                                code: lang.code,
                                name: lang.name,
                                active: lang.active,
                                createdAt: new Date(),
                                updatedAt: new Date()
                            },
                            update: {} // No updates if exists
                        });
                    }
                    console.log('Default languages initialized successfully');
                }
            } catch (error) {
                console.error('Error initializing languages:', error);
                throw new ApiError(500, 'Error initializing languages');
            } finally {
                LanguageService.initializationPromise = null;
            }
        })();

        await LanguageService.initializationPromise;
    }

    async findAll(): Promise<Language[]> {
        try {
            await this.initializeLanguages();
            return await this.prisma.language.findMany({
                orderBy: { name: 'asc' }
            });
        } catch (error) {
            console.error('Error in findAll:', error);
            throw new ApiError(500, 'Error fetching languages');
        }
    }

    async bulkUpdate(languages: { code: string; name: string; }[]): Promise<Language[]> {
        try {
            await this.initializeLanguages();

            await this.prisma.language.updateMany({
                data: { active: false }
            });

            const operations = languages.map(lang => 
                this.prisma.language.update({
                    where: { code: lang.code },
                    data: { 
                        active: true,
                        updatedAt: new Date()
                    }
                })
            );

            await this.prisma.$transaction(operations);

            for (const lang of languages) {
                await this.generateTranslationsForLanguage(lang.code);
            }

            return this.findAll();
        } catch (error) {
            console.error('Error in bulkUpdate:', error);
            throw new ApiError(500, `Error updating languages: ${error.message}`);
        }
    }

    async findByCode(code: string): Promise<Language> {
        try {
            await this.initializeLanguages();
            const lang = await this.prisma.language.findUnique({
                where: { code }
            });
            if (!lang) {
                throw new ApiError(404, `Language '${code}' not found`);
            }
            return lang;
        } catch (error) {
            console.error('Error in findByCode:', error);
            if (error instanceof ApiError) throw error;
            throw new ApiError(500, `Error fetching language: ${error.message}`);
        }
    }

    async findActive(): Promise<Language[]> {
        try {
            await this.initializeLanguages();
            return await this.prisma.language.findMany({
                where: { active: true },
                orderBy: { name: 'asc' }
            });
        } catch (error) {
            console.error('Error in findActive:', error);
            throw new ApiError(500, `Error fetching active languages: ${error.message}`);
        }
    }

    private async generateTranslationsForLanguage(languageCode: string): Promise<void> {
        try {
            const [categories, foodItems] = await Promise.all([
                this.prisma.category.findMany(),
                this.prisma.foodItem.findMany()
            ]);

            for (const category of categories) {
                await this.translationService.generateAutomaticTranslations(
                    category.id,
                    'category'
                ).catch(error => {
                    console.error(`Failed to translate category ${category.id} to ${languageCode}:`, error);
                });
            }

            for (const item of foodItems) {
                await this.translationService.generateAutomaticTranslations(
                    item.id,
                    'foodItem'
                ).catch(error => {
                    console.error(`Failed to translate food item ${item.id} to ${languageCode}:`, error);
                });
            }
        } catch (error) {
            console.error(`Failed to generate translations for language ${languageCode}:`, error);
        }
    }
}
</file>

<file path="packages/backend/src/services/TranslationService.ts">
import { PrismaClient } from '@prisma/client';
import { ApiError } from '../utils/ApiError';
import { OpenAIService } from './openai/OpenAIService';
import { LanguageConfig } from '../config/languageConfig';
import { ErrorTypes, ErrorMessages } from '../utils/errorConstants';
import { handleServiceError } from '../utils/errorHandler';

type ItemType = 'category' | 'foodItem';

interface CreateTranslationData {
    languageCode: string;
    translatedText: string;
    isAutomatic?: boolean;
}

export class TranslationService {
    private prisma: PrismaClient;
    private openAI: OpenAIService;

    constructor() {
        this.prisma = new PrismaClient();
        this.openAI = new OpenAIService();
    }

    async findAll(params: { 
        languageCode?: string; 
        categoryId?: number; 
        foodItemId?: number;
        type?: ItemType;
    }) {
        try {
            const whereClause: any = {
                AND: [
                    params.languageCode ? { language: { code: params.languageCode } } : {},
                    params.categoryId ? { categoryId: params.categoryId } : {},
                    params.foodItemId ? { foodItemId: params.foodItemId } : {}
                ]
            };

            if (params.type) {
                if (params.type === 'category') {
                    whereClause.AND.push({ categoryId: { not: null }, foodItemId: null });
                } else if (params.type === 'foodItem') {
                    whereClause.AND.push({ foodItemId: { not: null }, categoryId: null });
                }
            }

            return await this.prisma.translation.findMany({
                where: whereClause,
                include: { 
                    language: true,
                    category: true,
                    foodItem: true
                }
            });
        } catch (error) {
            throw handleServiceError(error, 'Error fetching translations');
        }
    }

    async findById(id: number) {
        try {
            const translation = await this.prisma.translation.findUnique({
                where: { id },
                include: { language: true }
            });

            if (!translation) {
                throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.TRANSLATION_NOT_FOUND);
            }

            return translation;
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.TRANSLATION_NOT_FOUND);
        }
    }

    async findByLanguage(languageCode: string, params: { categoryId?: number; foodItemId?: number }) {
        try {
            const language = await this.prisma.language.findFirst({
                where: { code: languageCode, active: true }
            });

            if (!language) {
                throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_LANGUAGE);
            }

            return await this.prisma.translation.findMany({
                where: {
                    languageId: language.id,
                    ...(params.categoryId && { categoryId: params.categoryId }),
                    ...(params.foodItemId && { foodItemId: params.foodItemId })
                },
                include: { language: true }
            });
        } catch (error) {
            throw handleServiceError(error, `Error fetching translations for language: ${languageCode}`);
        }
    }

    async createForCategory(categoryId: number, data: CreateTranslationData) {
        try {
            const category = await this.prisma.category.findUnique({
                where: { id: categoryId }
            });

            if (!category) {
                throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.CATEGORY_NOT_FOUND);
            }

            const language = await this.prisma.language.findFirst({
                where: { code: data.languageCode, active: true }
            });

            if (!language) {
                throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_LANGUAGE);
            }

            const existingTranslation = await this.prisma.translation.findFirst({
                where: {
                    categoryId,
                    languageId: language.id
                }
            });

            if (existingTranslation) {
                return this.update(existingTranslation.id, { 
                    translatedText: data.translatedText,
                    isAutomatic: data.isAutomatic ?? false
                });
            }

            return await this.prisma.translation.create({
                data: {
                    translatedText: data.translatedText,
                    categoryId,
                    languageId: language.id,
                    isAutomatic: data.isAutomatic ?? false
                },
                include: { language: true }
            });
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.CREATE_ERROR('category translation'));
        }
    }

    async createForFoodItem(foodItemId: number, data: CreateTranslationData) {
        try {
            const foodItem = await this.prisma.foodItem.findUnique({
                where: { id: foodItemId }
            });

            if (!foodItem) {
                throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.FOOD_ITEM_NOT_FOUND);
            }

            const language = await this.prisma.language.findFirst({
                where: { code: data.languageCode, active: true }
            });

            if (!language) {
                throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_LANGUAGE);
            }

            const existingTranslation = await this.prisma.translation.findFirst({
                where: {
                    foodItemId,
                    languageId: language.id
                }
            });

            if (existingTranslation) {
                return this.update(existingTranslation.id, { 
                    translatedText: data.translatedText,
                    isAutomatic: data.isAutomatic ?? false
                });
            }

            return await this.prisma.translation.create({
                data: {
                    translatedText: data.translatedText,
                    foodItemId,
                    languageId: language.id,
                    isAutomatic: data.isAutomatic ?? false
                },
                include: { language: true }
            });
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.CREATE_ERROR('food item translation'));
        }
    }

    async update(id: number, data: { translatedText: string; isAutomatic?: boolean }) {
        try {
            const translation = await this.findById(id);

            return await this.prisma.translation.update({
                where: { id },
                data: {
                    translatedText: data.translatedText,
                    isAutomatic: data.isAutomatic ?? translation.isAutomatic
                },
                include: { language: true }
            });
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.UPDATE_ERROR('translation'));
        }
    }

    async generateAutomaticTranslations(itemId: number, itemType: ItemType) {
        try {
            const item = itemType === 'category' 
                ? await this.prisma.category.findUnique({ where: { id: itemId } })
                : await this.prisma.foodItem.findUnique({ where: { id: itemId } });

            if (!item) {
                throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages[itemType === 'category' ? 'CATEGORY_NOT_FOUND' : 'FOOD_ITEM_NOT_FOUND']);
            }

            const activeLanguages = await this.prisma.language.findMany({
                where: { active: true }
            });

            const results = [];
            for (const language of activeLanguages) {
                if (language.code === LanguageConfig.DEFAULT_LANGUAGE) continue;

                try {
                    const translation = await this.openAI.translateText(
                        item.name,
                        language.code,
                        itemType
                    );

                    const createMethod = itemType === 'category' 
                        ? this.createForCategory.bind(this)
                        : this.createForFoodItem.bind(this);

                    const savedTranslation = await createMethod(
                        itemId,
                        {
                            languageCode: language.code,
                            translatedText: translation,
                            isAutomatic: true
                        }
                    );

                    results.push(savedTranslation);
                } catch (error) {
                    console.error(`Failed translation for ${itemType} ${itemId} in ${language.code}:`, error);
                }
            }

            return results;
        } catch (error) {
            throw handleServiceError(error, 'Error generating automatic translations');
        }
    }

    async delete(id: number) {
        try {
            await this.findById(id);
            await this.prisma.translation.delete({
                where: { id }
            });
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.DELETE_ERROR('translation'));
        }
    }
}
</file>

<file path="packages/backend/src/tests/utils/dbHelpers.ts">
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export const cleanDatabase = async () => {
  await prisma.translation.deleteMany({});
  await prisma.customField.deleteMany({});
  await prisma.foodItem.deleteMany({});
  await prisma.category.deleteMany({});
  await prisma.language.deleteMany({});
  await prisma.settings.deleteMany({});
};

export const disconnectDatabase = async () => {
  await cleanDatabase();
  await prisma.$disconnect();
};

export { prisma };
</file>

<file path="packages/backend/src/tests/utils/testFactories.ts">
import { prisma } from './dbHelpers';

export const createTestCategory = async (name = 'Test Category') => {
  return prisma.category.create({
    data: { name }
  });
};

export const createTestFoodItem = async (categoryId: number, data = {}) => {
  return prisma.foodItem.create({
    data: {
      name: 'Test Food Item',
      categoryId,
      inStock: true,
      itemLimit: 0,
      limitType: 'perHousehold',
      ...data
    }
  });
};

export const createTestLanguage = async (data = {}) => {
  return prisma.language.create({
    data: {
      code: 'en',
      name: 'English',
      active: true,
      ...data
    }
  });
};

export const createTestTranslation = async (data: {
  categoryId?: number;
  foodItemId?: number;
  languageId: number;
}) => {
  return prisma.translation.create({
    data: {
      translatedText: 'Test Translation',
      ...data
    }
  });
};
</file>

<file path="packages/backend/src/tests/utils/testHelpers.ts">
import { Express } from 'express';
import request from 'supertest';

export const expectSuccessResponse = (response: request.Response) => {
  expect(response.body.success).toBe(true);
  expect(response.body.data).toBeDefined();
};

export const expectErrorResponse = (response: request.Response) => {
  expect(response.body.success).toBe(false);
  expect(response.body.error).toBeDefined();
};

export const testCrudEndpoints = (app: Express, baseUrl: string, validPayload: any) => {
  describe('CRUD Operations', () => {
    let createdId: number;

    it('should create resource', async () => {
      const response = await request(app)
        .post(baseUrl)
        .send(validPayload)
        .expect(201);

      expectSuccessResponse(response);
      createdId = response.body.data.id;
    });

    it('should get all resources', async () => {
      const response = await request(app)
        .get(baseUrl)
        .expect(200);

      expectSuccessResponse(response);
      expect(Array.isArray(response.body.data)).toBe(true);
    });

    it('should get specific resource', async () => {
      const response = await request(app)
        .get(`${baseUrl}/${createdId}`)
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.id).toBe(createdId);
    });

    it('should update resource', async () => {
      const response = await request(app)
        .put(`${baseUrl}/${createdId}`)
        .send(validPayload)
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.id).toBe(createdId);
    });

    it('should delete resource', async () => {
      await request(app)
        .delete(`${baseUrl}/${createdId}`)
        .expect(200);

      await request(app)
        .get(`${baseUrl}/${createdId}`)
        .expect(404);
    });
  });
};
</file>

<file path="packages/backend/src/tests/categoryRoutes.test.ts">
import { createApp } from '../index';
import { cleanDatabase } from './utils/dbHelpers';
import { createTestCategory } from './utils/testFactories';
import { expectSuccessResponse, expectErrorResponse, testCrudEndpoints } from './utils/testHelpers';
import request from 'supertest';

describe('Category Routes', () => {
  const app = createApp();
  
  beforeEach(async () => {
    await cleanDatabase();
  });

  // Test all CRUD endpoints
  testCrudEndpoints(app, '/api/categories', { name: 'Test Category' });

  // Additional category-specific tests
  describe('Category Validations', () => {
    it('should reject empty category name', async () => {
      const response = await request(app)
        .post('/api/categories')
        .send({ name: '' })
        .expect(400);

      expectErrorResponse(response);
    });

    it('should handle duplicate category names', async () => {
      const category = await createTestCategory('Duplicate');
      
      const response = await request(app)
        .post('/api/categories')
        .send({ name: 'Duplicate' })
        .expect(400);

      expectErrorResponse(response);
    });
  });
});
</file>

<file path="packages/backend/src/tests/CategoryService.test.ts">
import { CategoryService } from '../services/CategoryService';
import { ApiError } from '../utils/ApiError';

describe('CategoryService', () => {
  let categoryService: CategoryService;

  beforeEach(() => {
    categoryService = new CategoryService();
  });

  describe('create', () => {
    it('should create a new category', async () => {
      const testData = { name: 'Test Category' };
      const result = await categoryService.create(testData);
      
      expect(result).toBeDefined();
      expect(result.name).toBe(testData.name);
      expect(result.id).toBeDefined();
    });
  });

  describe('findAll', () => {
    it('should return all categories', async () => {
      // Create test categories
      await categoryService.create({ name: 'Category 1' });
      await categoryService.create({ name: 'Category 2' });

      const categories = await categoryService.findAll();
      
      expect(categories).toBeDefined();
      expect(Array.isArray(categories)).toBe(true);
      expect(categories.length).toBeGreaterThanOrEqual(2);
    });
  });

  describe('findById', () => {
    it('should find category by id', async () => {
      const created = await categoryService.create({ name: 'Test Category' });
      const found = await categoryService.findById(created.id);
      
      expect(found).toBeDefined();
      expect(found?.id).toBe(created.id);
      expect(found?.name).toBe(created.name);
    });

    it('should throw ApiError if category not found', async () => {
      await expect(categoryService.findById(-1))
        .rejects
        .toThrow(ApiError);
    });
  });

  describe('update', () => {
    it('should update category', async () => {
      const created = await categoryService.create({ name: 'Original Name' });
      const updated = await categoryService.update(created.id, { name: 'Updated Name' });
      
      expect(updated).toBeDefined();
      expect(updated.id).toBe(created.id);
      expect(updated.name).toBe('Updated Name');
    });
  });

  describe('delete', () => {
    it('should delete category', async () => {
      const created = await categoryService.create({ name: 'To Delete' });
      
      await expect(categoryService.delete(created.id))
        .resolves
        .not
        .toThrow();

      await expect(categoryService.findById(created.id))
        .rejects
        .toThrow(ApiError);
    });
  });
});
</file>

<file path="packages/backend/src/tests/foodItemRoutes.test.ts">
import { createApp } from '../index';
import { cleanDatabase } from './utils/dbHelpers';
import { createTestCategory, createTestFoodItem } from './utils/testFactories';
import { expectSuccessResponse, expectErrorResponse, testCrudEndpoints } from './utils/testHelpers';
import request from 'supertest';

describe('Food Item Routes', () => {
  const app = createApp();
  let testCategoryId: number;
  
  beforeEach(async () => {
    await cleanDatabase();
    const category = await createTestCategory();
    testCategoryId = category.id;
  });

  const validPayload = {
    name: 'Test Food Item',
    categoryId: 0, // Will be set in beforeAll
    inStock: true,
    itemLimit: 0,
    limitType: 'perHousehold'
  };

  beforeAll(() => {
    // Update payload with actual category ID
    validPayload.categoryId = testCategoryId;
  });

  // Test all CRUD endpoints
  testCrudEndpoints(app, '/api/food-items', validPayload);

  describe('Food Item Validations', () => {
    it('should reject empty name', async () => {
      const response = await request(app)
        .post('/api/food-items')
        .send({ ...validPayload, name: '' })
        .expect(400);

      expectErrorResponse(response);
    });

    it('should reject invalid category', async () => {
      const response = await request(app)
        .post('/api/food-items')
        .send({ ...validPayload, categoryId: -1 })
        .expect(400);

      expectErrorResponse(response);
    });

    it('should validate limit type', async () => {
      const response = await request(app)
        .post('/api/food-items')
        .send({ ...validPayload, limitType: 'invalid' })
        .expect(400);

      expectErrorResponse(response);
    });
  });

  describe('Stock Filtering', () => {
    beforeEach(async () => {
      await createTestFoodItem(testCategoryId, { inStock: true });
      await createTestFoodItem(testCategoryId, { inStock: false });
    });

    it('should filter out-of-stock items by default', async () => {
      const response = await request(app)
        .get('/api/food-items')
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.every((item: any) => item.inStock)).toBe(true);
    });

    it('should include out-of-stock items when requested', async () => {
      const response = await request(app)
        .get('/api/food-items?includeOutOfStock=true')
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.some((item: any) => !item.inStock)).toBe(true);
    });
  });
});
</file>

<file path="packages/backend/src/tests/FoodItemService.test.ts">
import { FoodItemService } from '../services/FoodItemService';
import { ApiError } from '../utils/ApiError';
import { cleanDatabase } from './utils/dbHelpers';
import { createTestCategory, createTestFoodItem } from './utils/testFactories';

describe('FoodItemService', () => {
  let foodItemService: FoodItemService;
  let testCategoryId: number;

  beforeEach(async () => {
    foodItemService = new FoodItemService();
    await cleanDatabase();
    const category = await createTestCategory();
    testCategoryId = category.id;
  });

  describe('create', () => {
    it('should create a food item', async () => {
      const testData = {
        name: 'Test Food',
        categoryId: testCategoryId,
        inStock: true,
        itemLimit: 0,
        limitType: 'perHousehold'
      };
      const result = await foodItemService.create(testData);
      
      expect(result).toBeDefined();
      expect(result.name).toBe(testData.name);
      expect(result.categoryId).toBe(testCategoryId);
      expect(result.id).toBeDefined();
    });

    it('should validate category exists', async () => {
      const testData = {
        name: 'Test Food',
        categoryId: -1,
        inStock: true,
        itemLimit: 0,
        limitType: 'perHousehold'
      };
      await expect(foodItemService.create(testData)).rejects.toThrow(ApiError);
    });
  });

  describe('findAll', () => {
    it('should return all food items', async () => {
      await createTestFoodItem(testCategoryId, { name: 'Food 1' });
      await createTestFoodItem(testCategoryId, { name: 'Food 2' });

      const items = await foodItemService.findAll();
      expect(items.length).toBeGreaterThanOrEqual(2);
    });

    it('should filter out-of-stock items', async () => {
      await createTestFoodItem(testCategoryId, { name: 'In Stock', inStock: true });
      await createTestFoodItem(testCategoryId, { name: 'Out of Stock', inStock: false });

      const items = await foodItemService.findAll({ includeOutOfStock: false });
      expect(items.every(item => item.inStock)).toBe(true);
    });
  });

  describe('findById', () => {
    it('should find food item by id', async () => {
      const created = await createTestFoodItem(testCategoryId);
      const found = await foodItemService.findById(created.id);
      
      expect(found).toBeDefined();
      expect(found?.id).toBe(created.id);
    });

    it('should throw ApiError if not found', async () => {
      await expect(foodItemService.findById(-1)).rejects.toThrow(ApiError);
    });
  });

  describe('update', () => {
    it('should update food item', async () => {
      const created = await createTestFoodItem(testCategoryId);
      const updated = await foodItemService.update(created.id, { name: 'Updated Name' });
      
      expect(updated.name).toBe('Updated Name');
      expect(updated.id).toBe(created.id);
    });

    it('should validate category on update', async () => {
      const created = await createTestFoodItem(testCategoryId);
      await expect(foodItemService.update(created.id, { categoryId: -1 }))
        .rejects.toThrow(ApiError);
    });
  });

  describe('delete', () => {
    it('should delete food item', async () => {
      const created = await createTestFoodItem(testCategoryId);
      await foodItemService.delete(created.id);
      await expect(foodItemService.findById(created.id)).rejects.toThrow(ApiError);
    });
  });

  describe('limitType handling', () => {
    it('should handle per-household limits', async () => {
      const item = await createTestFoodItem(testCategoryId, {
        itemLimit: 5,
        limitType: 'perHousehold'
      });
      expect(item.limitType).toBe('perHousehold');
      expect(item.itemLimit).toBe(5);
    });

    it('should handle per-person limits', async () => {
      const item = await createTestFoodItem(testCategoryId, {
        itemLimit: 2,
        limitType: 'perPerson'
      });
      expect(item.limitType).toBe('perPerson');
      expect(item.itemLimit).toBe(2);
    });
  });
});
</file>

<file path="packages/backend/src/tests/languageRoutes.test.ts">
import request from 'supertest';
import { createApp } from '../index';
import { PrismaClient } from '@prisma/client';

describe('Language Routes', () => {
  const app = createApp();
  const prisma = new PrismaClient();

  beforeEach(async () => {
    await prisma.translation.deleteMany({});
    await prisma.foodItem.deleteMany({});
    await prisma.category.deleteMany({});
    await prisma.language.deleteMany({});
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  describe('POST /api/languages', () => {
    it('should create a new language', async () => {
      const response = await request(app)
        .post('/api/languages')
        .send({ code: 'fr', name: 'French' })
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.code).toBe('fr');
      expect(response.body.data.name).toBe('French');
    });

    it('should reject if code is missing', async () => {
      const response = await request(app)
        .post('/api/languages')
        .send({})
        .expect(400);

      expect(response.body.success).toBe(false);
    });

    it('should reject duplicates', async () => {
      await prisma.language.create({ data: { code: 'fr', name: 'French', active: true } });

      const response = await request(app)
        .post('/api/languages')
        .send({ code: 'fr', name: 'French' })
        .expect(400);

      expect(response.body.success).toBe(false);
    });
  });

  describe('GET /api/languages', () => {
    beforeEach(async () => {
      await prisma.language.create({
        data: { code: 'es', name: 'Spanish', active: true }
      });
      await prisma.language.create({
        data: { code: 'ru', name: 'Russian', active: true }
      });
    });

    it('should return all active languages', async () => {
      const response = await request(app)
        .get('/api/languages')
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(Array.isArray(response.body.data)).toBe(true);
      expect(response.body.data.length).toBe(2);
      const codes = response.body.data.map((l: any) => l.code);
      expect(codes).toContain('es');
      expect(codes).toContain('ru');
    });
  });
});
</file>

<file path="packages/backend/src/tests/limitType.test.ts">
import { PrismaClient } from '@prisma/client';
import { FoodItemService } from '../services/FoodItemService';

describe('FoodItem LimitType Tests', () => {
    let prisma: PrismaClient;
    let foodItemService: FoodItemService;
    let testCategoryId: number;

    beforeAll(async () => {
        prisma = new PrismaClient();
        foodItemService = new FoodItemService(true); // Enable test mode
        // Clear any existing data
        await prisma.translation.deleteMany();
        await prisma.foodItem.deleteMany();
        await prisma.category.deleteMany();
        
        const category = await prisma.category.create({
            data: { name: 'Test Category' }
        });
        testCategoryId = category.id;
    });

    afterEach(async () => {
        await prisma.translation.deleteMany();
        await prisma.foodItem.deleteMany();
    });

    afterAll(async () => {
        await prisma.$transaction([
            prisma.translation.deleteMany(),
            prisma.foodItem.deleteMany(),
            prisma.category.deleteMany()
        ]);
        await prisma.$disconnect();
    });

    it('creates food item with perPerson limitType', async () => {
        const foodItem = await foodItemService.create({
            name: 'Test Item',
            categoryId: testCategoryId,
            itemLimit: 2,
            limitType: 'perPerson'
        });

        expect(foodItem.limitType).toBe('perPerson');
    });

    it('defaults to perHousehold when limitType not specified', async () => {
        const foodItem = await foodItemService.create({
            name: 'Test Item 2',
            categoryId: testCategoryId
        });
        
        expect(foodItem.limitType).toBe('perHousehold');
    });

    it('updates limitType successfully', async () => {
        const foodItem = await foodItemService.create({
            name: 'Test Item 3',
            categoryId: testCategoryId,
            limitType: 'perHousehold'
        });
        
        const updated = await foodItemService.update(foodItem.id, {
            limitType: 'perPerson'
        });
        
        expect(updated.limitType).toBe('perPerson');
    });
});
</file>

<file path="packages/backend/src/tests/settings.test.ts">
describe('Settings API', () => {
    it('should get default settings', async () => {
        const response = await request(app)
            .get('/api/settings')
            .expect(200);
        
        expect(response.body.data.globalUpperLimit).toBeDefined();
    });

    it('should update settings', async () => {
        const response = await request(app)
            .post('/api/settings')
            .send({ globalUpperLimit: 50 })
            .expect(200);
        
        expect(response.body.data.globalUpperLimit).toBe(50);
    });
});
</file>

<file path="packages/backend/src/tests/settingsRoutes.test.ts">
import request from 'supertest';
import { createApp } from '../index';
import { PrismaClient } from '@prisma/client';

describe('Settings Routes', () => {
    const app = createApp();
    const prisma = new PrismaClient();

    beforeEach(async () => {
        await prisma.settings.deleteMany({});
    });

    afterAll(async () => {
        await prisma.$disconnect();
    });

    describe('GET /api/settings', () => {
        it('should return default settings when none exist', async () => {
            const response = await request(app)
                .get('/api/settings')
                .expect(200);

            expect(response.body).toEqual({
                success: true,
                data: { globalUpperLimit: 10 }
            });
        });

        it('should return existing settings', async () => {
            await prisma.settings.create({
                data: {
                    id: 1,
                    globalUpperLimit: 20
                }
            });

            const response = await request(app)
                .get('/api/settings')
                .expect(200);

            expect(response.body).toEqual({
                success: true,
                data: { globalUpperLimit: 20 }
            });
        });
    });

    describe('POST /api/settings', () => {
        it('should create new settings when none exist', async () => {
            const response = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 30 })
                .expect(200);

            expect(response.body).toEqual({
                success: true,
                data: expect.objectContaining({
                    id: 1,
                    globalUpperLimit: 30
                }),
                message: 'Settings updated successfully'
            });
        });

        it('should update existing settings', async () => {
            await prisma.settings.create({
                data: {
                    id: 1,
                    globalUpperLimit: 20
                }
            });

            const response = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 40 })
                .expect(200);

            expect(response.body).toEqual({
                success: true,
                data: expect.objectContaining({
                    id: 1,
                    globalUpperLimit: 40
                }),
                message: 'Settings updated successfully'
            });
        });

        it('should reject non-numeric global upper limit', async () => {
            const response = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 'invalid' })
                .expect(400);

            expect(response.body).toEqual({
                success: false,
                message: 'Global upper limit must be an integer',
                status: 400
            });
        });

        it('should reject negative global upper limit', async () => {
            const response = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: -1 })
                .expect(400);

            expect(response.body).toEqual({
                success: false,
                message: 'Global upper limit cannot be negative',
                status: 400
            });
        });

        it('should reject missing global upper limit', async () => {
            const response = await request(app)
                .post('/api/settings')
                .send({})
                .expect(400);

            expect(response.body).toEqual({
                success: false,
                message: 'Global upper limit is required',
                status: 400
            });
        });

        it('should reject decimal global upper limit', async () => {
            const response = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 10.5 })
                .expect(400);

            expect(response.body).toEqual({
                success: false,
                message: 'Global upper limit must be an integer',
                status: 400
            });
        });
    });

    describe('Settings persistence', () => {
        it('should maintain settings across requests', async () => {
            await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 50 })
                .expect(200);

            const response = await request(app)
                .get('/api/settings')
                .expect(200);

            expect(response.body).toEqual({
                success: true,
                data: { globalUpperLimit: 50 }
            });
        });

        it('should update updatedAt timestamp when modified', async () => {
            const createResponse = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 60 })
                .expect(200);

            const initialTimestamp = new Date(createResponse.body.data.updatedAt).getTime();

            // Wait a bit to ensure timestamp difference
            await new Promise(resolve => setTimeout(resolve, 1000));

            const updateResponse = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 70 })
                .expect(200);

            const updatedTimestamp = new Date(updateResponse.body.data.updatedAt).getTime();
            expect(updatedTimestamp).toBeGreaterThan(initialTimestamp);
        });
    });
});
</file>

<file path="packages/backend/src/tests/setup.ts">
import { cleanDatabase, disconnectDatabase } from './utils/dbHelpers';
import dotenv from 'dotenv';

// Load test environment variables
dotenv.config({ path: '.env.test' });

// Before all tests
beforeAll(async () => {
  await cleanDatabase();
});

// After all tests
afterAll(async () => {
  await disconnectDatabase();
});
</file>

<file path="packages/backend/src/tests/translationRoutes.test.ts">
import { createApp } from '../index';
import { cleanDatabase } from './utils/dbHelpers';
import { createTestCategory, createTestFoodItem, createTestLanguage, createTestTranslation } from './utils/testFactories';
import { expectSuccessResponse, expectErrorResponse } from './utils/testHelpers';
import request from 'supertest';

describe('Translation Routes', () => {
  const app = createApp();
  let testLanguageId: number;
  let testCategoryId: number;
  let testFoodItemId: number;

  beforeEach(async () => {
    await cleanDatabase();
    
    const language = await createTestLanguage();
    testLanguageId = language.id;
    
    const category = await createTestCategory();
    testCategoryId = category.id;
    
    const foodItem = await createTestFoodItem(category.id);
    testFoodItemId = foodItem.id;
  });

  describe('GET /api/translations/language/:languageCode', () => {
    beforeEach(async () => {
      await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });
      await createTestTranslation({
        foodItemId: testFoodItemId,
        languageId: testLanguageId
      });
    });

    it('should get translations by language code', async () => {
      const response = await request(app)
        .get('/api/translations/language/en')
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.length).toBe(2);
    });

    it('should filter by type', async () => {
      const response = await request(app)
        .get('/api/translations/language/en?type=category')
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.every((t: any) => t.categoryId)).toBe(true);
    });
  });

  describe('POST /api/translations/category/:categoryId', () => {
    it('should create category translation', async () => {
      const response = await request(app)
        .post(`/api/translations/category/${testCategoryId}`)
        .send({
          languageId: testLanguageId,
          translatedText: 'Test Translation'
        })
        .expect(201);

      expectSuccessResponse(response);
      expect(response.body.data.categoryId).toBe(testCategoryId);
    });

    it('should validate inputs', async () => {
      const response = await request(app)
        .post(`/api/translations/category/${testCategoryId}`)
        .send({
          languageId: -1,
          translatedText: ''
        })
        .expect(400);

      expectErrorResponse(response);
    });
  });

  describe('POST /api/translations/food-item/:foodItemId', () => {
    it('should create food item translation', async () => {
      const response = await request(app)
        .post(`/api/translations/food-item/${testFoodItemId}`)
        .send({
          languageId: testLanguageId,
          translatedText: 'Test Translation'
        })
        .expect(201);

      expectSuccessResponse(response);
      expect(response.body.data.foodItemId).toBe(testFoodItemId);
    });

    it('should validate inputs', async () => {
      const response = await request(app)
        .post(`/api/translations/food-item/${testFoodItemId}`)
        .send({
          languageId: -1,
          translatedText: ''
        })
        .expect(400);

      expectErrorResponse(response);
    });
  });

  describe('PUT /api/translations/:id', () => {
    it('should update translation', async () => {
      const translation = await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });

      const response = await request(app)
        .put(`/api/translations/${translation.id}`)
        .send({ translatedText: 'Updated Text' })
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.translatedText).toBe('Updated Text');
    });
  });

  describe('DELETE /api/translations/:id', () => {
    it('should delete translation', async () => {
      const translation = await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });

      await request(app)
        .delete(`/api/translations/${translation.id}`)
        .expect(200);

      // Verify deletion
      await request(app)
        .get(`/api/translations/${translation.id}`)
        .expect(404);
    });
  });
});
</file>

<file path="packages/backend/src/tests/TranslationService.test.ts">
import { TranslationService } from '../services/TranslationService';
import { ApiError } from '../utils/ApiError';
import { cleanDatabase } from './utils/dbHelpers';
import { createTestCategory, createTestFoodItem, createTestLanguage, createTestTranslation } from './utils/testFactories';

describe('TranslationService', () => {
  let translationService: TranslationService;
  let testLanguageId: number;
  let testCategoryId: number;
  let testFoodItemId: number;

  beforeEach(async () => {
    translationService = new TranslationService();
    await cleanDatabase();
    
    const language = await createTestLanguage();
    testLanguageId = language.id;
    
    const category = await createTestCategory();
    testCategoryId = category.id;
    
    const foodItem = await createTestFoodItem(category.id);
    testFoodItemId = foodItem.id;
  });

  describe('createForCategory', () => {
    it('should create category translation', async () => {
      const result = await translationService.createForCategory({
        categoryId: testCategoryId,
        languageId: testLanguageId,
        translatedText: 'Test Translation'
      });

      expect(result).toBeDefined();
      expect(result.categoryId).toBe(testCategoryId);
      expect(result.languageId).toBe(testLanguageId);
    });

    it('should validate category exists', async () => {
      await expect(translationService.createForCategory({
        categoryId: -1,
        languageId: testLanguageId,
        translatedText: 'Test'
      })).rejects.toThrow(ApiError);
    });
  });

  describe('createForFoodItem', () => {
    it('should create food item translation', async () => {
      const result = await translationService.createForFoodItem({
        foodItemId: testFoodItemId,
        languageId: testLanguageId,
        translatedText: 'Test Translation'
      });

      expect(result).toBeDefined();
      expect(result.foodItemId).toBe(testFoodItemId);
      expect(result.languageId).toBe(testLanguageId);
    });

    it('should validate food item exists', async () => {
      await expect(translationService.createForFoodItem({
        foodItemId: -1,
        languageId: testLanguageId,
        translatedText: 'Test'
      })).rejects.toThrow(ApiError);
    });
  });

  describe('findByLanguage', () => {
    beforeEach(async () => {
      await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });
      await createTestTranslation({
        foodItemId: testFoodItemId,
        languageId: testLanguageId
      });
    });

    it('should find all translations for language', async () => {
      const translations = await translationService.findByLanguage(testLanguageId);
      expect(translations.length).toBe(2);
    });

    it('should filter by type', async () => {
      const categoryTranslations = await translationService.findByLanguage(
        testLanguageId,
        'category'
      );
      expect(categoryTranslations.every(t => t.categoryId !== null)).toBe(true);

      const foodItemTranslations = await translationService.findByLanguage(
        testLanguageId,
        'foodItem'
      );
      expect(foodItemTranslations.every(t => t.foodItemId !== null)).toBe(true);
    });
  });

  describe('update', () => {
    it('should update translation text', async () => {
      const translation = await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });

      const updated = await translationService.update(
        translation.id,
        'Updated Text'
      );
      
      expect(updated.translatedText).toBe('Updated Text');
    });
  });

  describe('delete', () => {
    it('should delete translation', async () => {
      const translation = await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });

      await translationService.delete(translation.id);
      
      const translations = await translationService.findByLanguage(testLanguageId);
      expect(translations.find(t => t.id === translation.id)).toBeUndefined();
    });
  });
});
</file>

<file path="packages/backend/src/utils/ApiError.ts">
export class ApiError extends Error {
  public isOperational: boolean;

  constructor(
    public statusCode: number,
    message: string,
    isOperational = true,
    stack = ''
  ) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;

    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

/**
 * Custom error class for settings-related validation errors.
 * Inherits from ApiError with a fixed status code of 400.
 */
export class SettingsValidationError extends ApiError {
  constructor(message: string) {
    super(400, message);
  }
}

/**
 * Type guard to identify ApiError instances.
 */
export const isApiError = (error: unknown): error is ApiError => {
  return error instanceof ApiError;
};
</file>

<file path="packages/backend/src/utils/ApiResponse.ts">
export class ApiResponse {
  public readonly success: boolean;
  public readonly data: any;
  public readonly message?: string;
  public readonly pagination?: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
  };

  constructor(success: boolean, data: any, message?: string, pagination?: any) {
      this.success = success;
      this.data = data;
      this.message = message;
      this.pagination = pagination;
  }

  static success(data: any, message?: string, pagination?: any): ApiResponse {
      return new ApiResponse(true, data, message, pagination);
  }

  static error(message: string): ApiResponse {
      return new ApiResponse(false, null, message);
  }

  static paginated(items: any[], page: number, limit: number, total: number): ApiResponse {
      const totalPages = Math.ceil(total / limit);
      return new ApiResponse(true, items, undefined, { page, limit, total, totalPages });
  }
}
</file>

<file path="packages/backend/src/utils/errorConstants.ts">
export const ErrorTypes = {
  VALIDATION: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  INTERNAL: 500
} as const;

export const ErrorMessages = {
  // Entity not found
  CATEGORY_NOT_FOUND: 'Category not found',
  FOOD_ITEM_NOT_FOUND: 'Food item not found',
  TRANSLATION_NOT_FOUND: 'Translation not found',
  LANGUAGE_NOT_FOUND: 'Language not found',
  SETTING_NOT_FOUND: 'Setting not found',

  // Invalid inputs
  INVALID_CATEGORY: 'Invalid category ID',
  INVALID_LANGUAGE: 'Invalid or inactive language code',
  INVALID_LIMIT_TYPE: 'Invalid limit type',
  
  // Operation errors
  CREATE_ERROR: (entity: string) => `Error creating ${entity}`,
  UPDATE_ERROR: (entity: string) => `Error updating ${entity}`,
  DELETE_ERROR: (entity: string) => `Error deleting ${entity}`,
  TRANSLATION_ERROR: (lang: string) => `Error generating translation for language: ${lang}`
} as const;
</file>

<file path="packages/backend/src/utils/errorHandler.ts">
import { ApiError } from './ApiError';
import { ErrorTypes } from './errorConstants';
import { Prisma } from '@prisma/client';

export const handleServiceError = (error: unknown, defaultMessage: string): never => {
  console.error('Service Error:', error);

  if (error instanceof ApiError) {
    throw error;
  }

  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    // Handle specific Prisma errors
    switch (error.code) {
      case 'P2002':
        throw new ApiError(ErrorTypes.VALIDATION, 'Unique constraint failed');
      case 'P2003':
        throw new ApiError(ErrorTypes.VALIDATION, 'Foreign key constraint failed');
      case 'P2025':
        throw new ApiError(ErrorTypes.NOT_FOUND, 'Record not found');
      default:
        throw new ApiError(ErrorTypes.INTERNAL, defaultMessage);
    }
  }

  throw new ApiError(ErrorTypes.INTERNAL, defaultMessage);
};
</file>

<file path="packages/backend/src/index.ts">
import dotenv from 'dotenv';
dotenv.config(); // Call this first, before importing anything else that relies on env vars

import express from 'express';
import cors from 'cors';
import { requestLogger } from './middleware/requestLogger';
import { errorHandler } from './middleware/errorHandler';
import { ApiResponse } from './utils/ApiResponse';
import categoryRoutes from './routes/categoryRoutes';
import foodItemRoutes from './routes/foodItemRoutes';
import translationRoutes from './routes/translationRoutes';
import languageRoutes from './routes/languageRoutes';
import settingsRoutes from './routes/settingsRoutes';
import path from 'path';

// Create and configure express app
export const createApp = () => {
    const app = express();

    // Middleware
    app.use(cors());
    app.use(express.json());
    app.use(requestLogger);

    // Serve static files from public directory
    app.use(express.static(path.join(__dirname, '../public')));

    // Routes
    app.use('/api/categories', categoryRoutes);
    app.use('/api/food-items', foodItemRoutes);
    app.use('/api/translations', translationRoutes);
    app.use('/api/languages', languageRoutes);
    app.use('/api/settings', settingsRoutes);    // Add this line

    // Basic health check endpoint
    app.get('/health', (req, res) => {
        res.status(200).json(ApiResponse.success({
            uptime: process.uptime(),
            timestamp: new Date().toISOString()
        }));
    });

    // Error handling middleware (must be after all other middleware and routes)
    app.use(errorHandler);
    return app;
};

// Only start the server if this file is run directly
if (require.main === module) {
    const app = createApp();
    const PORT = process.env.PORT || 3000;
    app.listen(PORT, () => {
        console.log(`Server running on port ${PORT}`);
    });
}
</file>

<file path="packages/backend/.env.example">
DATABASE_URL="file:../../data/food-pantry.db"
OPENAI_API_KEY="your-api-key-here"
</file>

<file path="packages/backend/jest-setup.js">
const { TextEncoder, TextDecoder } = require('util');
global.TextEncoder = TextEncoder;
global.TextDecoder = TextDecoder;
</file>

<file path="packages/backend/jest.config.js">
module.exports = {
    projects: [
        {
            displayName: 'backend',
            testEnvironment: 'node',
            testMatch: [
                '<rootDir>/src/tests/*.test.ts',
                '<rootDir>/src/services/**/*.test.ts'
            ],
            transform: {
                '^.+\\.(ts|tsx)$': 'ts-jest'
            },
            setupFilesAfterEnv: [
                '<rootDir>/src/tests/setup.ts'
            ],
            moduleNameMapper: {
                '^@/(.*)$': '<rootDir>/src/$1'
            }
        },
        {
            displayName: 'frontend',
            testEnvironment: 'jsdom',
            testMatch: [
                '<rootDir>/src/tests/frontend/*.test.js'
            ],
            transform: {
                '^.+\\.(js|jsx)$': 'babel-jest'
            },
            setupFilesAfterEnv: [
                '<rootDir>/src/tests/frontend/setup.js'
            ]
        }
    ],
    collectCoverage: true,
    coverageDirectory: 'coverage',
    coverageReporters: ['text', 'lcov'],
    testTimeout: 30000,
    detectOpenHandles: true
}
</file>

<file path="packages/backend/package.json">
{
    "name": "@sql-react-app/backend",
    "version": "0.1.0",
    "private": true,
    "scripts": {
        "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
        "build": "tsc",
        "start": "node dist/index.js",
        "prisma:generate": "prisma generate",
        "prisma:migrate": "prisma migrate deploy",
        "prisma:studio": "prisma studio",
        "test": "jest",
        "test:watch": "jest --watch",
        "test:coverage": "jest --coverage",
        "test:unit": "jest src/tests/limitType.test.ts",
        "test:frontend": "jest src/tests/frontend/",
        "lint": "eslint . --ext .ts"
    },
    "dependencies": {
        "@prisma/client": "^6.1.0",
        "cors": "^2.8.5",
        "dotenv": "^16.3.1",
        "express": "^4.18.2",
        "express-validator": "^7.0.1",
        "openai": "^4.76.0",
        "winston": "^3.11.0"
    },
    "devDependencies": {
        "@babel/core": "^7.26.0",
        "@babel/plugin-transform-modules-commonjs": "^7.26.3",
        "@babel/preset-env": "^7.26.0",
        "@babel/preset-typescript": "^7.26.0",
        "@types/cors": "^2.8.17",
        "@types/express": "^4.17.21",
        "@types/jest": "^29.5.11",
        "@types/node": "^20.10.4",
        "@types/supertest": "^6.0.2",
        "@typescript-eslint/eslint-plugin": "^6.13.2",
        "@typescript-eslint/parser": "^6.13.2",
        "babel-jest": "^29.7.0",
        "eslint": "^8.55.0",
        "jest": "^29.7.0",
        "jest-environment-jsdom": "^29.7.0",
        "prisma": "^6.1.0",
        "supertest": "^7.0.0",
        "ts-jest": "^29.1.1",
        "ts-node-dev": "^2.0.0",
        "typescript": "^5.3.3"
    }
}
</file>

<file path="packages/backend/tsconfig.json">
{
    "compilerOptions": {
      "target": "es2020",
      "module": "commonjs",
      "lib": ["es2020"],
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "outDir": "dist",
      "rootDir": "src",
      "experimentalDecorators": true,
      "emitDecoratorMetadata": true,
      "resolveJsonModule": true
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "dist"]
  }
</file>

<file path="packages/frontend/package.json">
{
    "name": "@sql-react-app/frontend",
    "version": "0.1.0",
    "private": true,
    "dependencies": {
      "react": "^18.2.0",
      "react-dom": "^18.2.0"
    },
    "devDependencies": {
      "@types/react": "^18.2.0",
      "@types/react-dom": "^18.2.0",
      "typescript": "^5.3.3"
    }
}
</file>

<file path=".gitignore">
packages/backend/.env
node_modules
*.log
node_modules/
data/
.repomixignore
repomix-output.xml
repomix.config.json
</file>

<file path="CHANGELOG.md">
# Changelog
All notable changes to this project will be documented in this file.

The format follows [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.5.8] - 2024-12-21
### Fixed
- Language initialization race condition resolved
  - Added static initialization promise
  - Implemented proper promise handling
  - Resolved database constraint violations
  - Eliminated page refresh requirement
- Fresh database initialization now works correctly

## [0.5.7] - 2024-12-21
### Added
- Language Management filter dropdown (All/Active/Inactive)
- Enhanced language configuration robustness
  - Default language initialization
  - Automatic database population
  - Full OpenAI model language support
### Fixed
- Language Management unpopulation issue with fresh database
- Language table readability with filtering options

## [0.5.6] - 2024-12-21
### Added
- Category limit feature
  - Added itemLimit field to Category model
  - Implemented UI controls for setting category limits
  - Added validation against global upper limit
  - Real-time updates between Category and Food Item sections
- Event-based communication between managers
  - Automatic dropdown updates for Food Items
  - Cross-component synchronization

### Fixed
- Food Item category dropdown now updates automatically
- Improved initial database state handling
- Added proper validation for limit values

## [0.5.5] - 2024-12-21
### Added
- **LimitType** field to **FoodItem** model  
- Test suite for FoodItem limitType functionality  
- **Test mode** for FoodItemService  
- Additional test coverage for OpenAIService  
- Improved documentation for modular JavaScript structure

### Fixed
- Food item update functionality  
- Translation generation during testing  
- TypeScript validation in FoodItemService  
- Documentation formatting inconsistencies  
- **Food Items table display** and CRUD in Test UI (Edit/Delete now functional)

## [0.5.3] - 2024-12-18
### Added
- Local development environment setup
- Working database configuration for local SQLite
- Test data initialization process
- Updated documentation for local setup

### Changed
- Messages now display within their respective sections instead of global header
- Fixed category dropdown in Food Item Management
- Improved language filter to show all available languages

### Fixed
- Package dependency issues for local development
- Database path configuration for cross-platform compatibility
- Git tracking of sensitive information

## [0.5.2] - 2024-12-11
### Fixed
- Translation type classification in UI (categories vs. food items)
- Original text display in translation management
- Language filter dropdown initialization
- Translation filtering by type

### Added
- Automatic language filter updates when language settings change
- Event-based synchronization between language and translation managers

### Changed
- Improved translation type handling in backend service
- Enhanced translation filtering logic

## [0.5.1] - 2024-12-06
### Added
- Language model for managing supported languages
- Comprehensive language management system
- Improved translation validation and error handling
- Complete test coverage for language management
- Non-null assertions for type safety
- Paginated response utility

### Changed
- Updated translation schema to support language relationships
- Enhanced error handling with standardized responses
- Improved test setup with proper database cleanup
- Updated API documentation for language endpoints

### Fixed
- Language uniqueness constraint handling
- Translation relationship type safety
- Category validation for empty names
- Response status code consistency

## [0.5.0] - 2024-12-06
### Added
- OpenAI-powered translation system using gpt-4o-mini model
- Cost-effective automated translations
- Multiple language support
- Seamless UI integration

### Fixed
- Translation loading error after food item deletion

### Changed
- Translation system from manual to automated

## [0.4.0] - 2024-12-03
### Added
- Test UI for validating backend functionality
- Category management interface
- Food item management with dietary and status flags
- Translation management interface
- Basic CSS styling for usability
- Complete CRUD operations for all entities
- Form validation and error handling
- Status and dietary attribute display

### Fixed
- Food items visibility when out of stock
- JSON parsing in food item edit functionality

### Known Issues
- Translation loading error after food item deletion

## [0.1.1] - 2024-12-02
### Added
- Complete backend implementation:
  - Category, FoodItem, and Translation services with CRUD operations
  - RESTful API endpoints with validation
  - Comprehensive test coverage (56 tests)
  - Structured error handling
  - Request logging middleware

### Changed
- Enhanced project structure:
  - Separate route handlers
  - Service layer abstraction
  - Utility classes for errors and responses
- Improved type safety with TypeScript
- Updated documentation with API endpoints

## [0.1.0] - 2024-11-29
### Added
- Initial project setup:
  - Prisma ORM integration
  - Database schema for:
    - Categories and food items
    - Multi-language translations
    - Dietary attributes
    - Custom fields
  - Development environment configuration
  - SQLite database initialization
- Documentation setup:
  - README structure
  - Development roadmap
  - MIT License

### Changed
- Repository reset for fresh implementation
- Updated technical stack documentation
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 MattGeiger

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
  "name": "wth-food-shopping-lists",
  "version": "1.0.0",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "dev": "npm run dev --workspace=@sql-react-app/backend",
    "build": "npm run build --workspace=@sql-react-app/backend",
    "test": "npm run test --workspace=@sql-react-app/backend",
    "lint": "npm run lint --workspace=@sql-react-app/backend"
  },
  "devDependencies": {
    "@types/jsdom": "^21.1.7",
    "jsdom": "^25.0.1",
    "typescript": "^5.3.3"
  }
}
</file>

<file path="project-overview.md">
# Project Overview

## Introduction

The Food Pantry Management System is a web application designed to support non-profit food pantries through automated inventory management and AI-powered multilingual accessibility. The system reduces volunteer workload while improving service delivery to diverse communities.

## Core Goals

1. **Automated Inventory Management**
   - Zero-configuration database setup
   - Automated item and category tracking
   - Smart inventory status flags
   - Flexible item limits system
   - Real-time synchronization
   - Reduced manual data entry

2. **Multilingual Support**
   - Instant AI translations
   - 60+ language support
   - Zero-configuration initialization
   - Race-condition prevention
   - Translation refinement tools
   - Automatic updates

3. **Dietary Tracking**
   - Automated restriction flags
   - Clear allergen labeling
   - Quick filtering tools
   - Standardized attributes

## Technical Architecture

### Backend Architecture

1. **Database Layer**
   - SQLite for local deployment
   - Prisma ORM
   - Automated migrations
   - Models:
     * Categories
     * Food Items
     * Translations
     * Languages
     * Settings

2. **API Layer**
   - Express.js REST API
   - TypeScript integration
   - Modular routing
   - Standard responses
   - Error handling

3. **Service Layer**
   - Business logic
   - OpenAI translation
   - CRUD operations
   - Data validation

### Frontend Architecture

1. **Current Implementation**
   - Modular JavaScript
   - Event communication
   - Real-time updates
   - UI validation
   - CSS styling

2. **Planned React Implementation**
   - TypeScript
   - State management
   - Enhanced UI/UX
   - Component reuse

## Technical Decisions

1. **Database: SQLite**
   - Simple local deployment
   - Zero configuration
   - PostgreSQL upgrade path

2. **ORM: Prisma**
   - Type safety
   - Auto-generated types
   - Migration tools
   - Query building

3. **Languages**
   - Automated initialization
   - OpenAI translation
   - Manual refinement
   - Translation caching

4. **Item Limits**
   - Global limits
   - Category thresholds
   - Household/person options
   - Default settings

## Security Measures

1. **Input Validation**
   - Request validation
   - Type checking
   - Input sanitization

2. **Error Handling**
   - Custom errors
   - Standard responses
   - Error detail control

3. **API Security**
   - CORS setup
   - Rate limiting
   - Input cleaning

## Testing Strategy

1. **Unit Tests**
   - Jest framework
   - Service coverage
   - Utility testing

2. **Integration Tests**
   - API endpoints
   - Database operations
   - Translation system

3. **Frontend Tests**
   - Component testing
   - User interaction
   - Browser compatibility

## Development Process

1. **Version Control**
   - Feature branches
   - Standard commits
   - Version tagging

2. **Documentation**
   - Code comments
   - API documentation
   - Change logging
   - Structure docs

3. **Quality Control**
   - Code review
   - Automated tests
   - UI testing
   - Translation checks

## Roadmap

1. **Short Term**
   - React frontend
   - Test coverage
   - Auth system
   - Caching

2. **Medium Term**
   - Analytics 
   - Translation updates
   - Reporting
   - User roles

3. **Long Term**
   - Database scaling
   - Mobile app
   - Offline mode
   - Analytics

## Performance

1. **Database**
   - Index optimization
   - Query efficiency
   - Connection pooling

2. **API**
   - Response caching
   - Pagination
   - Efficient loading

3. **Frontend**
   - Code splitting
   - Asset optimization
   - Lazy loading

## Deployment

1. **Development**
   - Local SQLite
   - Environment config
   - Dev server

2. **Production**
   - Migration strategy
   - Environment setup
   - Monitoring
   - Backups

## Maintenance

1. **Database**
   - Regular backups
   - Migration management
   - Data cleanup

2. **Code**
   - Dependency updates
   - Security patches
   - Performance monitoring

3. **Translations**
   - Quality checks
   - Manual review
   - Update process

## Success Metrics

1. **Technical**
   - API response time
   - Error rates
   - Translation accuracy
   - Test coverage

2. **Service Impact**
   - Volunteer hours saved
   - Language accessibility
   - Client satisfaction
   - System reliability
   - Community reach
</file>

<file path="project-structure.md">
# Project Structure

```
.
├── packages/
│   ├── backend/                    # Main backend application directory
│   │   ├── prisma/                # Database configuration and migrations
│   │   │   ├── migrations/        # Database migration history
│   │   │   └── schema.prisma      # Prisma schema defining data models
│   │   │
│   │   ├── public/                # Static assets and test UI
│   │   │   ├── css/              # Stylesheets for test UI
│   │   │   │   ├── components/    # Component-specific styles
│   │   │   │   └── layout/        # Layout and structural styles
│   │   │   ├── js/               # Frontend JavaScript modules
│   │   │   └── index.html        # Test UI entry point
│   │   │
│   │   ├── src/                   # Backend source code
│   │   │   ├── config/           # Application configuration
│   │   │   │   └── languageConfig.ts    # Language initialization
│   │   │   │
│   │   │   ├── middleware/       # Express middleware
│   │   │   │   ├── errorHandler.ts      # Global error handling
│   │   │   │   └── requestLogger.ts     # Request logging
│   │   │   │
│   │   │   ├── routes/           # API route handlers
│   │   │   │   ├── categoryRoutes.ts    # Category endpoints
│   │   │   │   ├── foodItemRoutes.ts    # Food item endpoints
│   │   │   │   ├── languageRoutes.ts    # Language management
│   │   │   │   ├── settingsRoutes.ts    # Global settings
│   │   │   │   └── translationRoutes.ts # Translation endpoints
│   │   │   │
│   │   │   ├── services/         # Business logic layer
│   │   │   │   ├── openai/       # OpenAI integration
│   │   │   │   ├── CategoryService.ts   # Category operations
│   │   │   │   ├── FoodItemService.ts   # Food item operations
│   │   │   │   ├── LanguageService.ts   # Language initialization
│   │   │   │   └── TranslationService.ts # Translation operations
│   │   │   │
│   │   │   ├── tests/            # Test suites
│   │   │   │   ├── utils/        # Test utilities
│   │   │   │   └── setup.ts      # Test environment setup
│   │   │   │
│   │   │   └── utils/            # Utility functions
│   │   │       ├── ApiError.ts         # Error handling
│   │   │       ├── ApiResponse.ts      # Response formatting
│   │   │       └── errorHandler.ts     # Error processing
│   │   │
│   │   ├── .env.example          # Environment template
│   │   ├── jest.config.js        # Test configuration
│   │   ├── package.json          # Backend dependencies
│   │   └── tsconfig.json         # TypeScript configuration
│   │
│   └── frontend/                  # React frontend (planned)
│       └── package.json          # Frontend dependencies
│
├── CHANGELOG.md                   # Project history
├── LICENSE                       # MIT license
├── README.md                     # Project documentation
└── package.json                  # Root package file
```

## Key Components

### Backend Structure

- `prisma/`: Database setup
  - Zero-configuration migrations
  - Automated model generation
  - Data relationships

- `public/`: Test interface
  - Modular JavaScript
  - Component styling
  - Real-time updates

- `src/`: Application core
  - TypeScript services
  - API endpoints
  - Business logic

### Frontend Structure

- React implementation planned
- Component architecture
- TypeScript integration

## Core Files

### Configuration

- `schema.prisma`: Database models
- `languageConfig.ts`: Language setup
- `tsconfig.json`: TypeScript setup
- `jest.config.js`: Test configuration

### Services

- `CategoryService.ts`: Category management
- `FoodItemService.ts`: Inventory control
- `LanguageService.ts`: Language initialization
- `TranslationService.ts`: AI translations

### API Routes

- `categoryRoutes.ts`: Category API
- `foodItemRoutes.ts`: Inventory API
- `languageRoutes.ts`: Language management
- `settingsRoutes.ts`: Global settings

### Utilities

- `ApiError.ts`: Error classes
- `ApiResponse.ts`: Response format
- `errorHandler.ts`: Error management

### Components

- `categories.js`: Category interface
- `foodItems.js`: Inventory interface
- `translations.js`: Language interface
- `settings.js`: System settings
</file>

<file path="project-tree.txt">
.
├── CHANGELOG.md
├── LICENSE
├── README.md
├── package-lock.json
├── package.json
├── packages
│   ├── backend
│   │   ├── babel.config.js
│   │   ├── jest-setup.js
│   │   ├── jest.config.js
│   │   ├── package.json
│   │   ├── prisma
│   │   │   ├── migrations
│   │   │   │   ├── 20241130003245_init
│   │   │   │   │   └── migration.sql
│   │   │   │   ├── 20241207052011_add_language_model_and_make_language_id_optional
│   │   │   │   │   └── migration.sql
│   │   │   │   ├── 20241209004222_add_settings_model
│   │   │   │   │   └── migration.sql
│   │   │   │   ├── 20241220064500_add_limit_type
│   │   │   │   │   └── migration.sql
│   │   │   │   └── migration_lock.toml
│   │   │   └── schema.prisma
│   │   ├── project-tree.txt
│   │   ├── public
│   │   │   ├── css
│   │   │   │   ├── components
│   │   │   │   │   ├── forms.css
│   │   │   │   │   ├── languages.css
│   │   │   │   │   ├── messages.css
│   │   │   │   │   └── tables.css
│   │   │   │   ├── layout
│   │   │   │   │   └── sections.css
│   │   │   │   └── styles.css
│   │   │   ├── index.html
│   │   │   └── js
│   │   │       ├── categories.js
│   │   │       ├── foodItems.js
│   │   │       ├── languages.js
│   │   │       ├── main.js
│   │   │       ├── settings.js
│   │   │       ├── translations.js
│   │   │       └── utils.js
│   │   ├── src
│   │   │   ├── config
│   │   │   │   └── languageConfig.ts
│   │   │   ├── index.ts
│   │   │   ├── middleware
│   │   │   │   ├── errorHandler.ts
│   │   │   │   └── requestLogger.ts
│   │   │   ├── routes
│   │   │   │   ├── categoryRoutes.ts
│   │   │   │   ├── foodItemRoutes.ts
│   │   │   │   ├── languageRoutes.ts
│   │   │   │   ├── settingsRoutes.ts
│   │   │   │   └── translationRoutes.ts
│   │   │   ├── services
│   │   │   │   ├── CategoryService.ts
│   │   │   │   ├── FoodItemService.ts
│   │   │   │   ├── LanguageService.ts
│   │   │   │   ├── TranslationService.ts
│   │   │   │   └── openai
│   │   │   │       ├── OpenAIService.ts
│   │   │   │       └── __tests__
│   │   │   │           └── OpenAIService.test.ts
│   │   │   ├── tests
│   │   │   │   ├── CategoryService.test.ts
│   │   │   │   ├── FoodItemService.test.ts
│   │   │   │   ├── TranslationService.test.ts
│   │   │   │   ├── categoryRoutes.test.ts
│   │   │   │   ├── foodItemRoutes.test.ts
│   │   │   │   ├── frontend
│   │   │   │   │   ├── __mocks__
│   │   │   │   │   │   ├── fileMock.js
│   │   │   │   │   │   └── styleMock.js
│   │   │   │   │   ├── categories.test.js
│   │   │   │   │   ├── foodItems.test.js
│   │   │   │   │   ├── languages.test.js
│   │   │   │   │   ├── settings.test.js
│   │   │   │   │   ├── setup.js
│   │   │   │   │   ├── translations.test.js
│   │   │   │   │   └── utils
│   │   │   │   │       ├── mockHelpers.js
│   │   │   │   │       └── testFactories.js
│   │   │   │   ├── languageRoutes.test.ts
│   │   │   │   ├── limitType.test.ts
│   │   │   │   ├── settings.test.ts
│   │   │   │   ├── settingsRoutes.test.ts
│   │   │   │   ├── setup.ts
│   │   │   │   ├── translationRoutes.test.ts
│   │   │   │   └── utils
│   │   │   │       ├── dbHelpers.ts
│   │   │   │       ├── testFactories.ts
│   │   │   │       └── testHelpers.ts
│   │   │   └── utils
│   │   │       ├── ApiError.ts
│   │   │       ├── ApiResponse.ts
│   │   │       ├── errorConstants.ts
│   │   │       └── errorHandler.ts
│   │   └── tsconfig.json
│   └── frontend
│       └── package.json
└── project-tree.txt

28 directories, 76 files
</file>

<file path="README.md">
# Food Pantry Management System 

A web application designed for non-profit food pantries. Features automated inventory management, AI-powered translations, and multilingual accessibility.

## System Overview

- Automated inventory management for food pantries
- Zero-configuration multilingual support (60+ languages)
- AI-powered instant translations
- Dietary and allergen tracking
- Flexible item limits (per household/person)
- Category-based limit management

### Key Features

#### Core Functionality
- **Automated Management**
  - Inventory tracking and monitoring
  - Category and item organization
  - Status flags (must go, low supply)
  - Real-time updates across components

- **Language Support**
  - AI-powered translation system
  - Automatic language initialization
  - Manual translation refinement
  - Race condition protection
  - Instant updates across UI

- **Dietary System**
  - Automated dietary flags
  - Allergen tracking
  - Preference filtering
  - Standardized attributes

#### Technical Implementation
- **Backend**
  - SQLite with Prisma ORM
  - Express.js REST API
  - TypeScript services
  - OpenAI integration
  - Automated testing

- **Frontend**
  - Modular JavaScript architecture
  - Event-driven state management
  - Real-time synchronization
  - Component-based design
  - Comprehensive test coverage

## Getting Started

### Requirements
- Node.js v14+
- npm/yarn
- SQLite 3
- Git
- OpenAI API key

### Installation

1. Clone and enter directory:
```bash
git clone https://github.com/MattGeiger/food-pantry-app.git
cd food-pantry-app
```

2. Install dependencies:
```bash
npm install
cd packages/backend
npm install
```

3. Set up environment:
```bash
cp .env.example .env
# Add your OpenAI API key to .env
```

4. Initialize database:
```bash
npx prisma generate
npx prisma migrate reset --force
```

### Development

Start server:
```bash
npm run dev
```

Run tests:
```bash
npm test                 # All tests
npm run test:unit       # Unit tests
npm run test:watch      # Watch mode
npm run test:coverage   # Coverage report
```

Access application:
- API: http://localhost:3000
- UI: http://localhost:3000/index.html

## API Documentation

### Categories
```
GET    /api/categories
POST   /api/categories
GET    /api/categories/:id
PUT    /api/categories/:id
DELETE /api/categories/:id
```

### Food Items
```
GET    /api/food-items
POST   /api/food-items
GET    /api/food-items/:id
PUT    /api/food-items/:id
DELETE /api/food-items/:id
```

### Languages
```
GET    /api/languages
POST   /api/languages/bulk
GET    /api/languages/active
```

### Translations
```
GET    /api/translations
GET    /api/translations/language/:languageCode
POST   /api/translations/category/:categoryId
POST   /api/translations/food-item/:foodItemId
PUT    /api/translations/:id
DELETE /api/translations/:id
```

### Settings
```
GET    /api/settings
POST   /api/settings
```

## Development Status

✅ Complete
- Repository setup
- Development environment
- Backend implementation
- Test UI development
- OpenAI integration
- Language initialization
- Translation system
- Testing framework

🔄 In Progress
- Documentation updates
- Performance optimization
- Error handling improvements

📅 Planned
- React frontend
- User authentication
- Analytics dashboard
- Mobile interface

## Project Structure

```
packages/
├── backend/           # Main application
│   ├── prisma/       # Database layer
│   ├── public/       # Test UI
│   └── src/          # Backend source
└── frontend/         # React app (planned)
```

## Contributing

This project accepts contributions. See CHANGELOG.md for current development focus.

## License

MIT License - see LICENSE file for details.

## Support

For issues: [GitHub Issues](https://github.com/MattGeiger/food-pantry-app/issues)  
Documentation: [Project Wiki](https://github.com/MattGeiger/food-pantry-app/wiki)
</file>

</repository_files>
