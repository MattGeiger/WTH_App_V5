This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-29T06:58:05.390Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
packages/
  backend/
    prisma/
      migrations/
        20241130003245_init/
          migration.sql
        20241207052011_add_language_model_and_make_language_id_optional/
          migration.sql
        20241209004222_add_settings_model/
          migration.sql
        20241220064500_add_limit_type/
          migration.sql
        20241221195000_add_category_limit/
          migration.sql
        20241222002000_add_unique_name_constraints/
          migration.sql
        20241225021031_add_original_text_to_translations/
          migration.sql
        migration_lock.toml
      schema.prisma
    public/
      css/
        components/
          forms.css
          languages.css
          messages.css
          tables.css
        layout/
          sections.css
        styles.css
      js/
        foodItems/
          __tests__/
            coverage/
              lcov-report/
                base.css
                block-navigation.js
                index.html
                prettify.css
                prettify.js
                sorter.js
              clover.xml
            handlers/
              formData.test.js
              submit.test.js
              validation.test.js
            ui/
              forms.test.js
              stats.test.js
              table.test.js
            utils/
              assertions.js
              generateCoverage.js
              testFactories.js
              testHelpers.js
            babel.config.js
            FoodItemManager.test.js
            jest.config.js
            setup.js
          handlers/
            formData.js
            submit.js
            validation.js
          ui/
            forms.js
            stats.js
            table.js
          utils/
            errorHandler.js
          FoodItemManager.js
          index.js
        utils/
          sortableTable.js
        categories.js
        foodItems.js
        languages.js
        main.js
        settings.js
        translations.js
        utils.js
      index.html
      sample-claude.html
      sample-layout-part1.html
      sample-layout.html
      sample-layoutv2.html
      sample.html
    src/
      config/
        languageConfig.ts
      middleware/
        errorHandler.ts
        requestLogger.ts
      routes/
        categoryRoutes.ts
        foodItemRoutes.ts
        languageRoutes.ts
        settingsRoutes.ts
        translationRoutes.ts
      services/
        openai/
          __tests__/
            OpenAIService.test.ts
          OpenAIService.ts
        CategoryService.ts
        FoodItemService.ts
        LanguageService.ts
        TranslationService.ts
      tests/
        utils/
          dbHelpers.ts
          testFactories.ts
          testHelpers.ts
        categoryRoutes.test.ts
        CategoryService.test.ts
        foodItemRoutes.test.ts
        FoodItemService.test.ts
        languageRoutes.test.ts
        limitType.test.ts
        settings.test.ts
        settingsRoutes.test.ts
        setup.ts
        translationRoutes.test.ts
        TranslationService.test.ts
      utils/
        ApiError.ts
        ApiResponse.ts
        errorConstants.ts
        errorHandler.ts
        validationUtils.ts
      index.ts
    .env.example
    jest-setup.js
    jest.config.js
    package.json
    tsconfig.json
  frontend/
    package.json
.gitignore
LICENSE
package.json
project-tree.txt
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="packages/backend/prisma/migrations/20241130003245_init/migration.sql">
-- CreateTable
CREATE TABLE "Category" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "name" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- CreateTable
CREATE TABLE "FoodItem" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "name" TEXT NOT NULL,
    "categoryId" INTEGER NOT NULL,
    "imageUrl" TEXT,
    "thumbnailUrl" TEXT,
    "itemLimit" INTEGER,
    "inStock" BOOLEAN NOT NULL DEFAULT true,
    "mustGo" BOOLEAN NOT NULL DEFAULT false,
    "lowSupply" BOOLEAN NOT NULL DEFAULT false,
    "kosher" BOOLEAN NOT NULL DEFAULT false,
    "halal" BOOLEAN NOT NULL DEFAULT false,
    "vegetarian" BOOLEAN NOT NULL DEFAULT false,
    "vegan" BOOLEAN NOT NULL DEFAULT false,
    "glutenFree" BOOLEAN NOT NULL DEFAULT false,
    "organic" BOOLEAN NOT NULL DEFAULT false,
    "readyToEat" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "FoodItem_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "Translation" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "language" TEXT NOT NULL,
    "translatedText" TEXT NOT NULL,
    "categoryId" INTEGER,
    "foodItemId" INTEGER,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "Translation_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "Translation_foodItemId_fkey" FOREIGN KEY ("foodItemId") REFERENCES "FoodItem" ("id") ON DELETE SET NULL ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "CustomField" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "key" TEXT NOT NULL,
    "value" TEXT NOT NULL,
    "foodItemId" INTEGER NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "CustomField_foodItemId_fkey" FOREIGN KEY ("foodItemId") REFERENCES "FoodItem" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateIndex
CREATE INDEX "FoodItem_categoryId_idx" ON "FoodItem"("categoryId");

-- CreateIndex
CREATE UNIQUE INDEX "Translation_language_categoryId_key" ON "Translation"("language", "categoryId");

-- CreateIndex
CREATE UNIQUE INDEX "Translation_language_foodItemId_key" ON "Translation"("language", "foodItemId");

-- CreateIndex
CREATE INDEX "CustomField_foodItemId_idx" ON "CustomField"("foodItemId");
</file>

<file path="packages/backend/prisma/migrations/20241207052011_add_language_model_and_make_language_id_optional/migration.sql">
/*
  Warnings:

  - You are about to drop the column `language` on the `Translation` table. All the data in the column will be lost.

*/
-- CreateTable
CREATE TABLE "Language" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "code" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "active" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- RedefineTables
PRAGMA defer_foreign_keys=ON;
PRAGMA foreign_keys=OFF;
CREATE TABLE "new_Translation" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "translatedText" TEXT NOT NULL,
    "categoryId" INTEGER,
    "foodItemId" INTEGER,
    "languageId" INTEGER,
    "isAutomatic" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "Translation_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "Translation_foodItemId_fkey" FOREIGN KEY ("foodItemId") REFERENCES "FoodItem" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "Translation_languageId_fkey" FOREIGN KEY ("languageId") REFERENCES "Language" ("id") ON DELETE SET NULL ON UPDATE CASCADE
);
INSERT INTO "new_Translation" ("categoryId", "createdAt", "foodItemId", "id", "translatedText", "updatedAt") SELECT "categoryId", "createdAt", "foodItemId", "id", "translatedText", "updatedAt" FROM "Translation";
DROP TABLE "Translation";
ALTER TABLE "new_Translation" RENAME TO "Translation";
CREATE INDEX "Translation_languageId_idx" ON "Translation"("languageId");
CREATE UNIQUE INDEX "Translation_languageId_categoryId_key" ON "Translation"("languageId", "categoryId");
CREATE UNIQUE INDEX "Translation_languageId_foodItemId_key" ON "Translation"("languageId", "foodItemId");
PRAGMA foreign_keys=ON;
PRAGMA defer_foreign_keys=OFF;

-- CreateIndex
CREATE UNIQUE INDEX "Language_code_key" ON "Language"("code");
</file>

<file path="packages/backend/prisma/migrations/20241209004222_add_settings_model/migration.sql">
-- CreateTable
CREATE TABLE "Settings" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT DEFAULT 1,
    "globalUpperLimit" INTEGER NOT NULL DEFAULT 10,
    "updatedAt" DATETIME NOT NULL
);
</file>

<file path="packages/backend/prisma/migrations/20241220064500_add_limit_type/migration.sql">
-- Add limitType field to FoodItem
ALTER TABLE FoodItem ADD COLUMN limitType TEXT DEFAULT 'perHousehold';
</file>

<file path="packages/backend/prisma/migrations/20241221195000_add_category_limit/migration.sql">
-- CreateTable
CREATE TABLE "_prisma_new_Category" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "name" TEXT NOT NULL,
    "itemLimit" INTEGER NOT NULL DEFAULT 0,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- Copy data
INSERT INTO "_prisma_new_Category" ("id", "name", "createdAt", "updatedAt")
SELECT "id", "name", "createdAt", "updatedAt" FROM "Category";

-- Drop old table and rename new
DROP TABLE "Category";
ALTER TABLE "_prisma_new_Category" RENAME TO "Category";
</file>

<file path="packages/backend/prisma/migrations/20241222002000_add_unique_name_constraints/migration.sql">
-- CreateIndex
CREATE UNIQUE INDEX "Category_name_key" ON "Category"("name");
CREATE UNIQUE INDEX "FoodItem_name_key" ON "FoodItem"("name");
</file>

<file path="packages/backend/prisma/migrations/20241225021031_add_original_text_to_translations/migration.sql">
/*
  Warnings:

  - A unique constraint covering the columns `[languageId,originalText]` on the table `Translation` will be added. If there are existing duplicate values, this will fail.

*/
-- AlterTable
ALTER TABLE "Translation" ADD COLUMN "originalText" TEXT;

-- RedefineTables
PRAGMA defer_foreign_keys=ON;
PRAGMA foreign_keys=OFF;
CREATE TABLE "new_FoodItem" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "name" TEXT NOT NULL,
    "categoryId" INTEGER NOT NULL,
    "imageUrl" TEXT,
    "thumbnailUrl" TEXT,
    "itemLimit" INTEGER,
    "limitType" TEXT NOT NULL DEFAULT 'perHousehold',
    "inStock" BOOLEAN NOT NULL DEFAULT true,
    "mustGo" BOOLEAN NOT NULL DEFAULT false,
    "lowSupply" BOOLEAN NOT NULL DEFAULT false,
    "kosher" BOOLEAN NOT NULL DEFAULT false,
    "halal" BOOLEAN NOT NULL DEFAULT false,
    "vegetarian" BOOLEAN NOT NULL DEFAULT false,
    "vegan" BOOLEAN NOT NULL DEFAULT false,
    "glutenFree" BOOLEAN NOT NULL DEFAULT false,
    "organic" BOOLEAN NOT NULL DEFAULT false,
    "readyToEat" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "FoodItem_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);
INSERT INTO "new_FoodItem" ("categoryId", "createdAt", "glutenFree", "halal", "id", "imageUrl", "inStock", "itemLimit", "kosher", "limitType", "lowSupply", "mustGo", "name", "organic", "readyToEat", "thumbnailUrl", "updatedAt", "vegan", "vegetarian") SELECT "categoryId", "createdAt", "glutenFree", "halal", "id", "imageUrl", "inStock", "itemLimit", "kosher", coalesce("limitType", 'perHousehold') AS "limitType", "lowSupply", "mustGo", "name", "organic", "readyToEat", "thumbnailUrl", "updatedAt", "vegan", "vegetarian" FROM "FoodItem";
DROP TABLE "FoodItem";
ALTER TABLE "new_FoodItem" RENAME TO "FoodItem";
CREATE INDEX "FoodItem_categoryId_idx" ON "FoodItem"("categoryId");
CREATE UNIQUE INDEX "FoodItem_name_key" ON "FoodItem"("name");
PRAGMA foreign_keys=ON;
PRAGMA defer_foreign_keys=OFF;

-- CreateIndex
CREATE UNIQUE INDEX "Translation_languageId_originalText_key" ON "Translation"("languageId", "originalText");
</file>

<file path="packages/backend/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "sqlite"
</file>

<file path="packages/backend/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Category {
  id          Int           @id @default(autoincrement())
  name        String        // English name as base
  itemLimit   Int          @default(0)
  items       FoodItem[]
  translations Translation[]
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@unique([name])
}

model FoodItem {
  id            Int           @id @default(autoincrement())
  name          String        // English name as base
  categoryId    Int
  category      Category      @relation(fields: [categoryId], references: [id])
  translations  Translation[]
  
  imageUrl      String?
  thumbnailUrl  String?
  
  itemLimit     Int?
  limitType     String        @default("perHousehold")
  inStock       Boolean       @default(true)
  mustGo        Boolean       @default(false)
  lowSupply     Boolean       @default(false)
  
  kosher        Boolean       @default(false)
  halal         Boolean       @default(false)
  vegetarian    Boolean       @default(false)
  vegan         Boolean       @default(false)
  glutenFree    Boolean       @default(false)
  
  organic       Boolean       @default(false)
  readyToEat    Boolean       @default(false)
  
  customFields  CustomField[]
  
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  @@index([categoryId])
  @@unique([name])
}

model Translation {
  id             Int       @id @default(autoincrement())
  translatedText String
  originalText   String?   // For custom translations, store the original text
  categoryId     Int?
  category       Category? @relation(fields: [categoryId], references: [id])
  foodItemId     Int?
  foodItem       FoodItem? @relation(fields: [foodItemId], references: [id])
  languageId     Int?
  language       Language? @relation(fields: [languageId], references: [id])
  isAutomatic    Boolean   @default(false)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  
  // Only one translation per language per item type
  @@unique([languageId, categoryId])
  @@unique([languageId, foodItemId])
  @@unique([languageId, originalText])  // Only one translation per custom text per language
  @@index([languageId])
}

model Language {
  id           Int           @id @default(autoincrement())
  code         String        @unique
  name         String
  active       Boolean       @default(true)
  translations Translation[]
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
}

model CustomField {
  id          Int       @id @default(autoincrement())
  key         String
  value       String
  foodItemId  Int
  foodItem    FoodItem  @relation(fields: [foodItemId], references: [id])
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  @@index([foodItemId])
}

model Settings {
  id              Int      @id @default(1)
  globalUpperLimit Int     @default(10)
  updatedAt       DateTime @updatedAt
}
</file>

<file path="packages/backend/public/css/components/forms.css">
/* Form Groups */
.form__group {
    position: relative;
    margin: 0 0 24px 0;
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-width: 480px;
}

/* Base Input Styles */
.form__group input,
.form__group select,
.form__group textarea {
    width: 100%;
    padding: 12px 16px;
    font-size: 14px;
    line-height: 1.5;
    border: 1px solid #dadce0;
    border-radius: 4px;
    background: white;
    transition: all 0.2s ease;
    box-sizing: border-box;
    font-family: inherit;
    color: #333;
}

/* Labels */
.form__group label {
    font-size: 14px;
    font-weight: 500;
    color: #5f6368;
    margin-bottom: 4px;
    display: block;
}

/* Required Field Indicator */
.form__group label.required::after {
    content: "*";
    color: #d93025;
    margin-left: 4px;
}

/* Focus States */
.form__group input:focus,
.form__group select:focus,
.form__group textarea:focus {
    outline: none;
    border-color: #1a73e8;
    box-shadow: 0 0 0 4px rgba(26, 115, 232, 0.1);
}

/* Helper Text */
.form__group .helper-text {
    font-size: 12px;
    color: #5f6368;
    margin-top: 4px;
}

/* Error States */
.form__group.error input,
.form__group.error select,
.form__group.error textarea {
    border-color: #d93025;
}

.form__group.error .helper-text {
    color: #d93025;
}

/* Disabled States */
.form__group input:disabled,
.form__group select:disabled,
.form__group textarea:disabled {
    background-color: #f1f3f4;
    border-color: #dadce0;
    color: #80868b;
    cursor: not-allowed;
}

/* Select Input Styling */
.form__group select {
    appearance: none;
    padding-right: 40px;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%235f6368' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
    background-size: 24px;
}

/* Number Input Styling */
.form__group input[type="number"] {
    -moz-appearance: textfield;
}

.form__group input[type="number"]::-webkit-outer-spin-button,
.form__group input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

/* Flag Groups */
.dietary-flags-group,
.status-flags-group {
    margin-bottom: 32px;
}

.dietary-flags-group h3,
.status-flags-group h3 {
    font-size: 16px;
    font-weight: 600;
    color: #202124;
    margin: 0 0 8px 0;
}

/* Flag Grid Layout */
.flags-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 16px;
    margin: 24px 0;
    padding: 24px;
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 12px;
}

/* Flag Toggle Items */
.flag-toggle {
    background: white;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 12px;
    transition: all 0.2s ease;
}

.flag-toggle:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
}

.flag-toggle label {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    width: 100%;
    color: #495057;
    font-size: 14px;
    font-weight: 500;
}

.flag-toggle input[type="checkbox"] {
    width: 18px;
    height: 18px;
    border-radius: 4px;
    border: 2px solid #dee2e6;
    cursor: pointer;
    margin: 0;
}

/* Status vs Dietary Visual Differentiation */
.status-flags-group .flags-grid {
    border-color: rgba(33, 150, 243, 0.3);
    background: rgba(33, 150, 243, 0.02);
}

.dietary-flags-group .flags-grid {
    border-color: rgba(76, 175, 80, 0.3);
    background: rgba(76, 175, 80, 0.02);
}

/* Limit Type Group */
.limit-type-group {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 12px;
    margin: 16px 0;
}

/* Button Base Styles */
button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-family: inherit;
    font-size: 14px;
    font-weight: 500;
    min-height: 40px;
    padding: 8px 24px;
    border: none;
    cursor: pointer;
    transition: all 0.2s ease;
    text-decoration: none;
    line-height: 1.5;
    border-radius: 100px;
}

/* Primary Button */
button[type="submit"],
.primary-button {
    background: #1a73e8;
    color: white;
    border: none;
    font-weight: 500;
}

button[type="submit"]:hover,
.primary-button:hover {
    background: #1557b0;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

button[type="submit"]:active,
.primary-button:active {
    background: #174ea6;
}

/* Secondary Button */
button[type="button"],
.secondary-button {
    background: transparent;
    color: #1a73e8;
    border: 1px solid #1a73e8;
}

button[type="button"]:hover,
.secondary-button:hover {
    background: rgba(26, 115, 232, 0.04);
}

button[type="button"]:active,
.secondary-button:active {
    background: rgba(26, 115, 232, 0.1);
}

/* Button Focus States */
button:focus-visible {
    outline: 2px solid #1a73e8;
    outline-offset: 2px;
}

/* Disabled Button State */
button:disabled {
    background-color: #e8eaed;
    color: #80868b;
    border-color: transparent;
    cursor: not-allowed;
}

/* Button Groups */
.button-group {
    display: flex;
    gap: 12px;
    margin: 24px 0;
}

/* Form Section Styles */
.form-section {
    margin-bottom: 32px;
}

/* Responsive Design */
@media screen and (max-width: 768px) {
    .form__group {
        max-width: 100%;
    }
    
    .flags-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        padding: 16px;
        gap: 12px;
    }

    .flag-toggle {
        padding: 10px;
    }

    .limit-type-group {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    }
    
    button {
        width: 100%;
        justify-content: center;
    }
    
    .button-group {
        flex-direction: column;
    }
}

/* High Contrast Support */
@media (prefers-contrast: high) {
    .form__group input,
    .form__group select,
    .form__group textarea,
    .flag-toggle {
        border-width: 2px;
    }
    
    button[type="submit"],
    .primary-button {
        border: 2px solid #1a73e8;
    }
    
    .form__group input:focus,
    .form__group select:focus,
    .form__group textarea:focus {
        outline: 2px solid #1a73e8;
        outline-offset: 2px;
    }

    .status-flags-group .flags-grid {
        border: 2px solid #2196f3;
    }

    .dietary-flags-group .flags-grid {
        border: 2px solid #4caf50;
    }
}
</file>

<file path="packages/backend/public/css/components/languages.css">
/* Language Management Container */
#languageSection {
    position: relative;
}

/* Language Grid Layout */
.language-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 16px;
    margin: 24px 0;
    padding: 24px;
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 12px;
}

/* Language Toggle Items */
.language-toggle {
    background: white;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 12px;
    transition: all 0.2s ease;
}

.language-toggle:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
}

.language-toggle label {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    width: 100%;
    color: #495057;
    font-size: 14px;
    font-weight: 500;
}

.language-toggle input[type="checkbox"] {
    width: 18px;
    height: 18px;
    border-radius: 4px;
    border: 2px solid #dee2e6;
    cursor: pointer;
    margin: 0;
}

/* Language Filter Controls */
.filter-controls {
    display: flex;
    align-items: center;
    gap: 12px;
    margin: 24px 0;
    padding: 16px;
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
}

.filter-label {
    font-weight: 500;
    color: #495057;
    font-size: 14px;
    margin: 0;
    min-width: 80px;
}

.filter-select {
    padding: 8px 12px;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    font-size: 14px;
    color: #495057;
    background-color: white;
    cursor: pointer;
    min-width: 180px;
    transition: all 0.2s ease;
}

.filter-select:hover {
    border-color: #ced4da;
}

.filter-select:focus {
    border-color: #0066cc;
    outline: none;
    box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.1);
}

/* Update Languages Button */
#updateLanguages {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 10px 24px;
    background: #0066cc;
    color: white;
    border: none;
    border-radius: 100px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 24px 0;
}

#updateLanguages:hover {
    background: #0052a3;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Language Stats */
.language-stats {
    margin: 24px 0;
    padding: 24px;
    background: white;
    border: 1px solid #dee2e6;
    border-radius: 12px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.language-stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
}

.language-stat-item {
    display: flex;
    flex-direction: column;
    padding: 20px;
    background: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 8px;
    transition: all 0.2s ease;
}

.language-stat-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
}

.language-stat-value {
    font-size: 32px;
    font-weight: 700;
    color: #0066cc;
    margin-bottom: 8px;
    font-variant-numeric: tabular-nums;
    line-height: 1;
}

.language-stat-label {
    font-size: 14px;
    color: #6c757d;
    font-weight: 500;
    line-height: 1.4;
}

/* Language Status Badges */
.language-status {
    display: inline-flex;
    align-items: center;
    padding: 4px 12px;
    border-radius: 100px;
    font-size: 12px;
    font-weight: 500;
    line-height: 1.4;
}

.status-active {
    background-color: rgba(40, 167, 69, 0.1);
    color: #28a745;
}

.status-inactive {
    background-color: rgba(108, 117, 125, 0.1);
    color: #6c757d;
}

/* Last Updated Info */
.last-updated {
    margin-top: 16px;
    padding-top: 16px;
    border-top: 1px solid #dee2e6;
    color: #6c757d;
    font-size: 13px;
    font-style: italic;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

/* Section Warning */
.section-warning {
    padding: 16px;
    background: #fff3cd;
    border: 1px solid #ffeeba;
    border-radius: 8px;
    color: #856404;
    font-size: 14px;
    line-height: 1.5;
    margin: 24px 0;
}

/* Responsive Design */
@media screen and (max-width: 768px) {
    .language-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        padding: 16px;
        gap: 12px;
    }

    .language-toggle {
        padding: 10px;
    }

    .filter-controls {
        flex-direction: column;
        align-items: flex-start;
    }

    .filter-label {
        margin-bottom: 8px;
    }

    .filter-select {
        width: 100%;
    }

    #updateLanguages {
        width: 100%;
    }

    .language-stats-grid {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 16px;
    }

    .language-stat-value {
        font-size: 24px;
    }
}

/* High Contrast Support */
@media (prefers-contrast: high) {
    .language-toggle {
        border-width: 2px;
    }

    .status-active {
        background-color: transparent;
        outline: 2px solid #28a745;
    }

    .status-inactive {
        background-color: transparent;
        outline: 2px solid #6c757d;
    }
}
</file>

<file path="packages/backend/public/css/components/messages.css">
/* Message Area Container */
.message-area {
    min-height: 48px;
    margin: 0 0 24px 0;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

/* Base Message Styles */
.message {
    position: relative;
    padding: 12px 16px 12px 40px;
    margin: 0;
    border-radius: 8px;
    font-size: 14px;
    line-height: 1.5;
    display: flex;
    align-items: flex-start;
    gap: 12px;
    animation: messageSlide 0.3s ease-out;
}

/* Message Icons */
.message::before {
    content: "";
    position: absolute;
    left: 16px;
    top: 14px;
    width: 16px;
    height: 16px;
    background-repeat: no-repeat;
    background-position: center;
    background-size: contain;
}

/* Success Message */
.message--success {
    background-color: rgba(40, 167, 69, 0.1);
    border: 1px solid rgba(40, 167, 69, 0.2);
    color: #155724;
}

.message--success::before {
    content: "✓";
    color: #28a745;
}

/* Error Message */
.message--error {
    background-color: rgba(220, 53, 69, 0.1);
    border: 1px solid rgba(220, 53, 69, 0.2);
    color: #721c24;
}

.message--error::before {
    content: "!";
    color: #dc3545;
}

/* Warning Message */
.message--warning {
    background-color: rgba(255, 193, 7, 0.1);
    border: 1px solid rgba(255, 193, 7, 0.2);
    color: #856404;
}

.message--warning::before {
    content: "⚠";
    color: #ffc107;
}

/* Info Message */
.message--info {
    background-color: rgba(0, 102, 204, 0.1);
    border: 1px solid rgba(0, 102, 204, 0.2);
    color: #004085;
}

.message--info::before {
    content: "ℹ";
    color: #0066cc;
}

/* Note Message */
.message--note {
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    color: #495057;
    font-size: 13px;
    padding-left: 16px;
}

.message--note::before {
    content: none;
}

/* Message Content */
.message-content {
    flex: 1;
}

/* Form-specific Messages */
.form__group .message {
    margin-top: 4px;
    padding: 8px 12px;
    font-size: 13px;
}

/* Message Groups */
.message-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin: 16px 0;
}

/* Auto-dismissing Messages */
.message--auto-dismiss {
    animation: messageFade 5s forwards;
}

/* Loading Message */
.message--loading {
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    color: #495057;
}

.message--loading::before {
    content: "◌";
    animation: loadingRotate 1s linear infinite;
}

/* Field Validation Messages */
.validation-message {
    color: #dc3545;
    font-size: 13px;
    margin-top: 4px;
    display: none;
}

.form__group.has-error .validation-message {
    display: block;
}

/* Message with Actions */
.message--with-action {
    padding-right: 120px;
}

.message-action {
    position: absolute;
    right: 16px;
    top: 50%;
    transform: translateY(-50%);
    padding: 4px 12px;
    font-size: 13px;
    border-radius: 100px;
    border: 1px solid currentColor;
    background: transparent;
    color: inherit;
    cursor: pointer;
    transition: all 0.2s ease;
}

.message-action:hover {
    background-color: rgba(255, 255, 255, 0.2);
}

/* Input Help Text */
.help-text {
    color: #6c757d;
    font-size: 13px;
    margin-top: 4px;
    line-height: 1.4;
}

/* Global Limit Message */
.global-limit-message {
    color: #495057;
    font-size: 13px;
    font-style: italic;
    margin-top: 8px;
}

/* Animations */
@keyframes messageSlide {
    from {
        transform: translateY(-10px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

@keyframes messageFade {
    0%, 90% {
        opacity: 1;
        transform: translateY(0);
    }
    100% {
        opacity: 0;
        transform: translateY(-10px);
    }
}

@keyframes loadingRotate {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}

/* Accessibility */
@media (prefers-reduced-motion: reduce) {
    .message {
        animation: none;
    }
}

/* High Contrast Mode */
@media (prefers-contrast: high) {
    .message {
        border-width: 2px;
    }

    .message--success,
    .message--error,
    .message--warning,
    .message--info {
        background-color: white;
    }
}

/* Dark Mode Support */
@media (prefers-color-scheme: dark) {
    .message {
        border-width: 1px;
    }

    .message--note {
        background-color: rgba(255, 255, 255, 0.05);
        border-color: rgba(255, 255, 255, 0.1);
    }
}

/* Responsive Design */
@media screen and (max-width: 768px) {
    .message {
        padding: 12px 12px 12px 36px;
    }

    .message::before {
        left: 12px;
    }

    .message--with-action {
        padding-right: 12px;
        padding-bottom: 40px;
    }

    .message-action {
        right: 12px;
        bottom: 12px;
        top: auto;
        transform: none;
        width: calc(100% - 24px);
        text-align: center;
    }
}
</file>

<file path="packages/backend/public/css/components/tables.css">
/* Base Table Styles */
.table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    margin-top: 16px;
    background: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* Table Header */
.table__header {
    padding: 14px 16px;
    text-align: left;
    background-color: #f8f9fa;
    font-weight: 600;
    color: #212529;
    font-size: 14px;
    position: relative;
    border-bottom: 2px solid #dee2e6;
    white-space: nowrap;
}

/* Sortable Headers */
.table__header[data-sort] {
    cursor: pointer;
    user-select: none;
    padding-right: 32px;
}

.table__header[data-sort]:hover {
    background-color: #e9ecef;
}

/* Sort Indicators */
.sort-indicator {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    color: #6c757d;
    font-size: 12px;
    transition: transform 0.2s ease;
}

.table__header[data-sort]:hover .sort-indicator {
    color: #495057;
}

.sort-indicator.asc {
    transform: translateY(-50%) rotate(180deg);
}

/* Table Cells */
.table__cell {
    padding: 12px 16px;
    border-bottom: 1px solid #dee2e6;
    color: #495057;
    font-size: 14px;
    line-height: 1.5;
}

/* Row Hover */
.table tbody tr:hover {
    background-color: #f8f9fa;
}

/* Stats Summary Section */
.stats-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 16px;
    padding: 24px;
    margin-bottom: 32px;
    background: #fff;
    border: 1px solid #e9ecef;
    border-radius: 12px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.stats-item {
    display: flex;
    flex-direction: column;
    padding: 20px;
    background: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 8px;
    transition: all 0.2s ease;
}

.stats-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
}

.stats-value {
    font-size: 32px;
    font-weight: 700;
    color: #0066cc;
    margin-bottom: 8px;
    font-variant-numeric: tabular-nums;
    line-height: 1;
}

.stats-label {
    font-size: 14px;
    color: #6c757d;
    font-weight: 500;
    line-height: 1.4;
}

.stats-footer {
    grid-column: 1 / -1;
    color: #6c757d;
    font-size: 13px;
    font-style: italic;
    margin-top: 16px;
    padding-top: 16px;
    border-top: 1px solid #dee2e6;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

/* Table Actions */
.table-actions {
    display: flex;
    gap: 8px;
    white-space: nowrap;
}

/* Table Buttons */
.table button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    border: 1px solid transparent;
    gap: 4px;
}

/* Edit Button */
.table button.edit-btn,
.table button.edit-food-item-btn,
.table button.edit-translation-btn {
    background-color: rgba(0, 102, 204, 0.1);
    color: #0066cc;
    border-color: transparent;
}

.table button.edit-btn:hover,
.table button.edit-food-item-btn:hover,
.table button.edit-translation-btn:hover {
    background-color: rgba(0, 102, 204, 0.15);
}

/* Delete Button */
.table button.delete-btn,
.table button.delete-food-item-btn,
.table button.delete-translation-btn {
    background-color: rgba(220, 53, 69, 0.1);
    color: #dc3545;
    border-color: transparent;
}

.table button.delete-btn:hover,
.table button.delete-food-item-btn:hover,
.table button.delete-translation-btn:hover {
    background-color: rgba(220, 53, 69, 0.15);
}

/* Empty State */
.no-data {
    text-align: center;
    padding: 48px 24px;
    color: #6c757d;
    font-style: italic;
    background: #f8f9fa;
    border: 1px dashed #dee2e6;
    border-radius: 8px;
    margin: 24px 0;
}

/* Table Header Controls */
.table-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

/* Status Badges */
.status-badge {
    display: inline-flex;
    align-items: center;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 500;
    line-height: 1;
}

.status-badge--active {
    background-color: rgba(40, 167, 69, 0.1);
    color: #28a745;
}

.status-badge--inactive {
    background-color: rgba(108, 117, 125, 0.1);
    color: #6c757d;
}

/* Responsive Design */
@media screen and (max-width: 768px) {
    .stats-container {
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        padding: 16px;
        gap: 12px;
    }

    .stats-item {
        padding: 16px;
    }

    .stats-value {
        font-size: 24px;
    }

    .table-container {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
    }

    .table {
        min-width: 600px;
    }

    .table__header,
    .table__cell {
        padding: 10px 12px;
    }

    .table-actions {
        flex-direction: column;
        gap: 4px;
    }

    .table button {
        width: 100%;
    }
}

/* Print Styles */
@media print {
    .stats-container {
        break-inside: avoid;
        border: 1px solid #000;
        box-shadow: none;
    }

    .table {
        break-inside: auto;
        box-shadow: none;
    }

    .table__header,
    .table__cell {
        border-color: #000;
    }

    .table-actions {
        display: none;
    }
}
</file>

<file path="packages/backend/public/css/layout/sections.css">
/* Main Container */
body {
    max-width: 1200px;
    margin: 0 auto;
    padding: 32px 24px;
}

/* Section Base */
.section {
    margin: 40px 0;
    padding: 32px;
    background: white;
    border: 1px solid #dee2e6;
    border-radius: 12px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    width: 100%;
    box-sizing: border-box;
}

/* Section Headers */
.section h2 {
    color: #212529;
    font-size: 24px;
    font-weight: 600;
    margin: 0 0 24px 0;
    padding-bottom: 16px;
    border-bottom: 2px solid #e9ecef;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.section h3 {
    color: #495057;
    font-size: 18px;
    font-weight: 600;
    margin: 32px 0 16px 0;
}

.section h4 {
    color: #495057;
    font-size: 16px;
    font-weight: 600;
    margin: 24px 0 12px 0;
}

/* Section-specific Colors */
#settingsSection {
    border-left: 4px solid #0066cc;
}

#languageSection {
    border-left: 4px solid #28a745;
}

#categorySection {
    border-left: 4px solid #fd7e14;
}

#foodItemSection {
    border-left: 4px solid #dc3545;
}

#translationSection {
    border-left: 4px solid #6f42c1;
}

/* Section Form Groups */
.section .form__group {
    max-width: 480px;
    width: 100%;
    margin-bottom: 24px;
}

/* Message Areas */
.message-area {
    min-height: 48px;
    margin-bottom: 24px;
}

/* Content Layouts */
.section-content {
    margin: 24px 0;
}

/* List Sections */
.list-section {
    margin-top: 32px;
}

/* Stats Container */
.stats-container {
    margin: 24px 0;
}

/* Filter Controls */
.filter-controls {
    display: flex;
    align-items: center;
    gap: 16px;
    margin: 24px 0;
    padding: 16px;
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
}

/* Language Management */
#languageSection .language-grid {
    margin: 24px 0;
}

#languageSection .filter-controls {
    justify-content: flex-start;
}

/* Food Item Management */
#foodItemSection .flags-section {
    margin: 32px 0;
}

.flags-section h4 {
    color: #212529;
    margin-bottom: 16px;
    padding-bottom: 8px;
    border-bottom: 2px solid #e9ecef;
}

/* Translation Management */
#translationSection .translation-controls {
    margin: 24px 0;
}

.translation-controls .filter-group {
    display: flex;
    align-items: center;
    gap: 12px;
}

/* Section Banners */
.section-banner {
    padding: 16px;
    margin: 24px 0;
    border-radius: 8px;
    font-size: 14px;
    line-height: 1.5;
}

.section-banner--warning {
    background: #fff3cd;
    border: 1px solid #ffeeba;
    color: #856404;
}

.section-banner--note {
    background: #e7f5ff;
    border: 1px solid #b8daff;
    color: #004085;
}

/* Table Containers */
.table-container {
    margin: 24px 0;
    overflow-x: auto;
    border-radius: 8px;
}

/* Button Groups */
.button-group {
    display: flex;
    gap: 12px;
    margin: 24px 0;
}

/* Empty States */
.empty-state {
    text-align: center;
    padding: 48px 24px;
    background: #f8f9fa;
    border: 1px dashed #dee2e6;
    border-radius: 8px;
    color: #6c757d;
    margin: 24px 0;
}

/* Loading States */
.loading-state {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 200px;
    color: #6c757d;
}

/* Responsive Design */
@media screen and (max-width: 1024px) {
    .section {
        padding: 28px 24px;
        margin: 32px 0;
    }
}

@media screen and (max-width: 768px) {
    body {
        padding: 24px 16px;
    }

    .section {
        padding: 24px 16px;
        margin: 24px 0;
    }

    .section h2 {
        font-size: 20px;
        margin-bottom: 20px;
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
    }

    .section .form__group {
        max-width: 100%;
    }

    .filter-controls {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
    }

    .button-group {
        flex-direction: column;
        width: 100%;
    }

    .button-group button {
        width: 100%;
    }

    .translation-controls .filter-group {
        flex-direction: column;
        align-items: flex-start;
        width: 100%;
    }
}

@media screen and (max-width: 480px) {
    body {
        padding: 16px 12px;
    }

    .section {
        padding: 20px 12px;
        margin: 20px 0;
    }

    .section h2 {
        font-size: 18px;
    }
}

/* Print Styles */
@media print {
    .section {
        break-inside: avoid;
        border: none;
        box-shadow: none;
        padding: 20px 0;
    }

    .button-group,
    .filter-controls {
        display: none;
    }

    .section-banner {
        background: none;
        border: 1px solid #000;
    }
}

/* Global Header */
h1 {
    color: #212529;
    font-size: 32px;
    font-weight: 700;
    margin: 0 0 40px 0;
    text-align: center;
}

/* Help Text */
.help-text {
    font-size: 13px;
    color: #6c757d;
    margin-top: 8px;
    line-height: 1.4;
}
</file>

<file path="packages/backend/public/css/styles.css">
/* Base styles and imports */
@import 'components/messages.css';
@import 'components/tables.css';
@import 'components/forms.css';
@import 'components/languages.css';
@import 'layout/sections.css';

/* Global styles */
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;
    line-height: 1.4;
    color: #333;
    margin: 0;
    padding: 20px;
}

h1, h2, h3, h4 {
    margin-top: 0;
    margin-bottom: 0.5em;
}
</file>

<file path="packages/backend/public/js/foodItems/__tests__/coverage/lcov-report/base.css">
body, html {
  margin:0; padding: 0;
  height: 100%;
}
body {
    font-family: Helvetica Neue, Helvetica, Arial;
    font-size: 14px;
    color:#333;
}
.small { font-size: 12px; }
*, *:after, *:before {
  -webkit-box-sizing:border-box;
     -moz-box-sizing:border-box;
          box-sizing:border-box;
  }
h1 { font-size: 20px; margin: 0;}
h2 { font-size: 14px; }
pre {
    font: 12px/1.4 Consolas, "Liberation Mono", Menlo, Courier, monospace;
    margin: 0;
    padding: 0;
    -moz-tab-size: 2;
    -o-tab-size:  2;
    tab-size: 2;
}
a { color:#0074D9; text-decoration:none; }
a:hover { text-decoration:underline; }
.strong { font-weight: bold; }
.space-top1 { padding: 10px 0 0 0; }
.pad2y { padding: 20px 0; }
.pad1y { padding: 10px 0; }
.pad2x { padding: 0 20px; }
.pad2 { padding: 20px; }
.pad1 { padding: 10px; }
.space-left2 { padding-left:55px; }
.space-right2 { padding-right:20px; }
.center { text-align:center; }
.clearfix { display:block; }
.clearfix:after {
  content:'';
  display:block;
  height:0;
  clear:both;
  visibility:hidden;
  }
.fl { float: left; }
@media only screen and (max-width:640px) {
  .col3 { width:100%; max-width:100%; }
  .hide-mobile { display:none!important; }
}

.quiet {
  color: #7f7f7f;
  color: rgba(0,0,0,0.5);
}
.quiet a { opacity: 0.7; }

.fraction {
  font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace;
  font-size: 10px;
  color: #555;
  background: #E8E8E8;
  padding: 4px 5px;
  border-radius: 3px;
  vertical-align: middle;
}

div.path a:link, div.path a:visited { color: #333; }
table.coverage {
  border-collapse: collapse;
  margin: 10px 0 0 0;
  padding: 0;
}

table.coverage td {
  margin: 0;
  padding: 0;
  vertical-align: top;
}
table.coverage td.line-count {
    text-align: right;
    padding: 0 5px 0 20px;
}
table.coverage td.line-coverage {
    text-align: right;
    padding-right: 10px;
    min-width:20px;
}

table.coverage td span.cline-any {
    display: inline-block;
    padding: 0 5px;
    width: 100%;
}
.missing-if-branch {
    display: inline-block;
    margin-right: 5px;
    border-radius: 3px;
    position: relative;
    padding: 0 4px;
    background: #333;
    color: yellow;
}

.skip-if-branch {
    display: none;
    margin-right: 10px;
    position: relative;
    padding: 0 4px;
    background: #ccc;
    color: white;
}
.missing-if-branch .typ, .skip-if-branch .typ {
    color: inherit !important;
}
.coverage-summary {
  border-collapse: collapse;
  width: 100%;
}
.coverage-summary tr { border-bottom: 1px solid #bbb; }
.keyline-all { border: 1px solid #ddd; }
.coverage-summary td, .coverage-summary th { padding: 10px; }
.coverage-summary tbody { border: 1px solid #bbb; }
.coverage-summary td { border-right: 1px solid #bbb; }
.coverage-summary td:last-child { border-right: none; }
.coverage-summary th {
  text-align: left;
  font-weight: normal;
  white-space: nowrap;
}
.coverage-summary th.file { border-right: none !important; }
.coverage-summary th.pct { }
.coverage-summary th.pic,
.coverage-summary th.abs,
.coverage-summary td.pct,
.coverage-summary td.abs { text-align: right; }
.coverage-summary td.file { white-space: nowrap;  }
.coverage-summary td.pic { min-width: 120px !important;  }
.coverage-summary tfoot td { }

.coverage-summary .sorter {
    height: 10px;
    width: 7px;
    display: inline-block;
    margin-left: 0.5em;
    background: url(sort-arrow-sprite.png) no-repeat scroll 0 0 transparent;
}
.coverage-summary .sorted .sorter {
    background-position: 0 -20px;
}
.coverage-summary .sorted-desc .sorter {
    background-position: 0 -10px;
}
.status-line {  height: 10px; }
/* yellow */
.cbranch-no { background: yellow !important; color: #111; }
/* dark red */
.red.solid, .status-line.low, .low .cover-fill { background:#C21F39 }
.low .chart { border:1px solid #C21F39 }
.highlighted,
.highlighted .cstat-no, .highlighted .fstat-no, .highlighted .cbranch-no{
  background: #C21F39 !important;
}
/* medium red */
.cstat-no, .fstat-no, .cbranch-no, .cbranch-no { background:#F6C6CE }
/* light red */
.low, .cline-no { background:#FCE1E5 }
/* light green */
.high, .cline-yes { background:rgb(230,245,208) }
/* medium green */
.cstat-yes { background:rgb(161,215,106) }
/* dark green */
.status-line.high, .high .cover-fill { background:rgb(77,146,33) }
.high .chart { border:1px solid rgb(77,146,33) }
/* dark yellow (gold) */
.status-line.medium, .medium .cover-fill { background: #f9cd0b; }
.medium .chart { border:1px solid #f9cd0b; }
/* light yellow */
.medium { background: #fff4c2; }

.cstat-skip { background: #ddd; color: #111; }
.fstat-skip { background: #ddd; color: #111 !important; }
.cbranch-skip { background: #ddd !important; color: #111; }

span.cline-neutral { background: #eaeaea; }

.coverage-summary td.empty {
    opacity: .5;
    padding-top: 4px;
    padding-bottom: 4px;
    line-height: 1;
    color: #888;
}

.cover-fill, .cover-empty {
  display:inline-block;
  height: 12px;
}
.chart {
  line-height: 0;
}
.cover-empty {
    background: white;
}
.cover-full {
    border-right: none !important;
}
pre.prettyprint {
    border: none !important;
    padding: 0 !important;
    margin: 0 !important;
}
.com { color: #999 !important; }
.ignore-none { color: #999; font-weight: normal; }

.wrapper {
  min-height: 100%;
  height: auto !important;
  height: 100%;
  margin: 0 auto -48px;
}
.footer, .push {
  height: 48px;
}
</file>

<file path="packages/backend/public/js/foodItems/__tests__/coverage/lcov-report/block-navigation.js">
/* eslint-disable */
var jumpToCode = (function init() {
    // Classes of code we would like to highlight in the file view
    var missingCoverageClasses = ['.cbranch-no', '.cstat-no', '.fstat-no'];

    // Elements to highlight in the file listing view
    var fileListingElements = ['td.pct.low'];

    // We don't want to select elements that are direct descendants of another match
    var notSelector = ':not(' + missingCoverageClasses.join('):not(') + ') > '; // becomes `:not(a):not(b) > `

    // Selecter that finds elements on the page to which we can jump
    var selector =
        fileListingElements.join(', ') +
        ', ' +
        notSelector +
        missingCoverageClasses.join(', ' + notSelector); // becomes `:not(a):not(b) > a, :not(a):not(b) > b`

    // The NodeList of matching elements
    var missingCoverageElements = document.querySelectorAll(selector);

    var currentIndex;

    function toggleClass(index) {
        missingCoverageElements
            .item(currentIndex)
            .classList.remove('highlighted');
        missingCoverageElements.item(index).classList.add('highlighted');
    }

    function makeCurrent(index) {
        toggleClass(index);
        currentIndex = index;
        missingCoverageElements.item(index).scrollIntoView({
            behavior: 'smooth',
            block: 'center',
            inline: 'center'
        });
    }

    function goToPrevious() {
        var nextIndex = 0;
        if (typeof currentIndex !== 'number' || currentIndex === 0) {
            nextIndex = missingCoverageElements.length - 1;
        } else if (missingCoverageElements.length > 1) {
            nextIndex = currentIndex - 1;
        }

        makeCurrent(nextIndex);
    }

    function goToNext() {
        var nextIndex = 0;

        if (
            typeof currentIndex === 'number' &&
            currentIndex < missingCoverageElements.length - 1
        ) {
            nextIndex = currentIndex + 1;
        }

        makeCurrent(nextIndex);
    }

    return function jump(event) {
        if (
            document.getElementById('fileSearch') === document.activeElement &&
            document.activeElement != null
        ) {
            // if we're currently focused on the search input, we don't want to navigate
            return;
        }

        switch (event.which) {
            case 78: // n
            case 74: // j
                goToNext();
                break;
            case 66: // b
            case 75: // k
            case 80: // p
                goToPrevious();
                break;
        }
    };
})();
window.addEventListener('keydown', jumpToCode);
</file>

<file path="packages/backend/public/js/foodItems/__tests__/coverage/lcov-report/index.html">
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for All files</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="prettify.css" />
    <link rel="stylesheet" href="base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1>All files</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">Unknown% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/0</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">Unknown% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/0</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">Unknown% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/0</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">Unknown% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/0</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line medium'></div>
    <div class="pad1">
<table class="coverage-summary">
<thead>
<tr>
   <th data-col="file" data-fmt="html" data-html="true" class="file">File</th>
   <th data-col="pic" data-type="number" data-fmt="html" data-html="true" class="pic"></th>
   <th data-col="statements" data-type="number" data-fmt="pct" class="pct">Statements</th>
   <th data-col="statements_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="branches" data-type="number" data-fmt="pct" class="pct">Branches</th>
   <th data-col="branches_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="functions" data-type="number" data-fmt="pct" class="pct">Functions</th>
   <th data-col="functions_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="lines" data-type="number" data-fmt="pct" class="pct">Lines</th>
   <th data-col="lines_raw" data-type="number" data-fmt="html" class="abs"></th>
</tr>
</thead>
<tbody></tbody>
</table>
</div>
                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2024-12-29T04:32:02.161Z
            </div>
        <script src="prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="sorter.js"></script>
        <script src="block-navigation.js"></script>
    </body>
</html>
</file>

<file path="packages/backend/public/js/foodItems/__tests__/coverage/lcov-report/prettify.css">
.pln{color:#000}@media screen{.str{color:#080}.kwd{color:#008}.com{color:#800}.typ{color:#606}.lit{color:#066}.pun,.opn,.clo{color:#660}.tag{color:#008}.atn{color:#606}.atv{color:#080}.dec,.var{color:#606}.fun{color:red}}@media print,projection{.str{color:#060}.kwd{color:#006;font-weight:bold}.com{color:#600;font-style:italic}.typ{color:#404;font-weight:bold}.lit{color:#044}.pun,.opn,.clo{color:#440}.tag{color:#006;font-weight:bold}.atn{color:#404}.atv{color:#060}}pre.prettyprint{padding:2px;border:1px solid #888}ol.linenums{margin-top:0;margin-bottom:0}li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8{list-style-type:none}li.L1,li.L3,li.L5,li.L7,li.L9{background:#eee}
</file>

<file path="packages/backend/public/js/foodItems/__tests__/coverage/lcov-report/prettify.js">
/* eslint-disable */
window.PR_SHOULD_USE_CONTINUATION=true;(function(){var h=["break,continue,do,else,for,if,return,while"];var u=[h,"auto,case,char,const,default,double,enum,extern,float,goto,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"];var p=[u,"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"];var l=[p,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,dynamic_cast,explicit,export,friend,inline,late_check,mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"];var x=[p,"abstract,boolean,byte,extends,final,finally,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient"];var R=[x,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var"];var r="all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,true,try,unless,until,when,while,yes";var w=[p,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"];var s="caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END";var I=[h,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"];var f=[h,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"];var H=[h,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"];var A=[l,R,w,s+I,f,H];var e=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)/;var C="str";var z="kwd";var j="com";var O="typ";var G="lit";var L="pun";var F="pln";var m="tag";var E="dec";var J="src";var P="atn";var n="atv";var N="nocode";var M="(?:^^\\.?|[+-]|\\!|\\!=|\\!==|\\#|\\%|\\%=|&|&&|&&=|&=|\\(|\\*|\\*=|\\+=|\\,|\\-=|\\->|\\/|\\/=|:|::|\\;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\@|\\[|\\^|\\^=|\\^\\^|\\^\\^=|\\{|\\||\\|=|\\|\\||\\|\\|=|\\~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*";function k(Z){var ad=0;var S=false;var ac=false;for(var V=0,U=Z.length;V<U;++V){var ae=Z[V];if(ae.ignoreCase){ac=true}else{if(/[a-z]/i.test(ae.source.replace(/\\u[0-9a-f]{4}|\\x[0-9a-f]{2}|\\[^ux]/gi,""))){S=true;ac=false;break}}}var Y={b:8,t:9,n:10,v:11,f:12,r:13};function ab(ah){var ag=ah.charCodeAt(0);if(ag!==92){return ag}var af=ah.charAt(1);ag=Y[af];if(ag){return ag}else{if("0"<=af&&af<="7"){return parseInt(ah.substring(1),8)}else{if(af==="u"||af==="x"){return parseInt(ah.substring(2),16)}else{return ah.charCodeAt(1)}}}}function T(af){if(af<32){return(af<16?"\\x0":"\\x")+af.toString(16)}var ag=String.fromCharCode(af);if(ag==="\\"||ag==="-"||ag==="["||ag==="]"){ag="\\"+ag}return ag}function X(am){var aq=am.substring(1,am.length-1).match(new RegExp("\\\\u[0-9A-Fa-f]{4}|\\\\x[0-9A-Fa-f]{2}|\\\\[0-3][0-7]{0,2}|\\\\[0-7]{1,2}|\\\\[\\s\\S]|-|[^-\\\\]","g"));var ak=[];var af=[];var ao=aq[0]==="^";for(var ar=ao?1:0,aj=aq.length;ar<aj;++ar){var ah=aq[ar];if(/\\[bdsw]/i.test(ah)){ak.push(ah)}else{var ag=ab(ah);var al;if(ar+2<aj&&"-"===aq[ar+1]){al=ab(aq[ar+2]);ar+=2}else{al=ag}af.push([ag,al]);if(!(al<65||ag>122)){if(!(al<65||ag>90)){af.push([Math.max(65,ag)|32,Math.min(al,90)|32])}if(!(al<97||ag>122)){af.push([Math.max(97,ag)&~32,Math.min(al,122)&~32])}}}}af.sort(function(av,au){return(av[0]-au[0])||(au[1]-av[1])});var ai=[];var ap=[NaN,NaN];for(var ar=0;ar<af.length;++ar){var at=af[ar];if(at[0]<=ap[1]+1){ap[1]=Math.max(ap[1],at[1])}else{ai.push(ap=at)}}var an=["["];if(ao){an.push("^")}an.push.apply(an,ak);for(var ar=0;ar<ai.length;++ar){var at=ai[ar];an.push(T(at[0]));if(at[1]>at[0]){if(at[1]+1>at[0]){an.push("-")}an.push(T(at[1]))}}an.push("]");return an.join("")}function W(al){var aj=al.source.match(new RegExp("(?:\\[(?:[^\\x5C\\x5D]|\\\\[\\s\\S])*\\]|\\\\u[A-Fa-f0-9]{4}|\\\\x[A-Fa-f0-9]{2}|\\\\[0-9]+|\\\\[^ux0-9]|\\(\\?[:!=]|[\\(\\)\\^]|[^\\x5B\\x5C\\(\\)\\^]+)","g"));var ah=aj.length;var an=[];for(var ak=0,am=0;ak<ah;++ak){var ag=aj[ak];if(ag==="("){++am}else{if("\\"===ag.charAt(0)){var af=+ag.substring(1);if(af&&af<=am){an[af]=-1}}}}for(var ak=1;ak<an.length;++ak){if(-1===an[ak]){an[ak]=++ad}}for(var ak=0,am=0;ak<ah;++ak){var ag=aj[ak];if(ag==="("){++am;if(an[am]===undefined){aj[ak]="(?:"}}else{if("\\"===ag.charAt(0)){var af=+ag.substring(1);if(af&&af<=am){aj[ak]="\\"+an[am]}}}}for(var ak=0,am=0;ak<ah;++ak){if("^"===aj[ak]&&"^"!==aj[ak+1]){aj[ak]=""}}if(al.ignoreCase&&S){for(var ak=0;ak<ah;++ak){var ag=aj[ak];var ai=ag.charAt(0);if(ag.length>=2&&ai==="["){aj[ak]=X(ag)}else{if(ai!=="\\"){aj[ak]=ag.replace(/[a-zA-Z]/g,function(ao){var ap=ao.charCodeAt(0);return"["+String.fromCharCode(ap&~32,ap|32)+"]"})}}}}return aj.join("")}var aa=[];for(var V=0,U=Z.length;V<U;++V){var ae=Z[V];if(ae.global||ae.multiline){throw new Error(""+ae)}aa.push("(?:"+W(ae)+")")}return new RegExp(aa.join("|"),ac?"gi":"g")}function a(V){var U=/(?:^|\s)nocode(?:\s|$)/;var X=[];var T=0;var Z=[];var W=0;var S;if(V.currentStyle){S=V.currentStyle.whiteSpace}else{if(window.getComputedStyle){S=document.defaultView.getComputedStyle(V,null).getPropertyValue("white-space")}}var Y=S&&"pre"===S.substring(0,3);function aa(ab){switch(ab.nodeType){case 1:if(U.test(ab.className)){return}for(var ae=ab.firstChild;ae;ae=ae.nextSibling){aa(ae)}var ad=ab.nodeName;if("BR"===ad||"LI"===ad){X[W]="\n";Z[W<<1]=T++;Z[(W++<<1)|1]=ab}break;case 3:case 4:var ac=ab.nodeValue;if(ac.length){if(!Y){ac=ac.replace(/[ \t\r\n]+/g," ")}else{ac=ac.replace(/\r\n?/g,"\n")}X[W]=ac;Z[W<<1]=T;T+=ac.length;Z[(W++<<1)|1]=ab}break}}aa(V);return{sourceCode:X.join("").replace(/\n$/,""),spans:Z}}function B(S,U,W,T){if(!U){return}var V={sourceCode:U,basePos:S};W(V);T.push.apply(T,V.decorations)}var v=/\S/;function o(S){var V=undefined;for(var U=S.firstChild;U;U=U.nextSibling){var T=U.nodeType;V=(T===1)?(V?S:U):(T===3)?(v.test(U.nodeValue)?S:V):V}return V===S?undefined:V}function g(U,T){var S={};var V;(function(){var ad=U.concat(T);var ah=[];var ag={};for(var ab=0,Z=ad.length;ab<Z;++ab){var Y=ad[ab];var ac=Y[3];if(ac){for(var ae=ac.length;--ae>=0;){S[ac.charAt(ae)]=Y}}var af=Y[1];var aa=""+af;if(!ag.hasOwnProperty(aa)){ah.push(af);ag[aa]=null}}ah.push(/[\0-\uffff]/);V=k(ah)})();var X=T.length;var W=function(ah){var Z=ah.sourceCode,Y=ah.basePos;var ad=[Y,F];var af=0;var an=Z.match(V)||[];var aj={};for(var ae=0,aq=an.length;ae<aq;++ae){var ag=an[ae];var ap=aj[ag];var ai=void 0;var am;if(typeof ap==="string"){am=false}else{var aa=S[ag.charAt(0)];if(aa){ai=ag.match(aa[1]);ap=aa[0]}else{for(var ao=0;ao<X;++ao){aa=T[ao];ai=ag.match(aa[1]);if(ai){ap=aa[0];break}}if(!ai){ap=F}}am=ap.length>=5&&"lang-"===ap.substring(0,5);if(am&&!(ai&&typeof ai[1]==="string")){am=false;ap=J}if(!am){aj[ag]=ap}}var ab=af;af+=ag.length;if(!am){ad.push(Y+ab,ap)}else{var al=ai[1];var ak=ag.indexOf(al);var ac=ak+al.length;if(ai[2]){ac=ag.length-ai[2].length;ak=ac-al.length}var ar=ap.substring(5);B(Y+ab,ag.substring(0,ak),W,ad);B(Y+ab+ak,al,q(ar,al),ad);B(Y+ab+ac,ag.substring(ac),W,ad)}}ah.decorations=ad};return W}function i(T){var W=[],S=[];if(T.tripleQuotedStrings){W.push([C,/^(?:\'\'\'(?:[^\'\\]|\\[\s\S]|\'{1,2}(?=[^\']))*(?:\'\'\'|$)|\"\"\"(?:[^\"\\]|\\[\s\S]|\"{1,2}(?=[^\"]))*(?:\"\"\"|$)|\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$))/,null,"'\""])}else{if(T.multiLineStrings){W.push([C,/^(?:\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$)|\`(?:[^\\\`]|\\[\s\S])*(?:\`|$))/,null,"'\"`"])}else{W.push([C,/^(?:\'(?:[^\\\'\r\n]|\\.)*(?:\'|$)|\"(?:[^\\\"\r\n]|\\.)*(?:\"|$))/,null,"\"'"])}}if(T.verbatimStrings){S.push([C,/^@\"(?:[^\"]|\"\")*(?:\"|$)/,null])}var Y=T.hashComments;if(Y){if(T.cStyleComments){if(Y>1){W.push([j,/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,null,"#"])}else{W.push([j,/^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\b|[^\r\n]*)/,null,"#"])}S.push([C,/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h|[a-z]\w*)>/,null])}else{W.push([j,/^#[^\r\n]*/,null,"#"])}}if(T.cStyleComments){S.push([j,/^\/\/[^\r\n]*/,null]);S.push([j,/^\/\*[\s\S]*?(?:\*\/|$)/,null])}if(T.regexLiterals){var X=("/(?=[^/*])(?:[^/\\x5B\\x5C]|\\x5C[\\s\\S]|\\x5B(?:[^\\x5C\\x5D]|\\x5C[\\s\\S])*(?:\\x5D|$))+/");S.push(["lang-regex",new RegExp("^"+M+"("+X+")")])}var V=T.types;if(V){S.push([O,V])}var U=(""+T.keywords).replace(/^ | $/g,"");if(U.length){S.push([z,new RegExp("^(?:"+U.replace(/[\s,]+/g,"|")+")\\b"),null])}W.push([F,/^\s+/,null," \r\n\t\xA0"]);S.push([G,/^@[a-z_$][a-z_$@0-9]*/i,null],[O,/^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\w+_t\b)/,null],[F,/^[a-z_$][a-z_$@0-9]*/i,null],[G,new RegExp("^(?:0x[a-f0-9]+|(?:\\d(?:_\\d+)*\\d*(?:\\.\\d*)?|\\.\\d\\+)(?:e[+\\-]?\\d+)?)[a-z]*","i"),null,"0123456789"],[F,/^\\[\s\S]?/,null],[L,/^.[^\s\w\.$@\'\"\`\/\#\\]*/,null]);return g(W,S)}var K=i({keywords:A,hashComments:true,cStyleComments:true,multiLineStrings:true,regexLiterals:true});function Q(V,ag){var U=/(?:^|\s)nocode(?:\s|$)/;var ab=/\r\n?|\n/;var ac=V.ownerDocument;var S;if(V.currentStyle){S=V.currentStyle.whiteSpace}else{if(window.getComputedStyle){S=ac.defaultView.getComputedStyle(V,null).getPropertyValue("white-space")}}var Z=S&&"pre"===S.substring(0,3);var af=ac.createElement("LI");while(V.firstChild){af.appendChild(V.firstChild)}var W=[af];function ae(al){switch(al.nodeType){case 1:if(U.test(al.className)){break}if("BR"===al.nodeName){ad(al);if(al.parentNode){al.parentNode.removeChild(al)}}else{for(var an=al.firstChild;an;an=an.nextSibling){ae(an)}}break;case 3:case 4:if(Z){var am=al.nodeValue;var aj=am.match(ab);if(aj){var ai=am.substring(0,aj.index);al.nodeValue=ai;var ah=am.substring(aj.index+aj[0].length);if(ah){var ak=al.parentNode;ak.insertBefore(ac.createTextNode(ah),al.nextSibling)}ad(al);if(!ai){al.parentNode.removeChild(al)}}}break}}function ad(ak){while(!ak.nextSibling){ak=ak.parentNode;if(!ak){return}}function ai(al,ar){var aq=ar?al.cloneNode(false):al;var ao=al.parentNode;if(ao){var ap=ai(ao,1);var an=al.nextSibling;ap.appendChild(aq);for(var am=an;am;am=an){an=am.nextSibling;ap.appendChild(am)}}return aq}var ah=ai(ak.nextSibling,0);for(var aj;(aj=ah.parentNode)&&aj.nodeType===1;){ah=aj}W.push(ah)}for(var Y=0;Y<W.length;++Y){ae(W[Y])}if(ag===(ag|0)){W[0].setAttribute("value",ag)}var aa=ac.createElement("OL");aa.className="linenums";var X=Math.max(0,((ag-1))|0)||0;for(var Y=0,T=W.length;Y<T;++Y){af=W[Y];af.className="L"+((Y+X)%10);if(!af.firstChild){af.appendChild(ac.createTextNode("\xA0"))}aa.appendChild(af)}V.appendChild(aa)}function D(ac){var aj=/\bMSIE\b/.test(navigator.userAgent);var am=/\n/g;var al=ac.sourceCode;var an=al.length;var V=0;var aa=ac.spans;var T=aa.length;var ah=0;var X=ac.decorations;var Y=X.length;var Z=0;X[Y]=an;var ar,aq;for(aq=ar=0;aq<Y;){if(X[aq]!==X[aq+2]){X[ar++]=X[aq++];X[ar++]=X[aq++]}else{aq+=2}}Y=ar;for(aq=ar=0;aq<Y;){var at=X[aq];var ab=X[aq+1];var W=aq+2;while(W+2<=Y&&X[W+1]===ab){W+=2}X[ar++]=at;X[ar++]=ab;aq=W}Y=X.length=ar;var ae=null;while(ah<T){var af=aa[ah];var S=aa[ah+2]||an;var ag=X[Z];var ap=X[Z+2]||an;var W=Math.min(S,ap);var ak=aa[ah+1];var U;if(ak.nodeType!==1&&(U=al.substring(V,W))){if(aj){U=U.replace(am,"\r")}ak.nodeValue=U;var ai=ak.ownerDocument;var ao=ai.createElement("SPAN");ao.className=X[Z+1];var ad=ak.parentNode;ad.replaceChild(ao,ak);ao.appendChild(ak);if(V<S){aa[ah+1]=ak=ai.createTextNode(al.substring(W,S));ad.insertBefore(ak,ao.nextSibling)}}V=W;if(V>=S){ah+=2}if(V>=ap){Z+=2}}}var t={};function c(U,V){for(var S=V.length;--S>=0;){var T=V[S];if(!t.hasOwnProperty(T)){t[T]=U}else{if(window.console){console.warn("cannot override language handler %s",T)}}}}function q(T,S){if(!(T&&t.hasOwnProperty(T))){T=/^\s*</.test(S)?"default-markup":"default-code"}return t[T]}c(K,["default-code"]);c(g([],[[F,/^[^<?]+/],[E,/^<!\w[^>]*(?:>|$)/],[j,/^<\!--[\s\S]*?(?:-\->|$)/],["lang-",/^<\?([\s\S]+?)(?:\?>|$)/],["lang-",/^<%([\s\S]+?)(?:%>|$)/],[L,/^(?:<[%?]|[%?]>)/],["lang-",/^<xmp\b[^>]*>([\s\S]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\s\S]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);c(g([[F,/^[\s]+/,null," \t\r\n"],[n,/^(?:\"[^\"]*\"?|\'[^\']*\'?)/,null,"\"'"]],[[m,/^^<\/?[a-z](?:[\w.:-]*\w)?|\/?>$/i],[P,/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^>\'\"\s]*(?:[^>\'\"\s\/]|\/(?=\s)))/],[L,/^[=<>\/]+/],["lang-js",/^on\w+\s*=\s*\"([^\"]+)\"/i],["lang-js",/^on\w+\s*=\s*\'([^\']+)\'/i],["lang-js",/^on\w+\s*=\s*([^\"\'>\s]+)/i],["lang-css",/^style\s*=\s*\"([^\"]+)\"/i],["lang-css",/^style\s*=\s*\'([^\']+)\'/i],["lang-css",/^style\s*=\s*([^\"\'>\s]+)/i]]),["in.tag"]);c(g([],[[n,/^[\s\S]+/]]),["uq.val"]);c(i({keywords:l,hashComments:true,cStyleComments:true,types:e}),["c","cc","cpp","cxx","cyc","m"]);c(i({keywords:"null,true,false"}),["json"]);c(i({keywords:R,hashComments:true,cStyleComments:true,verbatimStrings:true,types:e}),["cs"]);c(i({keywords:x,cStyleComments:true}),["java"]);c(i({keywords:H,hashComments:true,multiLineStrings:true}),["bsh","csh","sh"]);c(i({keywords:I,hashComments:true,multiLineStrings:true,tripleQuotedStrings:true}),["cv","py"]);c(i({keywords:s,hashComments:true,multiLineStrings:true,regexLiterals:true}),["perl","pl","pm"]);c(i({keywords:f,hashComments:true,multiLineStrings:true,regexLiterals:true}),["rb"]);c(i({keywords:w,cStyleComments:true,regexLiterals:true}),["js"]);c(i({keywords:r,hashComments:3,cStyleComments:true,multilineStrings:true,tripleQuotedStrings:true,regexLiterals:true}),["coffee"]);c(g([],[[C,/^[\s\S]+/]]),["regex"]);function d(V){var U=V.langExtension;try{var S=a(V.sourceNode);var T=S.sourceCode;V.sourceCode=T;V.spans=S.spans;V.basePos=0;q(U,T)(V);D(V)}catch(W){if("console" in window){console.log(W&&W.stack?W.stack:W)}}}function y(W,V,U){var S=document.createElement("PRE");S.innerHTML=W;if(U){Q(S,U)}var T={langExtension:V,numberLines:U,sourceNode:S};d(T);return S.innerHTML}function b(ad){function Y(af){return document.getElementsByTagName(af)}var ac=[Y("pre"),Y("code"),Y("xmp")];var T=[];for(var aa=0;aa<ac.length;++aa){for(var Z=0,V=ac[aa].length;Z<V;++Z){T.push(ac[aa][Z])}}ac=null;var W=Date;if(!W.now){W={now:function(){return +(new Date)}}}var X=0;var S;var ab=/\blang(?:uage)?-([\w.]+)(?!\S)/;var ae=/\bprettyprint\b/;function U(){var ag=(window.PR_SHOULD_USE_CONTINUATION?W.now()+250:Infinity);for(;X<T.length&&W.now()<ag;X++){var aj=T[X];var ai=aj.className;if(ai.indexOf("prettyprint")>=0){var ah=ai.match(ab);var am;if(!ah&&(am=o(aj))&&"CODE"===am.tagName){ah=am.className.match(ab)}if(ah){ah=ah[1]}var al=false;for(var ak=aj.parentNode;ak;ak=ak.parentNode){if((ak.tagName==="pre"||ak.tagName==="code"||ak.tagName==="xmp")&&ak.className&&ak.className.indexOf("prettyprint")>=0){al=true;break}}if(!al){var af=aj.className.match(/\blinenums\b(?::(\d+))?/);af=af?af[1]&&af[1].length?+af[1]:true:false;if(af){Q(aj,af)}S={langExtension:ah,sourceNode:aj,numberLines:af};d(S)}}}if(X<T.length){setTimeout(U,250)}else{if(ad){ad()}}}U()}window.prettyPrintOne=y;window.prettyPrint=b;window.PR={createSimpleLexer:g,registerLangHandler:c,sourceDecorator:i,PR_ATTRIB_NAME:P,PR_ATTRIB_VALUE:n,PR_COMMENT:j,PR_DECLARATION:E,PR_KEYWORD:z,PR_LITERAL:G,PR_NOCODE:N,PR_PLAIN:F,PR_PUNCTUATION:L,PR_SOURCE:J,PR_STRING:C,PR_TAG:m,PR_TYPE:O}})();PR.registerLangHandler(PR.createSimpleLexer([],[[PR.PR_DECLARATION,/^<!\w[^>]*(?:>|$)/],[PR.PR_COMMENT,/^<\!--[\s\S]*?(?:-\->|$)/],[PR.PR_PUNCTUATION,/^(?:<[%?]|[%?]>)/],["lang-",/^<\?([\s\S]+?)(?:\?>|$)/],["lang-",/^<%([\s\S]+?)(?:%>|$)/],["lang-",/^<xmp\b[^>]*>([\s\S]+?)<\/xmp\b[^>]*>/i],["lang-handlebars",/^<script\b[^>]*type\s*=\s*['"]?text\/x-handlebars-template['"]?\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],["lang-js",/^<script\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\s\S]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i],[PR.PR_DECLARATION,/^{{[#^>/]?\s*[\w.][^}]*}}/],[PR.PR_DECLARATION,/^{{&?\s*[\w.][^}]*}}/],[PR.PR_DECLARATION,/^{{{>?\s*[\w.][^}]*}}}/],[PR.PR_COMMENT,/^{{![^}]*}}/]]),["handlebars","hbs"]);PR.registerLangHandler(PR.createSimpleLexer([[PR.PR_PLAIN,/^[ \t\r\n\f]+/,null," \t\r\n\f"]],[[PR.PR_STRING,/^\"(?:[^\n\r\f\\\"]|\\(?:\r\n?|\n|\f)|\\[\s\S])*\"/,null],[PR.PR_STRING,/^\'(?:[^\n\r\f\\\']|\\(?:\r\n?|\n|\f)|\\[\s\S])*\'/,null],["lang-css-str",/^url\(([^\)\"\']*)\)/i],[PR.PR_KEYWORD,/^(?:url|rgb|\!important|@import|@page|@media|@charset|inherit)(?=[^\-\w]|$)/i,null],["lang-css-kw",/^(-?(?:[_a-z]|(?:\\[0-9a-f]+ ?))(?:[_a-z0-9\-]|\\(?:\\[0-9a-f]+ ?))*)\s*:/i],[PR.PR_COMMENT,/^\/\*[^*]*\*+(?:[^\/*][^*]*\*+)*\//],[PR.PR_COMMENT,/^(?:<!--|-->)/],[PR.PR_LITERAL,/^(?:\d+|\d*\.\d+)(?:%|[a-z]+)?/i],[PR.PR_LITERAL,/^#(?:[0-9a-f]{3}){1,2}/i],[PR.PR_PLAIN,/^-?(?:[_a-z]|(?:\\[\da-f]+ ?))(?:[_a-z\d\-]|\\(?:\\[\da-f]+ ?))*/i],[PR.PR_PUNCTUATION,/^[^\s\w\'\"]+/]]),["css"]);PR.registerLangHandler(PR.createSimpleLexer([],[[PR.PR_KEYWORD,/^-?(?:[_a-z]|(?:\\[\da-f]+ ?))(?:[_a-z\d\-]|\\(?:\\[\da-f]+ ?))*/i]]),["css-kw"]);PR.registerLangHandler(PR.createSimpleLexer([],[[PR.PR_STRING,/^[^\)\"\']+/]]),["css-str"]);
</file>

<file path="packages/backend/public/js/foodItems/__tests__/coverage/lcov-report/sorter.js">
/* eslint-disable */
var addSorting = (function() {
    'use strict';
    var cols,
        currentSort = {
            index: 0,
            desc: false
        };

    // returns the summary table element
    function getTable() {
        return document.querySelector('.coverage-summary');
    }
    // returns the thead element of the summary table
    function getTableHeader() {
        return getTable().querySelector('thead tr');
    }
    // returns the tbody element of the summary table
    function getTableBody() {
        return getTable().querySelector('tbody');
    }
    // returns the th element for nth column
    function getNthColumn(n) {
        return getTableHeader().querySelectorAll('th')[n];
    }

    function onFilterInput() {
        const searchValue = document.getElementById('fileSearch').value;
        const rows = document.getElementsByTagName('tbody')[0].children;
        for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            if (
                row.textContent
                    .toLowerCase()
                    .includes(searchValue.toLowerCase())
            ) {
                row.style.display = '';
            } else {
                row.style.display = 'none';
            }
        }
    }

    // loads the search box
    function addSearchBox() {
        var template = document.getElementById('filterTemplate');
        var templateClone = template.content.cloneNode(true);
        templateClone.getElementById('fileSearch').oninput = onFilterInput;
        template.parentElement.appendChild(templateClone);
    }

    // loads all columns
    function loadColumns() {
        var colNodes = getTableHeader().querySelectorAll('th'),
            colNode,
            cols = [],
            col,
            i;

        for (i = 0; i < colNodes.length; i += 1) {
            colNode = colNodes[i];
            col = {
                key: colNode.getAttribute('data-col'),
                sortable: !colNode.getAttribute('data-nosort'),
                type: colNode.getAttribute('data-type') || 'string'
            };
            cols.push(col);
            if (col.sortable) {
                col.defaultDescSort = col.type === 'number';
                colNode.innerHTML =
                    colNode.innerHTML + '<span class="sorter"></span>';
            }
        }
        return cols;
    }
    // attaches a data attribute to every tr element with an object
    // of data values keyed by column name
    function loadRowData(tableRow) {
        var tableCols = tableRow.querySelectorAll('td'),
            colNode,
            col,
            data = {},
            i,
            val;
        for (i = 0; i < tableCols.length; i += 1) {
            colNode = tableCols[i];
            col = cols[i];
            val = colNode.getAttribute('data-value');
            if (col.type === 'number') {
                val = Number(val);
            }
            data[col.key] = val;
        }
        return data;
    }
    // loads all row data
    function loadData() {
        var rows = getTableBody().querySelectorAll('tr'),
            i;

        for (i = 0; i < rows.length; i += 1) {
            rows[i].data = loadRowData(rows[i]);
        }
    }
    // sorts the table using the data for the ith column
    function sortByIndex(index, desc) {
        var key = cols[index].key,
            sorter = function(a, b) {
                a = a.data[key];
                b = b.data[key];
                return a < b ? -1 : a > b ? 1 : 0;
            },
            finalSorter = sorter,
            tableBody = document.querySelector('.coverage-summary tbody'),
            rowNodes = tableBody.querySelectorAll('tr'),
            rows = [],
            i;

        if (desc) {
            finalSorter = function(a, b) {
                return -1 * sorter(a, b);
            };
        }

        for (i = 0; i < rowNodes.length; i += 1) {
            rows.push(rowNodes[i]);
            tableBody.removeChild(rowNodes[i]);
        }

        rows.sort(finalSorter);

        for (i = 0; i < rows.length; i += 1) {
            tableBody.appendChild(rows[i]);
        }
    }
    // removes sort indicators for current column being sorted
    function removeSortIndicators() {
        var col = getNthColumn(currentSort.index),
            cls = col.className;

        cls = cls.replace(/ sorted$/, '').replace(/ sorted-desc$/, '');
        col.className = cls;
    }
    // adds sort indicators for current column being sorted
    function addSortIndicators() {
        getNthColumn(currentSort.index).className += currentSort.desc
            ? ' sorted-desc'
            : ' sorted';
    }
    // adds event listeners for all sorter widgets
    function enableUI() {
        var i,
            el,
            ithSorter = function ithSorter(i) {
                var col = cols[i];

                return function() {
                    var desc = col.defaultDescSort;

                    if (currentSort.index === i) {
                        desc = !currentSort.desc;
                    }
                    sortByIndex(i, desc);
                    removeSortIndicators();
                    currentSort.index = i;
                    currentSort.desc = desc;
                    addSortIndicators();
                };
            };
        for (i = 0; i < cols.length; i += 1) {
            if (cols[i].sortable) {
                // add the click event handler on the th so users
                // dont have to click on those tiny arrows
                el = getNthColumn(i).querySelector('.sorter').parentElement;
                if (el.addEventListener) {
                    el.addEventListener('click', ithSorter(i));
                } else {
                    el.attachEvent('onclick', ithSorter(i));
                }
            }
        }
    }
    // adds sorting functionality to the UI
    return function() {
        if (!getTable()) {
            return;
        }
        cols = loadColumns();
        loadData();
        addSearchBox();
        addSortIndicators();
        enableUI();
    };
})();

window.addEventListener('load', addSorting);
</file>

<file path="packages/backend/public/js/foodItems/__tests__/coverage/clover.xml">
<?xml version="1.0" encoding="UTF-8"?>
<coverage generated="1735446722165" clover="3.2.0">
  <project timestamp="1735446722165" name="All files">
    <metrics statements="0" coveredstatements="0" conditionals="0" coveredconditionals="0" methods="0" coveredmethods="0" elements="0" coveredelements="0" complexity="0" loc="0" ncloc="0" packages="0" files="0" classes="0"/>
  </project>
</coverage>
</file>

<file path="packages/backend/public/js/foodItems/__tests__/handlers/formData.test.js">
import { collectFormData } from '../../handlers/formData.js';

describe('Form Data Collection', () => {
    let mockManager;
    let mockDocument;

    beforeEach(() => {
        // Set up DOM elements
        document.body.innerHTML = `
            <input type="radio" name="limitType" value="perHousehold" checked>
            <input type="radio" name="limitType" value="perPerson">
            <input type="checkbox" id="foodItemInStock">
            <input type="checkbox" id="foodItemMustGo">
            <input type="checkbox" id="foodItemLowSupply">
            <input type="checkbox" id="foodItemReadyToEat">
            <input type="checkbox" id="foodItemKosher">
            <input type="checkbox" id="foodItemHalal">
            <input type="checkbox" id="foodItemVegetarian">
            <input type="checkbox" id="foodItemVegan">
            <input type="checkbox" id="foodItemGlutenFree">
            <input type="checkbox" id="foodItemOrganic">
        `;

        // Mock manager instance
        mockManager = {
            nameInput: { value: '  Test Item  ' },
            categorySelect: { value: '1' },
            itemLimitSelect: { value: '5' }
        };
    });

    it('should collect basic item data', () => {
        const result = collectFormData(mockManager);
        
        expect(result).toEqual(expect.objectContaining({
            name: 'Test Item',
            categoryId: 1,
            itemLimit: 5,
            limitType: 'perHousehold'
        }));
    });

    it('should handle empty item limit', () => {
        mockManager.itemLimitSelect.value = '';
        const result = collectFormData(mockManager);
        
        expect(result.itemLimit).toBe(0);
    });

    it('should collect status flags', () => {
        document.getElementById('foodItemInStock').checked = true;
        document.getElementById('foodItemMustGo').checked = true;
        
        const result = collectFormData(mockManager);
        
        expect(result).toEqual(expect.objectContaining({
            inStock: true,
            mustGo: true,
            lowSupply: false,
            readyToEat: false
        }));
    });

    it('should collect dietary flags', () => {
        document.getElementById('foodItemKosher').checked = true;
        document.getElementById('foodItemVegan').checked = true;
        document.getElementById('foodItemGlutenFree').checked = true;
        
        const result = collectFormData(mockManager);
        
        expect(result).toEqual(expect.objectContaining({
            kosher: true,
            halal: false,
            vegetarian: false,
            vegan: true,
            glutenFree: true,
            organic: false
        }));
    });

    it('should handle per-person limit type', () => {
        document.querySelector('input[value="perPerson"]').checked = true;
        document.querySelector('input[value="perHousehold"]').checked = false;
        
        const result = collectFormData(mockManager);
        
        expect(result.limitType).toBe('perPerson');
    });

    it('should handle all flags unchecked', () => {
        const result = collectFormData(mockManager);
        
        const flags = [
            'inStock', 'mustGo', 'lowSupply', 'readyToEat',
            'kosher', 'halal', 'vegetarian', 'vegan', 
            'glutenFree', 'organic'
        ];
        
        flags.forEach(flag => {
            expect(result[flag]).toBe(false);
        });
    });
});
</file>

<file path="packages/backend/public/js/foodItems/__tests__/handlers/submit.test.js">
import { handleSubmit } from '../../handlers/submit.js';
import { showMessage } from '../../../utils.js';
import { validateName } from '../../handlers/validation.js';
import { collectFormData } from '../../handlers/formData.js';

jest.mock('../../../utils.js');
jest.mock('../../handlers/validation.js');
jest.mock('../../handlers/formData.js');

describe('Submit Handler', () => {
    let mockEvent;
    let mockManager;
    let mockData;

    beforeEach(() => {
        // Setup DOM
        document.body.innerHTML = `
            <form id="foodItemForm">
                <input type="text" id="foodItemName" value="Test Item">
                <select id="foodItemCategory" value="1"></select>
                <input type="hidden" id="foodItemId" value="">
                <button type="submit">Add Food Item</button>
            </form>
        `;

        // Mock event
        mockEvent = {
            preventDefault: jest.fn()
        };

        // Mock form data
        mockData = {
            name: 'Test Item',
            categoryId: 1,
            itemLimit: 5,
            limitType: 'perHousehold',
            inStock: true
        };

        // Mock manager
        mockManager = {
            nameInput: { value: 'Test Item' },
            categorySelect: { value: '1' },
            updateItem: jest.fn().mockResolvedValue(true),
            createItem: jest.fn().mockResolvedValue(true),
            resetForm: jest.fn(),
            loadFoodItems: jest.fn()
        };

        // Setup default mock returns
        validateName.mockReturnValue(true);
        collectFormData.mockReturnValue(mockData);
        showMessage.mockReset();
    });

    afterEach(() => {
        document.body.innerHTML = '';
        jest.clearAllMocks();
    });

    it('should prevent default form submission', async () => {
        await handleSubmit(mockEvent, mockManager);
        expect(mockEvent.preventDefault).toHaveBeenCalled();
    });

    it('should validate name before submission', async () => {
        validateName.mockReturnValue(false);
        await handleSubmit(mockEvent, mockManager);
        expect(validateName).toHaveBeenCalledWith('Test Item');
        expect(mockManager.createItem).not.toHaveBeenCalled();
    });

    it('should show error if category is not selected', async () => {
        mockData.categoryId = '';
        collectFormData.mockReturnValue(mockData);
        
        await handleSubmit(mockEvent, mockManager);
        
        expect(showMessage).toHaveBeenCalledWith(
            'Please select a category',
            'error',
            'foodItem'
        );
        expect(mockManager.createItem).not.toHaveBeenCalled();
    });

    it('should create new item when no ID present', async () => {
        mockManager.createItem.mockResolvedValue(true);
        
        await handleSubmit(mockEvent, mockManager);
        
        expect(mockManager.createItem).toHaveBeenCalledWith(mockData);
        expect(mockManager.updateItem).not.toHaveBeenCalled();
        expect(mockManager.resetForm).toHaveBeenCalled();
        expect(mockManager.loadFoodItems).toHaveBeenCalled();
    });

    it('should update existing item when ID present', async () => {
        document.getElementById('foodItemId').value = '1';
        mockManager.updateItem.mockResolvedValue(true);
        
        await handleSubmit(mockEvent, mockManager);
        
        expect(mockManager.updateItem).toHaveBeenCalledWith('1', mockData);
        expect(mockManager.createItem).not.toHaveBeenCalled();
        expect(mockManager.resetForm).toHaveBeenCalled();
        expect(mockManager.loadFoodItems).toHaveBeenCalled();
    });

    it('should handle API errors gracefully', async () => {
        const apiError = new Error('API Error');
        mockManager.createItem.mockRejectedValue(apiError);
        
        await handleSubmit(mockEvent, mockManager);
        
        expect(showMessage).toHaveBeenCalledWith(
            'API Error',
            'error',
            'foodItem'
        );
        expect(mockManager.resetForm).not.toHaveBeenCalled();
        expect(mockManager.loadFoodItems).not.toHaveBeenCalled();
    });

    it('should handle validation errors appropriately', async () => {
        validateName.mockImplementation(() => {
            throw new Error('Validation failed');
        });
        
        await handleSubmit(mockEvent, mockManager);
        
        expect(showMessage).toHaveBeenCalledWith(
            'Validation failed',
            'error',
            'foodItem'
        );
        expect(mockManager.createItem).not.toHaveBeenCalled();
    });

    it('should handle form data collection errors', async () => {
        collectFormData.mockImplementation(() => {
            throw new Error('Data collection failed');
        });
        
        await handleSubmit(mockEvent, mockManager);
        
        expect(showMessage).toHaveBeenCalledWith(
            'Data collection failed',
            'error',
            'foodItem'
        );
        expect(mockManager.createItem).not.toHaveBeenCalled();
    });
});
</file>

<file path="packages/backend/public/js/foodItems/__tests__/handlers/validation.test.js">
import { validateName, handleNameInput, VALIDATION_RULES } from '../../handlers/validation.js';
import { showMessage } from '../../../utils.js';

jest.mock('../../../utils.js', () => ({
    showMessage: jest.fn()
}));

describe('Food Item Validation', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });

    describe('validateName', () => {
        it('should return false for names shorter than minimum length', () => {
            expect(validateName('ab')).toBe(false);
            expect(showMessage).toHaveBeenCalledWith(
                'Food item name must be at least three characters long',
                'error',
                'foodItem'
            );
        });

        it('should return false for names with insufficient letters', () => {
            expect(validateName('123')).toBe(false);
            expect(showMessage).toHaveBeenCalledWith(
                'Food item name must include at least three letters',
                'error',
                'foodItem'
            );
        });

        it('should return false for names with repeated words', () => {
            expect(validateName('Apple Apple')).toBe(false);
            expect(showMessage).toHaveBeenCalledWith(
                'Food item name contains repeated words',
                'error',
                'foodItem'
            );
        });

        it('should return true for valid names', () => {
            expect(validateName('Fresh Apples')).toBe(true);
            expect(showMessage).not.toHaveBeenCalled();
        });
    });

    describe('handleNameInput', () => {
        let input;

        beforeEach(() => {
            input = { value: '' };
        });

        it('should trim input to maximum length', () => {
            input.value = 'a'.repeat(VALIDATION_RULES.NAME.MAX_LENGTH + 5);
            const result = handleNameInput(input);
            expect(result.length).toBe(VALIDATION_RULES.NAME.MAX_LENGTH);
            expect(showMessage).toHaveBeenCalledWith(
                'Input cannot exceed 36 characters',
                'warning',
                'foodItem'
            );
        });

        it('should remove consecutive spaces', () => {
            input.value = 'Fresh  Apples';
            expect(handleNameInput(input)).toBe('Fresh Apples');
        });

        it('should convert to title case', () => {
            input.value = 'fresh apples';
            expect(handleNameInput(input)).toBe('Fresh Apples');
        });

        it('should warn about repeated words', () => {
            input.value = 'fresh fresh apples';
            handleNameInput(input);
            expect(showMessage).toHaveBeenCalledWith(
                'Input contains repeated words',
                'warning',
                'foodItem'
            );
        });
    });
});
</file>

<file path="packages/backend/public/js/foodItems/__tests__/ui/forms.test.js">
import { createFormLayout } from '../../ui/forms.js';

describe('Form UI Components', () => {
    let mockForm;
    let mockManager;

    beforeEach(() => {
        // Create basic form structure
        document.body.innerHTML = `
            <form id="testForm">
                <input type="text" id="foodItemName" name="foodItemName">
                <select id="foodItemCategory"></select>
                <select id="itemLimitSelect"></select>
                <input type="hidden" id="foodItemId" value="">
                <button type="submit">Add Food Item</button>
            </form>
        `;

        mockForm = document.getElementById('testForm');
        mockManager = {
            form: mockForm,
            nameInput: document.getElementById('foodItemName'),
            categorySelect: document.getElementById('foodItemCategory'),
            itemLimitSelect: document.getElementById('itemLimitSelect'),
            settingsManager: {
                getCurrentLimit: () => 10
            }
        };

        // Initialize form layout
        createFormLayout(mockManager);
    });

    afterEach(() => {
        document.body.innerHTML = '';
        jest.clearAllMocks();
    });

    describe('Form Layout Creation', () => {
        it('should create all form sections', () => {
            const sections = mockForm.querySelectorAll('.form-section');
            expect(sections.length).toBe(3);
            
            const sectionTypes = ['input', 'status', 'dietary'];
            sectionTypes.forEach(type => {
                const section = mockForm.querySelector(`.${type}-section`);
                expect(section).toBeTruthy();
                expect(section.classList.contains('form-section')).toBe(true);
            });
        });

        it('should create form groups with required labels', () => {
            const formGroups = mockForm.querySelectorAll('.form__group');
            expect(formGroups.length).toBe(3);

            const requiredLabels = mockForm.querySelectorAll('label.required');
            expect(requiredLabels.length).toBe(3);

            const expectedLabels = ['Item Name:', 'Category:', 'Item Limit:'];
            const labelTexts = Array.from(requiredLabels).map(label => label.textContent);
            expectedLabels.forEach(text => {
                expect(labelTexts).toContain(text);
            });
        });

        it('should create limit type group', () => {
            const limitGroup = document.getElementById('limitTypeContainer');
            expect(limitGroup).toBeTruthy();
            expect(limitGroup.style.display).toBe('none');
            expect(limitGroup.classList.contains('limit-type-group')).toBe(true);

            const radios = limitGroup.querySelectorAll('input[type="radio"]');
            expect(radios.length).toBe(2);

            const radioValues = Array.from(radios).map(radio => radio.value);
            expect(radioValues).toContain('perHousehold');
            expect(radioValues).toContain('perPerson');

            const perHousehold = limitGroup.querySelector('input[value="perHousehold"]');
            expect(perHousehold.checked).toBe(true);

            ['perHousehold', 'perPerson'].forEach(id => {
                const label = document.querySelector(`label[for="${id}"]`);
                expect(label).toBeTruthy();
            });
        });

        it('should create status flags group', () => {
            const statusSection = mockForm.querySelector('.status-section');
            expect(statusSection).toBeTruthy();

            const statusGroup = statusSection.querySelector('.status-flags-group');
            expect(statusGroup).toBeTruthy();

            const heading = statusGroup.querySelector('h3');
            expect(heading).toBeTruthy();
            expect(heading.textContent).toBe('Status Flags');

            const grid = statusGroup.querySelector('.flags-grid');
            expect(grid).toBeTruthy();

            const statusFlags = [
                { id: 'foodItemInStock', label: 'In Stock' },
                { id: 'foodItemMustGo', label: 'Must Go' },
                { id: 'foodItemLowSupply', label: 'Low Supply' },
                { id: 'foodItemReadyToEat', label: 'Ready to Eat' }
            ];

            const flags = grid.querySelectorAll('.flag-toggle');
            expect(flags.length).toBe(statusFlags.length);

            flags.forEach((flag, index) => {
                const input = flag.querySelector('input[type="checkbox"]');
                const label = flag.querySelector('label');
                expect(input.id).toBe(statusFlags[index].id);
                expect(label.textContent).toBe(statusFlags[index].label);
            });
        });

        it('should create dietary flags group', () => {
            const dietarySection = mockForm.querySelector('.dietary-section');
            expect(dietarySection).toBeTruthy();

            const dietaryGroup = dietarySection.querySelector('.dietary-flags-group');
            expect(dietaryGroup).toBeTruthy();

            const heading = dietaryGroup.querySelector('h3');
            expect(heading).toBeTruthy();
            expect(heading.textContent).toBe('Dietary Flags');

            const grid = dietaryGroup.querySelector('.flags-grid');
            expect(grid).toBeTruthy();

            const dietaryFlags = [
                { id: 'foodItemKosher', label: 'Kosher' },
                { id: 'foodItemHalal', label: 'Halal' },
                { id: 'foodItemVegetarian', label: 'Vegetarian' },
                { id: 'foodItemVegan', label: 'Vegan' },
                { id: 'foodItemGlutenFree', label: 'Gluten Free' },
                { id: 'foodItemOrganic', label: 'Organic' }
            ];

            const flags = grid.querySelectorAll('.flag-toggle');
            expect(flags.length).toBe(dietaryFlags.length);

            flags.forEach((flag, index) => {
                const input = flag.querySelector('input[type="checkbox"]');
                const label = flag.querySelector('label');
                expect(input.id).toBe(dietaryFlags[index].id);
                expect(label.textContent).toBe(dietaryFlags[index].label);
            });
        });
    });

    describe('Form Interactions', () => {
        it('should have correct initial state for limit type radios', () => {
            const perHousehold = document.getElementById('perHousehold');
            const perPerson = document.getElementById('perPerson');
            
            expect(perHousehold).toBeTruthy();
            expect(perPerson).toBeTruthy();
            expect(perHousehold.checked).toBe(true);
            expect(perPerson.checked).toBe(false);
        });

        it('should create accessible flag inputs', () => {
            const allFlags = mockForm.querySelectorAll('.flag-toggle input[type="checkbox"]');
            expect(allFlags.length).toBeGreaterThan(0);

            allFlags.forEach(flag => {
                expect(flag.id).toBeTruthy();
                const label = document.querySelector(`label[for="${flag.id}"]`);
                expect(label).toBeTruthy();
                expect(label.textContent.trim()).toBeTruthy();
            });
        });

        it('should maintain form hierarchy', () => {
            const sections = Array.from(mockForm.querySelectorAll('.form-section'));
            expect(sections.length).toBe(3);
            
            sections.forEach(section => {
                expect(section.children.length).toBeGreaterThan(0);
                expect(section.classList.contains('form-section')).toBe(true);
            });
        });
    });

    describe('Form Element Attributes', () => {
        it('should apply correct classes to form groups', () => {
            const groups = mockForm.querySelectorAll('.form__group');
            expect(groups.length).toBe(3);

            groups.forEach(group => {
                const label = group.querySelector('label');
                const input = group.querySelector('input, select');
                
                expect(label).toBeTruthy();
                expect(input).toBeTruthy();
                expect(label.classList.contains('required')).toBe(true);
            });
        });

        it('should set up flag groups with correct structure', () => {
            const flagGroups = mockForm.querySelectorAll('.flags-grid');
            expect(flagGroups.length).toBe(2);

            flagGroups.forEach(grid => {
                const toggles = grid.querySelectorAll('.flag-toggle');
                expect(toggles.length).toBeGreaterThan(0);

                toggles.forEach(toggle => {
                    const input = toggle.querySelector('input[type="checkbox"]');
                    const label = toggle.querySelector('label');
                    
                    expect(input).toBeTruthy();
                    expect(label).toBeTruthy();
                    expect(input.id).toBeTruthy();
                    expect(label.htmlFor).toBe(input.id);
                });
            });
        });
    });
});
</file>

<file path="packages/backend/public/js/foodItems/__tests__/ui/stats.test.js">
import { updateStats } from '../../ui/stats.js';

describe('Stats UI Component', () => {
    let mockManager;
    const mockItems = [
        {
            id: 1,
            name: 'Item 1',
            inStock: true,
            itemLimit: 5
        },
        {
            id: 2,
            name: 'Item 2',
            inStock: false,
            itemLimit: 0
        },
        {
            id: 3,
            name: 'Item 3',
            inStock: true,
            itemLimit: 3
        }
    ];

    beforeEach(() => {
        // Set up our DOM environment
        document.body.innerHTML = '<div id="foodItemStats"></div>';
        mockManager = {
            foodItemStats: document.getElementById('foodItemStats'),
            lastUpdated: new Date('2024-12-27T12:00:00Z')
        };
    });

    it('should not update stats if stats container is missing', () => {
        const managerWithoutStats = { ...mockManager, foodItemStats: null };
        expect(() => updateStats(mockItems, managerWithoutStats)).not.toThrow();
    });

    it('should display correct total items count', () => {
        updateStats(mockItems, mockManager);
        expect(mockManager.foodItemStats.textContent).toContain('Total Items: 3');
    });

    it('should display correct in-stock count', () => {
        updateStats(mockItems, mockManager);
        expect(mockManager.foodItemStats.textContent).toContain('In Stock: 2');
    });

    it('should display correct out-of-stock count', () => {
        updateStats(mockItems, mockManager);
        expect(mockManager.foodItemStats.textContent).toContain('Out of Stock: 1');
    });

    it('should display correct limited items count', () => {
        updateStats(mockItems, mockManager);
        expect(mockManager.foodItemStats.textContent).toContain('Limited: 2');
    });

    it('should display correct unlimited items count', () => {
        updateStats(mockItems, mockManager);
        expect(mockManager.foodItemStats.textContent).toContain('Unlimited: 1');
    });

    it('should display last updated timestamp', () => {
        updateStats(mockItems, mockManager);
        expect(mockManager.foodItemStats.textContent).toContain('Last Updated: ');
        expect(mockManager.foodItemStats.textContent).toContain(
            mockManager.lastUpdated.toLocaleString()
        );
    });

    it('should handle empty items array', () => {
        updateStats([], mockManager);
        expect(mockManager.foodItemStats.textContent).toContain('Total Items: 0');
        expect(mockManager.foodItemStats.textContent).toContain('In Stock: 0');
        expect(mockManager.foodItemStats.textContent).toContain('Out of Stock: 0');
    });

    it('should handle missing lastUpdated timestamp', () => {
        const managerWithoutTimestamp = { ...mockManager, lastUpdated: null };
        updateStats(mockItems, managerWithoutTimestamp);
        expect(mockManager.foodItemStats.textContent).not.toContain('Last Updated: ');
    });

    it('should create stats with correct DOM structure', () => {
        updateStats(mockItems, mockManager);
        
        const statsDiv = mockManager.foodItemStats.querySelector('.stats');
        expect(statsDiv).toBeTruthy();
        
        const statSpans = statsDiv.querySelectorAll('span');
        expect(statSpans.length).toBe(6); // 5 stats + timestamp
    });

    it('should handle all items being in stock', () => {
        const allInStockItems = mockItems.map(item => ({ ...item, inStock: true }));
        updateStats(allInStockItems, mockManager);
        expect(mockManager.foodItemStats.textContent).toContain('In Stock: 3');
        expect(mockManager.foodItemStats.textContent).toContain('Out of Stock: 0');
    });

    it('should handle all items being limited', () => {
        const allLimitedItems = mockItems.map(item => ({ ...item, itemLimit: 5 }));
        updateStats(allLimitedItems, mockManager);
        expect(mockManager.foodItemStats.textContent).toContain('Limited: 3');
        expect(mockManager.foodItemStats.textContent).toContain('Unlimited: 0');
    });
});
</file>

<file path="packages/backend/public/js/foodItems/__tests__/ui/table.test.js">
import { createFoodItemRow, displayFoodItems } from '../../ui/table.js';

describe('Table UI Components', () => {
    let mockManager;
    const mockItem = {
        id: 1,
        name: 'Test Item',
        category: { name: 'Test Category', id: 1 },
        itemLimit: 5,
        limitType: 'perHousehold',
        inStock: true,
        mustGo: false,
        lowSupply: true,
        readyToEat: false,
        kosher: true,
        halal: false,
        vegetarian: true,
        vegan: false,
        glutenFree: true,
        organic: false,
        createdAt: '2024-12-27T12:00:00Z'
    };

    beforeEach(() => {
        document.body.innerHTML = '<table><tbody id="testTableBody"></tbody></table>';
        mockManager = {
            tableBody: document.getElementById('testTableBody'),
            sortableTable: {
                setupSortingControls: jest.fn()
            }
        };
    });

    describe('Row Creation', () => {
        let row;

        beforeEach(() => {
            const rowHtml = createFoodItemRow(mockItem, mockManager);
            const container = document.createElement('tbody');
            container.innerHTML = rowHtml;
            row = container.firstElementChild;
        });

        it('should create row with all cells', () => {
            const cells = row.querySelectorAll('td');
            expect(cells.length).toBe(7);
        });

        it('should format item name and category', () => {
            const cells = row.querySelectorAll('td');
            expect(cells[0].textContent).toBe('Test Item');
            expect(cells[1].textContent).toBe('Test Category');
        });

        it('should format status flags correctly', () => {
            const statusCell = row.querySelectorAll('td')[2];
            expect(statusCell.textContent).toContain('In Stock');
            expect(statusCell.textContent).toContain('Low Supply');
            expect(statusCell.textContent).not.toContain('Must Go');
        });

        it('should format dietary flags correctly', () => {
            const dietaryCell = row.querySelectorAll('td')[3];
            expect(dietaryCell.textContent).toContain('Kosher');
            expect(dietaryCell.textContent).toContain('Vegetarian');
            expect(dietaryCell.textContent).toContain('GF');
            expect(dietaryCell.textContent).not.toContain('Halal');
        });

        it('should format limit display correctly', () => {
            const limitCell = row.querySelectorAll('td')[4];
            expect(limitCell.textContent).toBe('5 Per Household');
        });

        it('should format date correctly', () => {
            const dateCell = row.querySelectorAll('td')[5];
            expect(dateCell.textContent).toBe(new Date(mockItem.createdAt).toLocaleDateString());
        });

        it('should create action buttons', () => {
            const actionCell = row.querySelectorAll('td')[6];
            expect(actionCell.querySelector('.edit-food-item-btn')).toBeTruthy();
            expect(actionCell.querySelector('.delete-food-item-btn')).toBeTruthy();
        });

        it('should store item data in edit button', () => {
            const editButton = row.querySelector('.edit-food-item-btn');
            const storedData = JSON.parse(editButton.dataset.item);
            expect(storedData.id).toBe(mockItem.id);
            expect(storedData.name).toBe(mockItem.name);
        });
    });

    describe('Table Display', () => {
        it('should handle empty food items array', () => {
            displayFoodItems([], mockManager);
            expect(mockManager.tableBody.innerHTML).toContain('No food items found');
            expect(mockManager.sortableTable.setupSortingControls).not.toHaveBeenCalled();
        });

        it('should handle null food items', () => {
            displayFoodItems(null, mockManager);
            expect(mockManager.tableBody.innerHTML).toContain('No food items found');
            expect(mockManager.sortableTable.setupSortingControls).not.toHaveBeenCalled();
        });

        it('should display multiple food items', () => {
            const items = [
                mockItem,
                { ...mockItem, id: 2, name: 'Second Item' }
            ];

            displayFoodItems(items, mockManager);
            
            const rows = mockManager.tableBody.querySelectorAll('tr');
            expect(rows.length).toBe(2);
            expect(mockManager.sortableTable.setupSortingControls).toHaveBeenCalled();
        });

        it('should handle items with missing category', () => {
            const itemWithoutCategory = { ...mockItem, category: null };
            displayFoodItems([itemWithoutCategory], mockManager);
            
            const categoryCell = mockManager.tableBody.querySelector('td:nth-child(2)');
            expect(categoryCell.textContent).toBe('Unknown');
        });

        it('should format items with no limit', () => {
            const unlimitedItem = { ...mockItem, itemLimit: 0 };
            displayFoodItems([unlimitedItem], mockManager);
            
            const limitCell = mockManager.tableBody.querySelector('td:nth-child(5)');
            expect(limitCell.textContent).toBe('No Limit');
        });
    });
});
</file>

<file path="packages/backend/public/js/foodItems/__tests__/utils/assertions.js">
/**
 * Custom assertions for Food Item tests
 */

export function expectFormValidationState(form, { isValid = true, errorMessage = null } = {}) {
    const submitButton = form.querySelector('button[type="submit"]');
    expect(submitButton.disabled).toBe(!isValid);
    
    if (errorMessage) {
        const messageArea = document.querySelector('.message-area');
        expect(messageArea.textContent).toContain(errorMessage);
        expect(messageArea.querySelector('.message--error')).toBeTruthy();
    }
}

export function expectTableStructure(tableBody) {
    const rows = tableBody.querySelectorAll('tr');
    rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        expect(cells.length).toBe(7); // Standard columns
        
        // Check cell types
        expect(cells[0].textContent).toBeTruthy(); // Name
        expect(cells[1].textContent).toBeTruthy(); // Category
        expect(cells[2].textContent).toBeTruthy(); // Status
        expect(cells[3].textContent).toBeDefined(); // Dietary
        expect(cells[4].textContent).toMatch(/No Limit|\d+ (Per Household|Per Person)/); // Limit
        expect(cells[5].textContent).toMatch(/\d{1,2}\/\d{1,2}\/\d{4}/); // Date
        expect(cells[6].querySelectorAll('button').length).toBe(2); // Actions
    });
}

export function expectSortableHeaders(table) {
    const headers = table.querySelectorAll('th[data-sort]');
    headers.forEach(header => {
        expect(header.classList.contains('table__header')).toBe(true);
        expect(header.querySelector('.sort-indicator')).toBeTruthy();
    });
}

export function expectValidStats(statsContainer, expectedStats) {
    const stats = statsContainer.querySelectorAll('.stats span');
    const statsText = Array.from(stats).map(span => span.textContent);
    
    expect(statsText).toContain(`Total Items: ${expectedStats.total}`);
    expect(statsText).toContain(`In Stock: ${expectedStats.inStock}`);
    expect(statsText).toContain(`Out of Stock: ${expectedStats.outOfStock}`);
    expect(statsText).toContain(`Limited: ${expectedStats.limited}`);
    expect(statsText).toContain(`Unlimited: ${expectedStats.unlimited}`);
    
    if (expectedStats.lastUpdated) {
        expect(statsText.some(text => text.includes('Last Updated:'))).toBe(true);
    }
}

export function expectFormData(formData, expectedData) {
    // Basic fields
    expect(formData.name).toBe(expectedData.name);
    expect(formData.categoryId).toBe(expectedData.categoryId);
    expect(formData.itemLimit).toBe(expectedData.itemLimit);
    expect(formData.limitType).toBe(expectedData.limitType);

    // Status flags
    const statusFlags = ['inStock', 'mustGo', 'lowSupply', 'readyToEat'];
    statusFlags.forEach(flag => {
        expect(formData[flag]).toBe(expectedData[flag] ?? false);
    });

    // Dietary flags
    const dietaryFlags = ['kosher', 'halal', 'vegetarian', 'vegan', 'glutenFree', 'organic'];
    dietaryFlags.forEach(flag => {
        expect(formData[flag]).toBe(expectedData[flag] ?? false);
    });
}

export function expectValidationErrors(errors, expectedErrors) {
    expect(errors.length).toBe(expectedErrors.length);
    expectedErrors.forEach((expected, index) => {
        expect(errors[index]).toEqual(expect.objectContaining({
            field: expected.field,
            message: expected.message,
            type: 'validation'
        }));
    });
}

export function expectApiCallSequence(apiMock, expectedCalls) {
    expect(apiMock.mock.calls.length).toBe(expectedCalls.length);
    expectedCalls.forEach((expected, index) => {
        const [endpoint, data] = apiMock.mock.calls[index];
        expect(endpoint).toBe(expected.endpoint);
        if (expected.data) {
            expect(data).toEqual(expect.objectContaining(expected.data));
        }
    });
}

export function expectDomChanges(beforeSnapshot, afterSnapshot) {
    const changes = {
        added: [],
        removed: [],
        modified: []
    };

    // Compare DOM trees and collect changes
    function compareNodes(before, after) {
        if (!before && after) {
            changes.added.push(after);
        } else if (before && !after) {
            changes.removed.push(before);
        } else if (before.nodeValue !== after.nodeValue) {
            changes.modified.push({
                element: after,
                oldValue: before.nodeValue,
                newValue: after.nodeValue
            });
        }

        // Recursively compare children
        const beforeChildren = Array.from(before?.childNodes || []);
        const afterChildren = Array.from(after?.childNodes || []);
        
        const maxLength = Math.max(beforeChildren.length, afterChildren.length);
        for (let i = 0; i < maxLength; i++) {
            compareNodes(beforeChildren[i], afterChildren[i]);
        }
    }

    compareNodes(beforeSnapshot, afterSnapshot);
    return changes;
}

export function expectFormReset(form) {
    // Input fields should be empty
    const inputs = form.querySelectorAll('input[type="text"], input[type="number"], select');
    inputs.forEach(input => {
        expect(input.value).toBe('');
    });

    // Checkboxes should be unchecked
    const checkboxes = form.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach(checkbox => {
        expect(checkbox.checked).toBe(false);
    });

    // Radio buttons should be in default state
    const radios = form.querySelectorAll('input[type="radio"]');
    radios.forEach(radio => {
        expect(radio.checked).toBe(radio.value === 'perHousehold');
    });

    // Submit button should be in add state
    const submitButton = form.querySelector('button[type="submit"]');
    expect(submitButton.textContent).toBe('Add Food Item');
}
</file>

<file path="packages/backend/public/js/foodItems/__tests__/utils/generateCoverage.js">
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class CoverageReportGenerator {
    constructor() {
        this.coverageData = null;
        this.template = '';
        this.outputPath = path.join(__dirname, '..', 'coverage-report.md');
        this.templatePath = path.join(__dirname, '..', 'coverage-template.md');
    }

    async generate() {
        try {
            // Run tests with coverage
            console.log('Running tests with coverage...');
            execSync('npm run test:fooditems:coverage', { stdio: 'inherit' });

            // Read coverage data
            console.log('Reading coverage data...');
            const coverageJson = fs.readFileSync(
                path.join(__dirname, '..', 'coverage', 'coverage-final.json'),
                'utf8'
            );
            this.coverageData = JSON.parse(coverageJson);

            // Read template
            console.log('Reading template...');
            this.template = fs.readFileSync(this.templatePath, 'utf8');

            // Generate report
            console.log('Generating report...');
            const report = this.generateReport();

            // Write report
            console.log('Writing report...');
            fs.writeFileSync(this.outputPath, report);

            console.log(`Coverage report generated at ${this.outputPath}`);
            return true;
        } catch (error) {
            console.error('Error generating coverage report:', error);
            return false;
        }
    }

    generateReport() {
        let report = this.template;

        // Replace date placeholders
        const now = new Date();
        report = report.replace('{DATE}', now.toLocaleDateString());
        report = report.replace('{TIMESTAMP}', now.toISOString());

        // Calculate and replace coverage metrics
        const components = {
            handlers: {
                'submit.js': 'SUBMIT',
                'validation.js': 'VAL',
                'formData.js': 'FORM'
            },
            ui: {
                'forms.js': 'UI_FORMS',
                'table.js': 'UI_TABLE',
                'stats.js': 'UI_STATS'
            },
            manager: {
                'FoodItemManager.js': 'MGR'
            }
        };

        // Replace component coverage
        for (const [category, files] of Object.entries(components)) {
            for (const [file, prefix] of Object.entries(files)) {
                const coverage = this.getComponentCoverage(category, file);
                report = this.replaceCoverageMetrics(report, prefix, coverage);
            }
        }

        // Calculate total coverage
        const totalCoverage = this.calculateTotalCoverage();
        report = report.replace('{COVERAGE_PERCENTAGE}', totalCoverage.toFixed(2));

        return report;
    }

    getComponentCoverage(category, filename) {
        const filePath = path.join('public/js/foodItems', category, filename);
        const fileData = this.coverageData[filePath];

        if (!fileData) {
            return {
                statements: 0,
                branches: 0,
                functions: 0,
                lines: 0,
                uncovered: []
            };
        }

        const uncoveredLines = Object.entries(fileData.statementMap)
            .filter(([key]) => !fileData.s[key])
            .map(([_, loc]) => loc.start.line);

        return {
            statements: this.calculatePercentage(fileData.s),
            branches: this.calculatePercentage(fileData.b),
            functions: this.calculatePercentage(fileData.f),
            lines: this.calculatePercentage(fileData.l),
            uncovered: uncoveredLines.join(', ')
        };
    }

    replaceCoverageMetrics(report, prefix, coverage) {
        return report
            .replace(`{${prefix}_STMT}`, coverage.statements.toFixed(2))
            .replace(`{${prefix}_BRANCH}`, coverage.branches.toFixed(2))
            .replace(`{${prefix}_FUNC}`, coverage.functions.toFixed(2))
            .replace(`{${prefix}_LINES}`, coverage.lines.toFixed(2))
            .replace(`{${prefix}_UNCOVERED}`, coverage.uncovered);
    }

    calculatePercentage(data) {
        if (typeof data === 'object') {
            const covered = Object.values(data).filter(v => v > 0).length;
            const total = Object.values(data).length;
            return (covered / total) * 100 || 0;
        }
        return 0;
    }

    calculateTotalCoverage() {
        let totalStatements = 0;
        let coveredStatements = 0;

        Object.values(this.coverageData).forEach(file => {
            Object.values(file.s).forEach(covered => {
                totalStatements++;
                if (covered > 0) coveredStatements++;
            });
        });

        return (coveredStatements / totalStatements) * 100 || 0;
    }
}

// Run if called directly
if (require.main === module) {
    const generator = new CoverageReportGenerator();
    generator.generate();
}

module.exports = CoverageReportGenerator;
</file>

<file path="packages/backend/public/js/foodItems/__tests__/utils/testFactories.js">
/**
 * Test data factories for Food Item related tests
 */

export function createMockFoodItem({
    id = 1,
    name = 'Test Item',
    categoryId = 1,
    itemLimit = 5,
    limitType = 'perHousehold',
    inStock = true,
    ...overrides
} = {}) {
    return {
        id,
        name,
        categoryId,
        category: { id: categoryId, name: 'Test Category' },
        itemLimit,
        limitType,
        inStock,
        mustGo: false,
        lowSupply: false,
        readyToEat: false,
        kosher: false,
        halal: false,
        vegetarian: false,
        vegan: false,
        glutenFree: false,
        organic: false,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        ...overrides
    };
}

export function createMockManager({
    settingsManager = createMockSettingsManager(),
    ...overrides
} = {}) {
    // Set up basic DOM structure needed for manager
    document.body.innerHTML = `
        <form id="foodItemForm">
            <button type="submit">Submit</button>
        </form>
        <div id="foodItemTableBody"></div>
        <select id="itemLimitSelect"></select>
        <button id="resetFoodItemForm">Reset</button>
        <select id="foodItemCategory"></select>
        <input id="foodItemName" />
        <div id="foodItemStats"></div>
        <div id="foodItemId"></div>
    `;

    return {
        form: document.getElementById('foodItemForm'),
        tableBody: document.getElementById('foodItemTableBody'),
        itemLimitSelect: document.getElementById('itemLimitSelect'),
        resetButton: document.getElementById('resetFoodItemForm'),
        categorySelect: document.getElementById('foodItemCategory'),
        nameInput: document.getElementById('foodItemName'),
        foodItemStats: document.getElementById('foodItemStats'),
        settingsManager,
        sortableTable: createMockSortableTable(),
        lastUpdated: new Date(),
        ...overrides
    };
}

export function createMockSettingsManager({
    currentLimit = 10,
    ...overrides
} = {}) {
    return {
        getCurrentLimit: jest.fn().mockReturnValue(currentLimit),
        ...overrides
    };
}

export function createMockSortableTable({
    ...overrides
} = {}) {
    return {
        setupSortingControls: jest.fn(),
        getColumnIndex: jest.fn(key => {
            const indices = {
                name: 0,
                category: 1,
                status: 2,
                dietary: 3,
                limit: 4,
                created: 5
            };
            return indices[key] || -1;
        }),
        ...overrides
    };
}

export function createMockEvent({
    type = 'click',
    preventDefault = jest.fn(),
    target = {},
    ...overrides
} = {}) {
    return {
        type,
        preventDefault,
        target,
        ...overrides
    };
}

export function createMockApiResponse({
    success = true,
    data = null,
    message = '',
    status = 200,
    ...overrides
} = {}) {
    return {
        success,
        data,
        message,
        status,
        ...overrides
    };
}

export async function createTestEnvironment({
    itemCount = 3,
    withCategories = true,
    withSettings = true
} = {}) {
    // Create test items
    const items = Array.from({ length: itemCount }, (_, index) => 
        createMockFoodItem({ id: index + 1, name: `Test Item ${index + 1}` }));

    // Create test categories if requested
    const categories = withCategories ? [
        { id: 1, name: 'Category 1', itemLimit: 5 },
        { id: 2, name: 'Category 2', itemLimit: 0 }
    ] : [];

    // Create test settings if requested
    const settings = withSettings ? {
        globalUpperLimit: 10,
        updatedAt: new Date().toISOString()
    } : null;

    return {
        items,
        categories,
        settings,
        cleanup: () => {
            document.body.innerHTML = '';
            jest.clearAllMocks();
        }
    };
}
</file>

<file path="packages/backend/public/js/foodItems/__tests__/utils/testHelpers.js">
/**
 * Test helper utilities for Food Item tests
 */

export async function waitForDomUpdate(timeout = 0) {
    return new Promise(resolve => setTimeout(resolve, timeout));
}

export function simulateUserInput(element, value) {
    element.value = value;
    element.dispatchEvent(new Event('input', { bubbles: true }));
}

export function simulateFormSubmit(form) {
    form.dispatchEvent(new Event('submit', { bubbles: true, cancelable: true }));
}

export function createDomElement(type, attributes = {}, children = []) {
    const element = document.createElement(type);
    Object.entries(attributes).forEach(([key, value]) => {
        if (key === 'className') {
            element.className = value;
        } else if (key === 'dataset') {
            Object.entries(value).forEach(([dataKey, dataValue]) => {
                element.dataset[dataKey] = dataValue;
            });
        } else {
            element.setAttribute(key, value);
        }
    });
    children.forEach(child => {
        if (typeof child === 'string') {
            element.appendChild(document.createTextNode(child));
        } else {
            element.appendChild(child);
        }
    });
    return element;
}

export function findByTestId(container, testId) {
    return container.querySelector(`[data-testid="${testId}"]`);
}

export function queryAllByClass(container, className) {
    return Array.from(container.getElementsByClassName(className));
}

export function mockApiCall(mockFn, response, delay = 0) {
    return mockFn.mockImplementation(() => 
        new Promise(resolve => 
            setTimeout(() => resolve(response), delay)
        )
    );
}

export function createMockFormData({
    name = 'Test Item',
    categoryId = '1',
    itemLimit = '5',
    limitType = 'perHousehold',
    flags = {}
} = {}) {
    return {
        name,
        categoryId: parseInt(categoryId),
        itemLimit: parseInt(itemLimit),
        limitType,
        inStock: flags.inStock ?? false,
        mustGo: flags.mustGo ?? false,
        lowSupply: flags.lowSupply ?? false,
        readyToEat: flags.readyToEat ?? false,
        kosher: flags.kosher ?? false,
        halal: flags.halal ?? false,
        vegetarian: flags.vegetarian ?? false,
        vegan: flags.vegan ?? false,
        glutenFree: flags.glutenFree ?? false,
        organic: flags.organic ?? false
    };
}

export function verifyFormReset(form) {
    // Verify form element states
    expect(form.reset).toHaveBeenCalled();
    expect(document.getElementById('foodItemId').value).toBe('');
    expect(document.getElementById('limitTypeContainer').style.display).toBe('none');
    expect(form.querySelector('button[type="submit"]').textContent).toBe('Add Food Item');
}

export function expectValidationError(message) {
    return {
        asymmetricMatch: actual => {
            return actual.message === message && 
                   actual.type === 'validation' &&
                   actual.field !== undefined;
        },
        toString: () => `ValidationError(${message})`
    };
}

export function createTestTable() {
    const table = document.createElement('table');
    const tbody = document.createElement('tbody');
    table.appendChild(tbody);
    return { table, tbody };
}

/**
 * Verifies that DOM manipulation was performed efficiently
 * @param {Function} callback - Function that performs DOM manipulation
 * @returns {Promise<number>} - Number of reflows triggered
 */
export async function measureDomPerformance(callback) {
    const reflows = [];
    const originalOffsetHeight = Object.getOwnPropertyDescriptor(
        HTMLElement.prototype,
        'offsetHeight'
    );

    Object.defineProperty(HTMLElement.prototype, 'offsetHeight', {
        get() {
            reflows.push(new Error().stack);
            return 0;
        },
    });

    await callback();

    Object.defineProperty(
        HTMLElement.prototype,
        'offsetHeight',
        originalOffsetHeight
    );

    return reflows.length;
}

export function createTestContext() {
    return {
        errors: [],
        warnings: [],
        logs: [],
        clear() {
            this.errors = [];
            this.warnings = [];
            this.logs = [];
        },
        captureConsole() {
            const originalError = console.error;
            const originalWarn = console.warn;
            const originalLog = console.log;

            console.error = (...args) => this.errors.push(args);
            console.warn = (...args) => this.warnings.push(args);
            console.log = (...args) => this.logs.push(args);

            return () => {
                console.error = originalError;
                console.warn = originalWarn;
                console.log = originalLog;
            };
        }
    };
}
</file>

<file path="packages/backend/public/js/foodItems/__tests__/babel.config.js">
module.exports = {
    presets: [
        [
            '@babel/preset-env',
            {
                targets: {
                    node: 'current',
                },
            },
        ],
    ],
    env: {
        test: {
            plugins: ['@babel/plugin-transform-modules-commonjs']
        }
    }
};
</file>

<file path="packages/backend/public/js/foodItems/__tests__/FoodItemManager.test.js">
import { FoodItemManager } from '../FoodItemManager.js';
import { showMessage } from '../../utils.js';
import { SortableTable } from '../../utils/sortableTable.js';
import { handleSubmit } from '../handlers/submit.js';
import { handleNameInput } from '../handlers/validation.js';

jest.mock('../../utils.js');
jest.mock('../../utils/sortableTable.js');
jest.mock('../handlers/submit.js');
jest.mock('../handlers/validation.js');

describe('FoodItemManager', () => {
    let manager;
    let mockSettingsManager;

    beforeEach(() => {
        // Setup DOM
        document.body.innerHTML = `
            <form id="foodItemForm">
                <div class="input-section">
                    <input type="text" id="foodItemName" name="foodItemName" value="Test Item">
                    <select id="foodItemCategory"></select>
                    <select id="itemLimitSelect"></select>
                    <input type="hidden" id="foodItemId" value="">
                    <button id="resetFoodItemForm" type="button">Reset</button>
                    <button type="submit">Add Food Item</button>
                </div>
                <div id="limitTypeContainer" style="display: none;">
                    <input type="radio" name="limitType" value="perHousehold" id="perHousehold" checked>
                    <label for="perHousehold">Per Household</label>
                    <input type="radio" name="limitType" value="perPerson" id="perPerson">
                    <label for="perPerson">Per Person</label>
                </div>
                <div class="status-section"></div>
                <div class="dietary-section"></div>
            </form>
            <div id="foodItemTableBody"></div>
            <div id="foodItemStats"></div>
        `;

        // Mock settings manager
        mockSettingsManager = {
            getCurrentLimit: jest.fn().mockReturnValue(10)
        };

        // Mock handlers
        handleSubmit.mockImplementation(e => e.preventDefault());
        handleNameInput.mockReturnValue('Test Item');

        // Create manager instance
        manager = new FoodItemManager(mockSettingsManager);

        // Reset mocks
        showMessage.mockReset();
        SortableTable.mockClear();
        handleSubmit.mockClear();
        handleNameInput.mockClear();
    });

    afterEach(() => {
        document.body.innerHTML = '';
        jest.clearAllMocks();
    });

    describe('Initialization', () => {
        it('should initialize with correct DOM elements', () => {
            expect(manager.form).toBeTruthy();
            expect(manager.tableBody).toBeTruthy();
            expect(manager.itemLimitSelect).toBeTruthy();
            expect(manager.resetButton).toBeTruthy();
            expect(manager.categorySelect).toBeTruthy();
            expect(manager.nameInput).toBeTruthy();
            expect(manager.foodItemStats).toBeTruthy();
        });

        it('should initialize item limit dropdown', () => {
            expect(manager.itemLimitSelect.children.length).toBe(11); // 0-10
            const firstOption = manager.itemLimitSelect.children[0];
            expect(firstOption.value).toBe('0');
            expect(firstOption.textContent).toBe('No Limit');
        });

        it('should set up initial event listeners', () => {
            // Test form submission
            const submitEvent = new Event('submit', { bubbles: true, cancelable: true });
            manager.form.dispatchEvent(submitEvent);
            expect(handleSubmit).toHaveBeenCalledWith(submitEvent, manager);
            expect(submitEvent.defaultPrevented).toBe(true);

            // Test input handling
            const inputEvent = new Event('input');
            manager.nameInput.dispatchEvent(inputEvent);
            expect(handleNameInput).toHaveBeenCalled();

            // Test reset button
            const resetEvent = new Event('click');
            const originalValue = manager.itemLimitSelect.value;
            manager.itemLimitSelect.value = '5';
            manager.resetButton.dispatchEvent(resetEvent);
            expect(manager.itemLimitSelect.value).toBe('0');

            // Test limit type container visibility
            const changeEvent = new Event('change');
            manager.itemLimitSelect.value = '5';
            manager.itemLimitSelect.dispatchEvent(changeEvent);
            const limitContainer = document.getElementById('limitTypeContainer');
            expect(limitContainer.style.display).toBe('block');
        });
    });

    // Rest of test cases remain the same...
});
</file>

<file path="packages/backend/public/js/foodItems/__tests__/jest.config.js">
module.exports = {
  // Test environment
  testEnvironment: 'jsdom',
  
  // Test file patterns
  testMatch: [
    '**/foodItems/__tests__/**/*.test.js'
  ],

  // Module file extensions
  moduleFileExtensions: ['js', 'json'],

  // Module name mapper for imports
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1'
  },

  // Coverage configuration
  collectCoverage: true,
  coverageDirectory: '<rootDir>/coverage',
  coverageReporters: ['text', 'lcov', 'clover'],
  collectCoverageFrom: [
    '**/foodItems/**/*.js',
    '!**/foodItems/__tests__/**',
    '!**/node_modules/**'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },

  // Test setup file
  setupFilesAfterEnv: [
    '<rootDir>/setup.js'
  ],

  // Transform configuration
  transform: {
    '^.+\\.js$': 'babel-jest'
  },

  // Mocking configuration
  clearMocks: true,
  resetMocks: true,
  restoreMocks: true,

  // Error handling
  bail: false,
  verbose: true,

  // Performance
  maxConcurrency: 5,
  maxWorkers: '50%',

  // Timeouts
  testTimeout: 5000,
  slowTestThreshold: 1000
}
</file>

<file path="packages/backend/public/js/foodItems/__tests__/setup.js">
import * as assertions from './utils/assertions';
import * as testHelpers from './utils/testHelpers';
import * as testFactories from './utils/testFactories';

// Enable fake timers
jest.useFakeTimers();

// Mock window.localStorage
const localStorageMock = {
    getItem: jest.fn(),
    setItem: jest.fn(),
    removeItem: jest.fn(),
    clear: jest.fn()
};
global.localStorage = localStorageMock;

// Mock window.fetch
global.fetch = jest.fn(() =>
    Promise.resolve({
        ok: true,
        json: () => Promise.resolve({}),
        text: () => Promise.resolve('')
    })
);

// Mock window.alert and window.confirm
global.alert = jest.fn();
global.confirm = jest.fn(() => true);

// Add custom matchers
expect.extend({
    toHaveBeenCalledOnceWith(received, ...expectedArgs) {
        const pass = received.mock.calls.length === 1 &&
            JSON.stringify(received.mock.calls[0]) === JSON.stringify(expectedArgs);
        
        return {
            pass,
            message: () => pass
                ? `Expected function not to have been called once with ${expectedArgs}`
                : `Expected function to have been called once with ${expectedArgs}`
        };
    },
    // Add our custom assertions as matchers
    toHaveValidFormState(form, options) {
        assertions.expectFormValidationState(form, options);
        return { pass: true };
    },
    toHaveValidTableStructure(tableBody) {
        assertions.expectTableStructure(tableBody);
        return { pass: true };
    },
    toHaveSortableHeaders(table) {
        assertions.expectSortableHeaders(table);
        return { pass: true };
    },
    toHaveValidStats(container, expectedStats) {
        assertions.expectValidStats(container, expectedStats);
        return { pass: true };
    }
});

// Mock ResizeObserver
global.ResizeObserver = class ResizeObserver {
    observe() {}
    unobserve() {}
    disconnect() {}
};

// Add test utilities to global scope
global.testHelpers = testHelpers;
global.testFactories = testFactories;
global.assertions = assertions;

// Add common test utilities
global.waitForDomChange = testHelpers.waitForDomUpdate;
global.createTestContext = testHelpers.createTestContext;
global.measureDomPerformance = testHelpers.measureDomPerformance;

// Add factory methods
global.createMockFoodItem = testFactories.createMockFoodItem;
global.createMockManager = testFactories.createMockManager;
global.createTestEnvironment = testFactories.createTestEnvironment;

// Cleanup after each test
afterEach(() => {
    // Clear all mocks
    jest.clearAllMocks();
    // Reset timers
    jest.runOnlyPendingTimers();
    // Clear DOM
    document.body.innerHTML = '';
    // Clear local storage
    localStorage.clear();
    // Reset fetch mock
    fetch.mockClear();
});

// Test environment configuration
beforeAll(() => {
    // Suppress console.error in tests
    jest.spyOn(console, 'error').mockImplementation(() => {});
    // Set timezone for consistent date handling
    process.env.TZ = 'UTC';
});
</file>

<file path="packages/backend/public/js/foodItems/handlers/formData.js">
export function collectFormData(manager) {
    const limitType = document.querySelector('input[name="limitType"]:checked')?.value || 'perHousehold';
    const itemLimit = parseInt(manager.itemLimitSelect.value) || 0;

    return {
        name: manager.nameInput.value.trim(),
        categoryId: parseInt(manager.categorySelect.value),
        itemLimit,
        limitType,
        ...collectStatusFlags(),
        ...collectDietaryFlags()
    };
}

function collectStatusFlags() {
    return {
        inStock: document.getElementById('foodItemInStock').checked,
        mustGo: document.getElementById('foodItemMustGo').checked,
        lowSupply: document.getElementById('foodItemLowSupply').checked,
        readyToEat: document.getElementById('foodItemReadyToEat').checked
    };
}

function collectDietaryFlags() {
    return {
        kosher: document.getElementById('foodItemKosher').checked,
        halal: document.getElementById('foodItemHalal').checked,
        vegetarian: document.getElementById('foodItemVegetarian').checked,
        vegan: document.getElementById('foodItemVegan').checked,
        glutenFree: document.getElementById('foodItemGlutenFree').checked,
        organic: document.getElementById('foodItemOrganic').checked
    };
}
</file>

<file path="packages/backend/public/js/foodItems/handlers/submit.js">
import { showMessage } from '../../utils.js';
import { validateName } from './validation.js';
import { collectFormData } from './formData.js';

export async function handleSubmit(e, manager) {
    e.preventDefault();
    const name = manager.nameInput.value.trim();
    
    try {
        // Validation
        if (!validateName(name)) {
            showMessage('Invalid item name', 'error', 'foodItem');
            return;
        }

        // Data Collection
        const data = collectFormData(manager);
        
        if (data.categoryId === '') {
            showMessage('Please select a category', 'error', 'foodItem');
            return;
        }

        // Save Data
        const id = document.getElementById('foodItemId').value;
        const result = await (id ? 
            manager.updateItem(id, data) : 
            manager.createItem(data));

        if (result) {
            const action = id ? 'updated' : 'created';
            showMessage(`Food item ${action} successfully`, 'success', 'foodItem');
            manager.resetForm();
            await manager.loadFoodItems();
        }
    } catch (error) {
        showMessage(error.message || 'An error occurred', 'error', 'foodItem');
    }
}
</file>

<file path="packages/backend/public/js/foodItems/handlers/validation.js">
import { showMessage } from '../../utils.js';

export const VALIDATION_RULES = {
    NAME: {
        MIN_LENGTH: 3,
        MAX_LENGTH: 36,
        MIN_LETTERS: 3,
    }
};

export function validateName(name) {
    if (name.length < VALIDATION_RULES.NAME.MIN_LENGTH) {
        showMessage('Food item name must be at least three characters long', 'error', 'foodItem');
        return false;
    }

    const letterCount = (name.match(/[a-zA-Z]/g) || []).length;
    if (letterCount < VALIDATION_RULES.NAME.MIN_LETTERS) {
        showMessage('Food item name must include at least three letters', 'error', 'foodItem');
        return false;
    }

    const words = name.toLowerCase().split(' ');
    const uniqueWords = new Set(words);
    if (uniqueWords.size !== words.length) {
        showMessage('Food item name contains repeated words', 'error', 'foodItem');
        return false;
    }

    return true;
}

export function handleNameInput(input) {
    let value = input.value;

    if (value.length > VALIDATION_RULES.NAME.MAX_LENGTH) {
        value = value.slice(0, VALIDATION_RULES.NAME.MAX_LENGTH);
        showMessage('Input cannot exceed 36 characters', 'warning', 'foodItem');
    }

    if (/\s{2,}/.test(value)) {
        value = value.replace(/\s{2,}/g, ' ');
    }

    const words = value.toLowerCase().split(' ');
    const uniqueWords = new Set(words);
    if (uniqueWords.size !== words.length) {
        showMessage('Input contains repeated words', 'warning', 'foodItem');
    }

    return value
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
}
</file>

<file path="packages/backend/public/js/foodItems/ui/forms.js">
export function createFormLayout(manager) {
    // Clear the form completely
    const form = manager.form;
    while (form.firstChild) {
        form.removeChild(form.firstChild);
    }

    // Create form sections
    const formSections = ['input', 'status', 'dietary'];
    formSections.forEach(section => {
        const container = document.createElement('div');
        container.className = `form-section ${section}-section`;
        form.appendChild(container);
    });

    // Hidden ID field
    const hiddenId = document.createElement('input');
    hiddenId.type = 'hidden';
    hiddenId.id = 'foodItemId';
    form.appendChild(hiddenId);

    // Create input section elements
    const inputSection = form.querySelector('.input-section');
    [
        createFormGroup('Item Name:', manager.nameInput),
        createFormGroup('Category:', manager.categorySelect),
        createFormGroup('Item Limit:', manager.itemLimitSelect),
        createLimitTypeGroup()
    ].forEach(el => inputSection.appendChild(el));

    // Create status flags
    const statusSection = form.querySelector('.status-section');
    const statusFlags = createStatusFlagsGroup();
    statusSection.appendChild(statusFlags);

    // Create dietary flags
    const dietarySection = form.querySelector('.dietary-section');
    const dietaryFlags = createDietaryFlagsGroup();
    dietarySection.appendChild(dietaryFlags);

    // Submit button
    const submitButton = document.createElement('button');
    submitButton.type = 'submit';
    submitButton.textContent = 'Add Food Item';
    submitButton.className = 'submit-button';
    form.appendChild(submitButton);
}

function createFormGroup(label, element) {
    const group = document.createElement('div');
    group.className = 'form__group';
    
    const labelEl = document.createElement('label');
    labelEl.textContent = label;
    labelEl.className = 'required';
    labelEl.htmlFor = element.id;
    
    // Clone the element to avoid moving it if it exists
    const elementClone = element.cloneNode(true);
    
    group.appendChild(labelEl);
    group.appendChild(elementClone);
    return group;
}

function createLimitTypeGroup() {
    const container = document.createElement('div');
    container.id = 'limitTypeContainer';
    container.style.display = 'none';
    container.className = 'limit-type-group';

    const options = [
        { value: 'perHousehold', label: 'Per Household', defaultChecked: true },
        { value: 'perPerson', label: 'Per Person', defaultChecked: false }
    ];

    options.forEach(option => {
        const input = document.createElement('input');
        input.type = 'radio';
        input.name = 'limitType';
        input.value = option.value;
        input.id = option.value;
        input.checked = option.defaultChecked;

        const label = document.createElement('label');
        label.htmlFor = option.value;
        label.textContent = option.label;

        container.appendChild(input);
        container.appendChild(label);
    });

    return container;
}

function createFlagGroupContainer(title) {
    const container = document.createElement('div');
    
    // Use exact class names for status and dietary flags
    if (title === 'Status Flags') {
        container.className = 'status-flags-group';
    } else if (title === 'Dietary Flags') {
        container.className = 'dietary-flags-group';
    }

    const heading = document.createElement('h3');
    heading.textContent = title;
    container.appendChild(heading);

    const grid = document.createElement('div');
    grid.className = 'flags-grid';
    container.appendChild(grid);

    return { container, grid };
}

function createFlagToggle(flag) {
    const toggle = document.createElement('div');
    toggle.className = 'flag-toggle';

    const label = document.createElement('label');
    label.htmlFor = flag.id;

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = flag.id;
    checkbox.name = flag.id;

    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(flag.label));
    toggle.appendChild(label);

    return toggle;
}

function createFlagsGroup(title, flags) {
    const { container, grid } = createFlagGroupContainer(title);
    flags.forEach(flag => {
        const toggle = createFlagToggle(flag);
        grid.appendChild(toggle);
    });
    return container;
}

function createStatusFlagsGroup() {
    const flags = [
        { id: 'foodItemInStock', label: 'In Stock' },
        { id: 'foodItemMustGo', label: 'Must Go' },
        { id: 'foodItemLowSupply', label: 'Low Supply' },
        { id: 'foodItemReadyToEat', label: 'Ready to Eat' }
    ];
    return createFlagsGroup('Status Flags', flags);
}

function createDietaryFlagsGroup() {
    const flags = [
        { id: 'foodItemKosher', label: 'Kosher' },
        { id: 'foodItemHalal', label: 'Halal' },
        { id: 'foodItemVegetarian', label: 'Vegetarian' },
        { id: 'foodItemVegan', label: 'Vegan' },
        { id: 'foodItemGlutenFree', label: 'Gluten Free' },
        { id: 'foodItemOrganic', label: 'Organic' }
    ];
    return createFlagsGroup('Dietary Flags', flags);
}
</file>

<file path="packages/backend/public/js/foodItems/ui/stats.js">
export function updateStats(foodItems, manager) {
    if (!manager.foodItemStats) return;

    const stats = calculateStats(foodItems);
    const lastUpdatedStr = manager.lastUpdated ? 
        `Last Updated: ${manager.lastUpdated.toLocaleString()}` : '';

    manager.foodItemStats.innerHTML = `
        <div class="stats">
            <span>Total Items: ${stats.total}</span>
            <span>In Stock: ${stats.inStock}</span>
            <span>Out of Stock: ${stats.outOfStock}</span>
            <span>Limited: ${stats.limited}</span>
            <span>Unlimited: ${stats.unlimited}</span>
            <span>${lastUpdatedStr}</span>
        </div>
    `;
}

function calculateStats(foodItems) {
    const total = foodItems.length;
    const inStock = foodItems.filter(item => item.inStock).length;
    
    return {
        total,
        inStock,
        outOfStock: total - inStock,
        limited: foodItems.filter(item => item.itemLimit > 0).length,
        unlimited: foodItems.filter(item => !item.itemLimit).length
    };
}
</file>

<file path="packages/backend/public/js/foodItems/ui/table.js">
export function createFoodItemRow(item, manager) {
    const status = formatStatus(item);
    const dietary = formatDietary(item);
    const limitDisplay = formatLimit(item);
    const itemData = prepareItemData(item);

    return `
        <tr>
            <td class="table__cell">${item.name}</td>
            <td class="table__cell">${item.category?.name || 'Unknown'}</td>
            <td class="table__cell">${status || 'None'}</td>
            <td class="table__cell">${dietary || 'None'}</td>
            <td class="table__cell">${limitDisplay}</td>
            <td class="table__cell">${new Date(item.createdAt).toLocaleDateString()}</td>
            <td class="table__cell">
                <button class="edit-food-item-btn" data-item='${JSON.stringify(itemData)}'>
                    Edit
                </button>
                <button class="delete-food-item-btn" data-id="${item.id}">
                    Delete
                </button>
            </td>
        </tr>
    `;
}

function formatStatus(item) {
    return [
        item.inStock ? 'In Stock' : 'Out of Stock',
        item.mustGo ? 'Must Go' : '',
        item.lowSupply ? 'Low Supply' : '',
        item.readyToEat ? 'Ready to Eat' : ''
    ].filter(Boolean).join(', ');
}

function formatDietary(item) {
    return [
        item.kosher ? 'Kosher' : '',
        item.halal ? 'Halal' : '',
        item.vegetarian ? 'Vegetarian' : '',
        item.vegan ? 'Vegan' : '',
        item.glutenFree ? 'GF' : '',
        item.organic ? 'Organic' : ''
    ].filter(Boolean).join(', ');
}

function formatLimit(item) {
    if (item.itemLimit === 0) {
        return 'No Limit';
    }
    const limitType = item.limitType === 'perPerson' ? 'Per Person' : 'Per Household';
    return `${item.itemLimit} ${limitType}`;
}

function prepareItemData(item) {
    return {
        id: item.id,
        name: item.name,
        categoryId: item.category?.id,
        itemLimit: item.itemLimit,
        limitType: item.limitType,
        inStock: item.inStock,
        mustGo: item.mustGo,
        lowSupply: item.lowSupply,
        kosher: item.kosher,
        halal: item.halal,
        vegetarian: item.vegetarian,
        vegan: item.vegan,
        glutenFree: item.glutenFree,
        organic: item.organic,
        readyToEat: item.readyToEat
    };
}

export function displayFoodItems(foodItems, manager) {
    if (!Array.isArray(foodItems) || foodItems.length === 0) {
        manager.tableBody.innerHTML = '<tr><td colspan="7" class="table__cell--empty">No food items found</td></tr>';
        return;
    }

    manager.tableBody.innerHTML = foodItems
        .map(item => createFoodItemRow(item, manager))
        .join('');

    manager.sortableTable.setupSortingControls();
}
</file>

<file path="packages/backend/public/js/foodItems/utils/errorHandler.js">
import { showMessage } from '../../utils.js';

export function handleError(error, context) {
    const message = error.message || 'An error occurred';
    showMessage(`${context}: ${message}`, 'error', 'foodItem');
    console.error(`Food Items Error (${context}):`, error);
    return false;
}

export function handleSuccess(message) {
    showMessage(message, 'success', 'foodItem');
    return true;
}
</file>

<file path="packages/backend/public/js/foodItems/FoodItemManager.js">
import { showMessage, apiGet, apiPost, apiPut, apiDelete } from '../utils.js';
import { managers } from '../main.js';
import { SortableTable } from '../utils/sortableTable.js';
import { handleSubmit } from './handlers/submit.js';
import { handleNameInput } from './handlers/validation.js';
import { createFormLayout } from './ui/forms.js';
import { displayFoodItems } from './ui/table.js';
import { updateStats } from './ui/stats.js';

export class FoodItemManager {
    constructor(settingsManager) {
        this.settingsManager = settingsManager;
        this.form = document.getElementById('foodItemForm');
        this.tableBody = document.getElementById('foodItemTableBody');
        this.itemLimitSelect = document.getElementById('itemLimitSelect');
        this.resetButton = document.getElementById('resetFoodItemForm');
        this.categorySelect = document.getElementById('foodItemCategory');
        this.nameInput = document.getElementById('foodItemName');
        this.foodItemStats = document.getElementById('foodItemStats');
        this.sortableTable = new SortableTable('foodItemTableBody', this.getSortValue.bind(this));
        this.lastUpdated = null;

        this.initializeFormLayout();
        this.setupEventListeners();
        this.initializeItemLimitDropdown();
        this.init();
    }

    async init() {
        await this.loadCategories();
        if (this.categorySelect.options.length === 0) {
            this.displayNoCategories();
        }
    }

    initializeFormLayout() {
        createFormLayout(this);
    }

    setupEventListeners() {
        this.form.addEventListener('submit', (e) => handleSubmit(e, this));
        this.resetButton.addEventListener('click', () => this.resetForm());
        this.nameInput.addEventListener('input', (e) => {
            this.nameInput.value = handleNameInput(this.nameInput);
        });
        this.addTableEventListeners();
        
        this.itemLimitSelect.addEventListener('change', () => {
            const limitTypeContainer = document.getElementById('limitTypeContainer');
            limitTypeContainer.style.display = this.itemLimitSelect.value === '0' ? 'none' : 'block';
        });
    }

    initializeItemLimitDropdown() {
        if (!this.itemLimitSelect) return;
        const globalLimit = this.settingsManager.getCurrentLimit();
        const options = ['<option value="0">No Limit</option>'];
        for (let i = 1; i <= globalLimit; i++) {
            options.push(`<option value="${i}">${i}</option>`);
        }
        this.itemLimitSelect.innerHTML = options.join('');
    }

    getSortValue(row, key) {
        const columnIndex = this.sortableTable.getColumnIndex(key);
        switch (key) {
            case 'name':
            case 'category':
                return row.cells[columnIndex].textContent.toLowerCase();
            case 'status':
            case 'dietary':
                return row.cells[columnIndex].textContent.toLowerCase();
            case 'limit':
                const limitText = row.cells[columnIndex].textContent;
                return limitText === 'No Limit' ? -1 : parseInt(limitText);
            case 'created':
                return SortableTable.dateSortValue(row, columnIndex);
            default:
                return row.cells[columnIndex].textContent.toLowerCase();
        }
    }

    addTableEventListeners() {
        this.tableBody.addEventListener('click', async (e) => {
            const target = e.target;
            if (target.classList.contains('edit-food-item-btn')) {
                this.editFoodItem(target.getAttribute('data-item'));
            } else if (target.classList.contains('delete-food-item-btn')) {
                await this.deleteFoodItem(target.dataset.id);
            }
        });
    }

    async loadCategories() {
        try {
            const data = await apiGet('/api/categories');
            this.categorySelect.innerHTML = '';
            
            if (!data.data || data.data.length === 0) {
                this.displayNoCategories();
                return;
            }

            this.form.querySelector('button[type="submit"]').disabled = false;
            
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select a category';
            this.categorySelect.appendChild(defaultOption);

            data.data.forEach(category => {
                const option = document.createElement('option');
                option.value = category.id;
                option.textContent = category.name;
                option.dataset.limit = category.itemLimit;
                this.categorySelect.appendChild(option);
            });
        } catch (error) {
            showMessage(error.message, 'error', 'foodItem');
        }
    }

    displayNoCategories() {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'Please create a category first';
        this.categorySelect.appendChild(option);
        
        this.form.querySelector('button[type="submit"]').disabled = true;
        showMessage('Please create at least one category before adding food items', 'warning', 'foodItem');
    }

    async loadFoodItems() {
        try {
            await this.loadCategories();
            const data = await apiGet('/api/food-items?includeOutOfStock=true');
            displayFoodItems(data.data, this);
            updateStats(data.data, this);
            this.lastUpdated = new Date();
            if (managers.translations) {
                await managers.translations.loadTranslations();
            }
        } catch (error) {
            showMessage(error.message, 'error', 'foodItem');
        }
    }

    async createItem(data) {
        try {
            await apiPost('/api/food-items', data);
            showMessage('Food item created successfully', 'success', 'foodItem');
            return true;
        } catch (error) {
            showMessage(error.message || 'An error occurred', 'error', 'foodItem');
            return false;
        }
    }

    async updateItem(id, data) {
        try {
            await apiPut(`/api/food-items/${id}`, data);
            showMessage('Food item updated successfully', 'success', 'foodItem');
            return true;
        } catch (error) {
            showMessage(error.message || 'An error occurred', 'error', 'foodItem');
            return false;
        }
    }

    async deleteFoodItem(id) {
        if (!confirm('Are you sure you want to delete this food item?')) return;
        
        try {
            await apiDelete(`/api/food-items/${id}`);
            showMessage('Food item deleted successfully', 'success', 'foodItem');
            await this.loadFoodItems();
        } catch (error) {
            showMessage(error.message, 'error', 'foodItem');
        }
    }

    editFoodItem(itemData) {
        const data = typeof itemData === 'string' ? JSON.parse(itemData) : itemData;
        this.populateForm(data);
        this.form.querySelector('button[type="submit"]').textContent = 'Update Food Item';
    }

    populateForm(data) {
        document.getElementById('foodItemId').value = data.id;
        this.nameInput.value = data.name;
        this.categorySelect.value = data.categoryId;
        Object.keys(data).forEach(key => {
            const element = document.getElementById(`foodItem${key.charAt(0).toUpperCase() + key.slice(1)}`);
            if (element && element.type === 'checkbox') {
                element.checked = data[key];
            }
        });

        const limitTypeInputs = document.querySelectorAll('input[name="limitType"]');
        limitTypeInputs.forEach(r => {
            r.checked = (r.value === data.limitType);
        });

        this.itemLimitSelect.value = data.itemLimit;

        const limitTypeContainer = document.getElementById('limitTypeContainer');
        limitTypeContainer.style.display = data.itemLimit === 0 ? 'none' : 'block';
    }

    resetForm() {
        this.form.reset();
        document.getElementById('foodItemId').value = '';
        this.itemLimitSelect.value = '0';
        const limitTypeContainer = document.getElementById('limitTypeContainer');
        limitTypeContainer.style.display = 'none';
        this.form.querySelector('button[type="submit"]').textContent = 'Add Food Item';
    }
}
</file>

<file path="packages/backend/public/js/foodItems/index.js">
// foodItems/index.js - Main module exports
import { FoodItemManager } from './FoodItemManager.js';
export { FoodItemManager };
</file>

<file path="packages/backend/public/js/utils/sortableTable.js">
export class SortableTable {
    constructor(tableBodyId, getSortValue = null) {
        this.tableBody = document.getElementById(tableBodyId);
        this.currentSort = {
            column: null,
            direction: 'asc'
        };
        this.getSortValue = getSortValue || ((a, key) => {
            const value = a.cells[this.getColumnIndex(key)].textContent;
            return isNaN(value) ? value.toLowerCase() : parseFloat(value);
        });
        this.clickHandlers = new Map(); // Store click handlers for cleanup
    }

    getColumnIndex(key) {
        const headers = this.tableBody.closest('table').querySelectorAll('th');
        for (let i = 0; i < headers.length; i++) {
            if (headers[i].getAttribute('data-sort') === key) {
                return i;
            }
        }
        return -1;
    }

    cleanupSortingControls() {
        const table = this.tableBody.closest('table');
        const headers = table.querySelectorAll('th[data-sort]');
        
        headers.forEach(header => {
            // Remove old indicator if exists
            const oldIndicator = header.querySelector('.sort-indicator');
            if (oldIndicator) {
                oldIndicator.remove();
            }
            
            // Remove old click handler if exists
            const oldHandler = this.clickHandlers.get(header);
            if (oldHandler) {
                header.removeEventListener('click', oldHandler);
            }
        });
        
        // Clear stored handlers
        this.clickHandlers.clear();
    }

    setupSortingControls() {
        // Clean up any existing controls first
        this.cleanupSortingControls();
        
        const table = this.tableBody.closest('table');
        const headers = table.querySelectorAll('th[data-sort]');
        
        headers.forEach(header => {
            // Add sort direction indicator
            const sortKey = header.getAttribute('data-sort');
            const indicator = document.createElement('span');
            indicator.className = 'sort-indicator';
            indicator.textContent = ' ↕';
            header.appendChild(indicator);
            
            // Create and store click handler
            const clickHandler = () => {
                headers.forEach(h => {
                    if (h !== header) {
                        const otherIndicator = h.querySelector('.sort-indicator');
                        if (otherIndicator) {
                            otherIndicator.textContent = ' ↕';
                        }
                        h.classList.remove('active');
                    }
                });
                
                if (this.currentSort.column === sortKey) {
                    this.currentSort.direction = this.currentSort.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    this.currentSort.column = sortKey;
                    this.currentSort.direction = 'asc';
                }
                
                indicator.textContent = this.currentSort.direction === 'asc' ? ' ↑' : ' ↓';
                header.classList.add('active');
                this.sortTable();
            };
            
            this.clickHandlers.set(header, clickHandler);
            header.addEventListener('click', clickHandler);
        });
    }

    sortTable(data = null) {
        if (!this.currentSort.column) return;

        const rows = data ? data : Array.from(this.tableBody.rows);
        const sortedRows = rows.sort((a, b) => {
            const aVal = this.getSortValue(a, this.currentSort.column);
            const bVal = this.getSortValue(b, this.currentSort.column);
            
            if (aVal === bVal) return 0;
            
            const comparison = aVal < bVal ? -1 : 1;
            return this.currentSort.direction === 'asc' ? comparison : -comparison;
        });

        // Clear table body
        while (this.tableBody.firstChild) {
            this.tableBody.removeChild(this.tableBody.firstChild);
        }

        // Append sorted rows
        sortedRows.forEach(row => this.tableBody.appendChild(row));
    }

    // Custom sort value getters for specific data types
    static dateSortValue(row, columnIndex) {
        return new Date(row.cells[columnIndex].textContent).getTime();
    }

    static numberSortValue(row, columnIndex) {
        const text = row.cells[columnIndex].textContent;
        return text === 'No Limit' ? Infinity : parseFloat(text);
    }

    static booleanSortValue(row, columnIndex) {
        return row.cells[columnIndex].textContent.toLowerCase() === 'true';
    }
}
</file>

<file path="packages/backend/public/js/categories.js">
import { showMessage, apiGet, apiPost, apiPut, apiDelete } from './utils.js';
import { managers, EVENTS } from './main.js';
import { SortableTable } from './utils/sortableTable.js';

export class CategoryManager {
    constructor() {
        this.form = document.getElementById('categoryForm');
        this.tableBody = document.getElementById('categoryTableBody');
        this.resetButton = document.getElementById('resetForm');
        this.itemLimitSelect = document.getElementById('categoryItemLimit');
        this.nameInput = document.getElementById('categoryName');
        this.categoryStats = document.getElementById('categoryStats');
        this.sortableTable = new SortableTable('categoryTableBody', this.getSortValue.bind(this));
        this.lastUpdated = null;
        this.setupEventListeners();
        this.initializeItemLimitDropdown();
    }

    setupEventListeners() {
        this.form.addEventListener('submit', this.handleSubmit.bind(this));
        this.resetButton.addEventListener('click', () => this.resetForm());
        this.nameInput.addEventListener('input', this.handleNameInput.bind(this));
        this.addTableEventListeners();
    }

    initializeItemLimitDropdown() {
        if (!this.itemLimitSelect) return;

        const globalLimit = managers.settings.getCurrentLimit();
        let options = ['<option value="0">No Limit</option>'];
        
        for (let i = 1; i <= globalLimit; i++) {
            options.push(`<option value="${i}">${i}</option>`);
        }
        
        this.itemLimitSelect.innerHTML = options.join('');
    }

    getSortValue(row, key) {
        const columnIndex = this.sortableTable.getColumnIndex(key);
        switch (key) {
            case 'name':
                return row.cells[columnIndex].textContent.toLowerCase();
            case 'limit':
                const limitText = row.cells[columnIndex].textContent;
                return limitText === 'No Limit' ? -1 : parseInt(limitText);
            case 'created':
                return SortableTable.dateSortValue(row, columnIndex);
            default:
                return row.cells[columnIndex].textContent.toLowerCase();
        }
    }

    handleNameInput(e) {
        const input = e.target;
        const value = input.value;

        // Client-side validation
        if (value.length > 36) {
            input.value = value.slice(0, 36);
            showMessage('Input cannot exceed 36 characters', 'warning', 'category');
            return;
        }

        // Remove consecutive spaces as they type
        if (/\s{2,}/.test(value)) {
            input.value = value.replace(/\s{2,}/g, ' ');
        }

        // Check for repeated words
        const words = value.toLowerCase().split(' ');
        const uniqueWords = new Set(words);
        if (uniqueWords.size !== words.length) {
            showMessage('Input contains repeated words', 'warning', 'category');
        }

        // Convert to Title Case as they type
        input.value = value
            .split(' ')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join(' ');
    }

    addTableEventListeners() {
        this.tableBody.addEventListener('click', (e) => {
            const target = e.target;
            if (target.classList.contains('edit-btn')) {
                this.editCategory(
                    parseInt(target.dataset.id),
                    target.dataset.name,
                    parseInt(target.dataset.limit || '0')
                );
            } else if (target.classList.contains('delete-btn')) {
                this.deleteCategory(parseInt(target.dataset.id));
            }
        });
    }

    async handleSubmit(e) {
        e.preventDefault();
        const name = this.nameInput.value.trim();
        const itemLimit = parseInt(this.itemLimitSelect.value);
        const id = document.getElementById('categoryId').value;

        // Client-side validation
        if (name.length < 3) {
            showMessage('Category name must be at least three characters long', 'error', 'category');
            return;
        }

        const letterCount = (name.match(/[a-zA-Z]/g) || []).length;
        if (letterCount < 3) {
            showMessage('Category name must include at least three letters', 'error', 'category');
            return;
        }

        // Check for repeated words
        const words = name.toLowerCase().split(' ');
        const uniqueWords = new Set(words);
        if (uniqueWords.size !== words.length) {
            showMessage('Category name contains repeated words', 'error', 'category');
            return;
        }

        try {
            const data = { name, itemLimit };
            if (id) {
                await apiPut(`/api/categories/${id}`, data);
                showMessage('Category updated successfully', 'success', 'category');
            } else {
                await apiPost('/api/categories', data);
                showMessage('Category created successfully', 'success', 'category');
            }
            this.resetForm();
            await this.loadCategories();
            
            // Dispatch event for other managers
            document.dispatchEvent(new Event(EVENTS.CATEGORY_UPDATED));
        } catch (error) {
            showMessage(error.message || 'An error occurred', 'error', 'category');
        }
    }

    async loadCategories() {
        try {
            const data = await apiGet('/api/categories');
            if (data && data.data) {
                this.displayCategories(data.data);
                this.updateStats(data.data);
                this.lastUpdated = new Date();
            }
        } catch (error) {
            showMessage(error.message || 'Error loading categories', 'error', 'category');
        }
    }

    updateStats(categories) {
        if (!this.categoryStats) return;

        const totalCategories = categories.length;
        const limitedCategories = categories.filter(cat => cat.itemLimit > 0).length;
        const unlimitedCategories = totalCategories - limitedCategories;
        const lastUpdatedStr = this.lastUpdated ? 
            `Last Updated: ${this.lastUpdated.toLocaleString()}` : '';

        this.categoryStats.innerHTML = `
            <div class="stats">
                <span>Total Categories: ${totalCategories}</span>
                <span>Limited: ${limitedCategories}</span>
                <span>Unlimited: ${unlimitedCategories}</span>
                <span>${lastUpdatedStr}</span>
            </div>
        `;
    }

    displayCategories(categories) {
        if (!Array.isArray(categories)) {
            this.tableBody.innerHTML = '<tr><td colspan="4" class="table__cell--empty">No categories available</td></tr>';
            return;
        }

        this.tableBody.innerHTML = categories.map(category => `
            <tr>
                <td class="table__cell">${category.name}</td>
                <td class="table__cell">${this.formatLimit(category.itemLimit)}</td>
                <td class="table__cell">${new Date(category.createdAt).toLocaleDateString()}</td>
                <td class="table__cell">
                    <button class="edit-btn" 
                            data-id="${category.id}" 
                            data-name="${category.name}"
                            data-limit="${category.itemLimit || 0}">Edit</button>
                    <button class="delete-btn" data-id="${category.id}">Delete</button>
                </td>
            </tr>
        `).join('');

        // Initialize sorting controls after displaying data
        this.sortableTable.setupSortingControls();
    }

    formatLimit(limit) {
        const limitNum = parseInt(limit);
        return isNaN(limitNum) || limitNum === 0 ? 'No Limit' : limitNum.toString();
    }

    async deleteCategory(id) {
        if (!confirm('Are you sure you want to delete this category?')) return;

        try {
            await apiDelete(`/api/categories/${id}`);
            showMessage('Category deleted successfully', 'success', 'category');
            await this.loadCategories();
            
            // Dispatch event for other managers
            document.dispatchEvent(new Event(EVENTS.CATEGORY_UPDATED));
        } catch (error) {
            showMessage(error.message || 'Error deleting category', 'error', 'category');
        }
    }

    editCategory(id, name, itemLimit) {
        document.getElementById('categoryId').value = id;
        this.nameInput.value = name || '';
        this.itemLimitSelect.value = itemLimit || 0;
        this.form.querySelector('button[type="submit"]').textContent = 'Update Category';
    }

    resetForm() {
        this.form.reset();
        document.getElementById('categoryId').value = '';
        this.itemLimitSelect.value = '0';
        this.form.querySelector('button[type="submit"]').textContent = 'Add Category';
    }
}
</file>

<file path="packages/backend/public/js/foodItems.js">
import { showMessage, apiGet, apiPost, apiPut, apiDelete } from './utils.js';
import { managers } from './main.js';
import { SortableTable } from './utils/sortableTable.js';

export class FoodItemManager {
    constructor(settingsManager) {
        this.settingsManager = settingsManager;
        this.form = document.getElementById('foodItemForm');
        this.tableBody = document.getElementById('foodItemTableBody');
        this.itemLimitSelect = document.getElementById('itemLimitSelect');
        this.resetButton = document.getElementById('resetFoodItemForm');
        this.categorySelect = document.getElementById('foodItemCategory');
        this.nameInput = document.getElementById('foodItemName');
        this.foodItemStats = document.getElementById('foodItemStats');
        this.sortableTable = new SortableTable('foodItemTableBody', this.getSortValue.bind(this));
        this.lastUpdated = null;
        this.initializeFormLayout();
        this.setupEventListeners();
        this.initializeItemLimitDropdown();
        this.init();
    }

    initializeFormLayout() {
        const formSections = ['input', 'status', 'dietary'];
        formSections.forEach(section => {
            const container = document.createElement('div');
            container.className = `form-section ${section}-section`;
            this.form.appendChild(container);
        });

        this.appendToFormSection('input', [
            this.createFormGroup('Item Name:', this.nameInput),
            this.createFormGroup('Category:', this.categorySelect),
            this.createFormGroup('Item Limit:', this.itemLimitSelect),
            this.createLimitTypeGroup()
        ]);

        const statusFlags = this.createStatusFlagsGroup();
        this.appendToFormSection('status', [statusFlags]);

        const dietaryFlags = this.createDietaryFlagsGroup();
        this.appendToFormSection('dietary', [dietaryFlags]);
    }

    createFormGroup(label, element) {
        const group = document.createElement('div');
        group.className = 'form__group';
        
        const labelEl = document.createElement('label');
        labelEl.textContent = label;
        labelEl.className = 'required';
        
        group.appendChild(labelEl);
        group.appendChild(element);
        return group;
    }

    createLimitTypeGroup() {
        const container = document.createElement('div');
        container.id = 'limitTypeContainer';
        container.style.display = 'none';
        container.className = 'limit-type-group';

        const perHousehold = document.createElement('input');
        perHousehold.type = 'radio';
        perHousehold.name = 'limitType';
        perHousehold.value = 'perHousehold';
        perHousehold.id = 'perHousehold';
        perHousehold.checked = true;

        const perPerson = document.createElement('input');
        perPerson.type = 'radio';
        perPerson.name = 'limitType';
        perPerson.value = 'perPerson';
        perPerson.id = 'perPerson';

        const perHouseholdLabel = document.createElement('label');
        perHouseholdLabel.htmlFor = 'perHousehold';
        perHouseholdLabel.textContent = 'Per Household';

        const perPersonLabel = document.createElement('label');
        perPersonLabel.htmlFor = 'perPerson';
        perPersonLabel.textContent = 'Per Person';

        container.appendChild(perHousehold);
        container.appendChild(perHouseholdLabel);
        container.appendChild(perPerson);
        container.appendChild(perPersonLabel);

        return container;
    }

    createStatusFlagsGroup() {
        const container = document.createElement('div');
        container.className = 'status-flags-group';

        // Add heading
        const heading = document.createElement('h3');
        heading.textContent = 'Status Flags';
        container.appendChild(heading);

        // Create grid container
        const gridContainer = document.createElement('div');
        gridContainer.className = 'flags-grid';
        
        const flags = [
            { id: 'foodItemInStock', label: 'In Stock' },
            { id: 'foodItemMustGo', label: 'Must Go' },
            { id: 'foodItemLowSupply', label: 'Low Supply' },
            { id: 'foodItemReadyToEat', label: 'Ready to Eat' }
        ];

        flags.forEach(flag => {
            // Create toggle container
            const toggle = document.createElement('div');
            toggle.className = 'flag-toggle';
            
            // Create label that wraps the checkbox
            const label = document.createElement('label');
            
            // Create checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = flag.id;
            
            // Add the checkbox and text to label
            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(flag.label));
            
            // Add label to toggle container
            toggle.appendChild(label);
            
            // Add toggle to grid
            gridContainer.appendChild(toggle);
        });

        container.appendChild(gridContainer);
        return container;
    }

    createDietaryFlagsGroup() {
        const container = document.createElement('div');
        container.className = 'dietary-flags-group';

        // Add heading
        const heading = document.createElement('h3');
        heading.textContent = 'Dietary Flags';
        container.appendChild(heading);

        // Create grid container
        const gridContainer = document.createElement('div');
        gridContainer.className = 'flags-grid';
        
        const flags = [
            { id: 'foodItemKosher', label: 'Kosher' },
            { id: 'foodItemHalal', label: 'Halal' },
            { id: 'foodItemVegetarian', label: 'Vegetarian' },
            { id: 'foodItemVegan', label: 'Vegan' },
            { id: 'foodItemGlutenFree', label: 'Gluten Free' },
            { id: 'foodItemOrganic', label: 'Organic' }
        ];

        flags.forEach(flag => {
            // Create toggle container
            const toggle = document.createElement('div');
            toggle.className = 'flag-toggle';
            
            // Create label that wraps the checkbox
            const label = document.createElement('label');
            
            // Create checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = flag.id;
            
            // Add the checkbox and text to label
            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(flag.label));
            
            // Add label to toggle container
            toggle.appendChild(label);
            
            // Add toggle to grid
            gridContainer.appendChild(toggle);
        });

        container.appendChild(gridContainer);
        return container;
    }

    async init() {
        await this.loadCategories();
        if (this.categorySelect.options.length === 0) {
            this.displayNoCategories();
        }
    }

    initializeItemLimitDropdown() {
        if (!this.itemLimitSelect) return;

        const globalLimit = this.settingsManager.getCurrentLimit();
        let options = ['<option value=\"0\">No Limit</option>'];
        
        for (let i = 1; i <= globalLimit; i++) {
            options.push(`<option value=\"${i}\">${i}</option>`);
        }
        
        this.itemLimitSelect.innerHTML = options.join('');
    }

    getSortValue(row, key) {
        const columnIndex = this.sortableTable.getColumnIndex(key);
        switch (key) {
            case 'name':
            case 'category':
                return row.cells[columnIndex].textContent.toLowerCase();
            case 'status':
            case 'dietary':
                return row.cells[columnIndex].textContent.toLowerCase();
            case 'limit':
                const limitText = row.cells[columnIndex].textContent;
                return limitText === 'No Limit' ? -1 : parseInt(limitText);
            case 'created':
                return SortableTable.dateSortValue(row, columnIndex);
            default:
                return row.cells[columnIndex].textContent.toLowerCase();
        }
    }

    setupEventListeners() {
        this.form.addEventListener('submit', this.handleSubmit.bind(this));
        this.resetButton.addEventListener('click', () => this.resetForm());
        this.nameInput.addEventListener('input', this.handleNameInput.bind(this));
        this.addTableEventListeners();
        
        this.itemLimitSelect.addEventListener('change', () => {
            const limitTypeContainer = document.getElementById('limitTypeContainer');
            limitTypeContainer.style.display = this.itemLimitSelect.value === '0' ? 'none' : 'block';
        });
    }

    handleNameInput(e) {
        const input = e.target;
        const value = input.value;

        if (value.length > 36) {
            input.value = value.slice(0, 36);
            showMessage('Input cannot exceed 36 characters', 'warning', 'foodItem');
            return;
        }

        if (/\\s{2,}/.test(value)) {
            input.value = value.replace(/\\s{2,}/g, ' ');
        }

        const words = value.toLowerCase().split(' ');
        const uniqueWords = new Set(words);
        if (uniqueWords.size !== words.length) {
            showMessage('Input contains repeated words', 'warning', 'foodItem');
        }

        input.value = value
            .split(' ')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join(' ');
    }

    displayNoCategories() {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'Please create a category first';
        this.categorySelect.appendChild(option);
        
        this.form.querySelector('button[type=\"submit\"]').disabled = true;
        showMessage('Please create at least one category before adding food items', 'warning', 'foodItem');
    }

    async loadCategories() {
        try {
            const data = await apiGet('/api/categories');
            this.categorySelect.innerHTML = '';
            
            if (!data.data || data.data.length === 0) {
                this.displayNoCategories();
                return;
            }

            this.form.querySelector('button[type=\"submit\"]').disabled = false;
            
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select a category';
            this.categorySelect.appendChild(defaultOption);

            data.data.forEach(category => {
                const option = document.createElement('option');
                option.value = category.id;
                option.textContent = category.name;
                option.dataset.limit = category.itemLimit;
                this.categorySelect.appendChild(option);
            });
        } catch (error) {
            showMessage(error.message, 'error', 'foodItem');
        }
    }

    addTableEventListeners() {
        this.tableBody.addEventListener('click', async (e) => {
            const target = e.target;
            if (target.classList.contains('edit-food-item-btn')) {
                const itemData = target.getAttribute('data-item');
                this.editFoodItem(itemData);
            } else if (target.classList.contains('delete-food-item-btn')) {
                const id = target.dataset.id;
                await this.deleteFoodItem(id);
            }
        });
    }

    async handleSubmit(e) {
        e.preventDefault();
        const name = this.nameInput.value.trim();
        
        if (name.length < 3) {
            showMessage('Food item name must be at least three characters long', 'error', 'foodItem');
            return;
        }

        const letterCount = (name.match(/[a-zA-Z]/g) || []).length;
        if (letterCount < 3) {
            showMessage('Food item name must include at least three letters', 'error', 'foodItem');
            return;
        }

        const words = name.toLowerCase().split(' ');
        const uniqueWords = new Set(words);
        if (uniqueWords.size !== words.length) {
            showMessage('Food item name contains repeated words', 'error', 'foodItem');
            return;
        }

        const data = this.collectFormData();

        try {
            if (data.categoryId === '') {
                showMessage('Please select a category', 'error', 'foodItem');
                return;
            }

            const id = document.getElementById('foodItemId').value;
            if (id) {
                await apiPut(`/api/food-items/${id}`, data);
                showMessage('Food item updated successfully', 'success', 'foodItem');
            } else {
                await apiPost('/api/food-items', data);
                showMessage('Food item created successfully', 'success', 'foodItem');
            }
            this.resetForm();
            await this.loadFoodItems();
        } catch (error) {
            showMessage(error.message || 'An error occurred', 'error', 'foodItem');
        }
    }

    collectFormData() {
        const limitType = document.querySelector('input[name=\"limitType\"]:checked')?.value || 'perHousehold';
        const itemLimit = parseInt(this.itemLimitSelect.value) || 0;

        return {
            name: this.nameInput.value.trim(),
            categoryId: parseInt(this.categorySelect.value),
            itemLimit,
            limitType,
            inStock: document.getElementById('foodItemInStock').checked,
            mustGo: document.getElementById('foodItemMustGo').checked,
            lowSupply: document.getElementById('foodItemLowSupply').checked,
            kosher: document.getElementById('foodItemKosher').checked,
            halal: document.getElementById('foodItemHalal').checked,
            vegetarian: document.getElementById('foodItemVegetarian').checked,
            vegan: document.getElementById('foodItemVegan').checked,
            glutenFree: document.getElementById('foodItemGlutenFree').checked,
            organic: document.getElementById('foodItemOrganic').checked,
            readyToEat: document.getElementById('foodItemReadyToEat').checked
        };
    }

    async loadFoodItems() {
        try {
            await this.loadCategories();
            const data = await apiGet('/api/food-items?includeOutOfStock=true');
            this.displayFoodItems(data.data);
            this.updateStats(data.data);
            this.lastUpdated = new Date();
            if (managers.translations) {
                await managers.translations.loadTranslations();
            }
        } catch (error) {
            showMessage(error.message, 'error', 'foodItem');
        }
    }

    updateStats(foodItems) {
        if (!this.foodItemStats) return;

        const totalItems = foodItems.length;
        const inStock = foodItems.filter(item => item.inStock).length;
        const outOfStock = totalItems - inStock;
        const limited = foodItems.filter(item => item.itemLimit > 0).length;
        const unlimited = totalItems - limited;
        const lastUpdatedStr = this.lastUpdated ? 
            `Last Updated: ${this.lastUpdated.toLocaleString()}` : '';

        this.foodItemStats.innerHTML = `
            <div class="stats">
                <span>Total Items: ${totalItems}</span>
                <span>In Stock: ${inStock}</span>
                <span>Out of Stock: ${outOfStock}</span>
                <span>Limited: ${limited}</span>
                <span>Unlimited: ${unlimited}</span>
                <span>${lastUpdatedStr}</span>
            </div>
        `;
    }

    displayFoodItems(foodItems) {
        if (!Array.isArray(foodItems) || foodItems.length === 0) {
            this.tableBody.innerHTML = '<tr><td colspan="7" class="table__cell--empty">No food items found</td></tr>';
            return;
        }

        this.tableBody.innerHTML = foodItems
            .map(item => this.createFoodItemRow(item))
            .join('');

        this.sortableTable.setupSortingControls();
    }

    createFoodItemRow(item) {
        const status = this.formatStatus(item);
        const dietary = this.formatDietary(item);
        const limitDisplay = this.formatLimit(item);

        const itemData = {
            id: item.id,
            name: item.name,
            categoryId: item.category?.id,
            itemLimit: item.itemLimit,
            limitType: item.limitType,
            inStock: item.inStock,
            mustGo: item.mustGo,
            lowSupply: item.lowSupply,
            kosher: item.kosher,
            halal: item.halal,
            vegetarian: item.vegetarian,
            vegan: item.vegan,
            glutenFree: item.glutenFree,
            organic: item.organic,
            readyToEat: item.readyToEat
        };

        const itemDataString = JSON.stringify(itemData).replace(/'/g, "\\'");

        return `
            <tr>
                <td class="table__cell">${item.name}</td>
                <td class="table__cell">${item.category?.name || 'Unknown'}</td>
                <td class="table__cell">${status || 'None'}</td>
                <td class="table__cell">${dietary || 'None'}</td>
                <td class="table__cell">${limitDisplay}</td>
                <td class="table__cell">${new Date(item.createdAt).toLocaleDateString()}</td>
                <td class="table__cell">
                    <button class="edit-food-item-btn" data-item='${itemDataString}'>
                        Edit
                    </button>
                    <button class="delete-food-item-btn" data-id="${item.id}">
                        Delete
                    </button>
                </td>
            </tr>
        `;
    }

    formatStatus(item) {
        return [
            item.inStock ? 'In Stock' : 'Out of Stock',
            item.mustGo ? 'Must Go' : '',
            item.lowSupply ? 'Low Supply' : '',
            item.readyToEat ? 'Ready to Eat' : ''
        ].filter(Boolean).join(', ');
    }

    formatDietary(item) {
        return [
            item.kosher ? 'Kosher' : '',
            item.halal ? 'Halal' : '',
            item.vegetarian ? 'Vegetarian' : '',
            item.vegan ? 'Vegan' : '',
            item.glutenFree ? 'GF' : '',
            item.organic ? 'Organic' : ''
        ].filter(Boolean).join(', ');
    }

    formatLimit(item) {
        if (item.itemLimit === 0) {
            return 'No Limit';
        }
        const limitType = item.limitType === 'perPerson' ? 'Per Person' : 'Per Household';
        return `${item.itemLimit} ${limitType}`;
    }

    editFoodItem(itemData) {
        const data = typeof itemData === 'string' ? JSON.parse(itemData) : itemData;
        this.populateForm(data);
        this.form.querySelector('button[type="submit"]').textContent = 'Update Food Item';
    }

    populateForm(data) {
        document.getElementById('foodItemId').value = data.id;
        this.nameInput.value = data.name;
        this.categorySelect.value = data.categoryId;
        document.getElementById('foodItemInStock').checked = data.inStock;
        document.getElementById('foodItemMustGo').checked = data.mustGo;
        document.getElementById('foodItemLowSupply').checked = data.lowSupply;
        document.getElementById('foodItemKosher').checked = data.kosher;
        document.getElementById('foodItemHalal').checked = data.halal;
        document.getElementById('foodItemVegetarian').checked = data.vegetarian;
        document.getElementById('foodItemVegan').checked = data.vegan;
        document.getElementById('foodItemGlutenFree').checked = data.glutenFree;
        document.getElementById('foodItemOrganic').checked = data.organic;
        document.getElementById('foodItemReadyToEat').checked = data.readyToEat;

        const limitTypeInputs = document.querySelectorAll('input[name="limitType"]');
        limitTypeInputs.forEach(r => {
            r.checked = (r.value === data.limitType);
        });

        this.itemLimitSelect.value = data.itemLimit;

        const limitTypeContainer = document.getElementById('limitTypeContainer');
        limitTypeContainer.style.display = data.itemLimit === 0 ? 'none' : 'block';
    }

    async deleteFoodItem(id) {
        if (!confirm('Are you sure you want to delete this food item?')) return;
        
        try {
            await apiDelete(`/api/food-items/${id}`);
            showMessage('Food item deleted successfully', 'success', 'foodItem');
            await this.loadFoodItems();
        } catch (error) {
            showMessage(error.message, 'error', 'foodItem');
        }
    }

    resetForm() {
        this.form.reset();
        document.getElementById('foodItemId').value = '';
        this.itemLimitSelect.value = '0';
        const limitTypeContainer = document.getElementById('limitTypeContainer');
        limitTypeContainer.style.display = 'none';
        this.form.querySelector('button[type="submit"]').textContent = 'Add Food Item';
    }

    appendToFormSection(section, elements) {
        const container = this.form.querySelector(`.${section}-section`);
        if (container) {
            elements.forEach(el => container.appendChild(el));
        }
    }
}
</file>

<file path="packages/backend/public/js/languages.js">
import { showMessage, apiGet, apiPost } from './utils.js';
import { SortableTable } from './utils/sortableTable.js';

export class LanguageManager {
    constructor() {
        this.languageTableBody = document.getElementById('languageTableBody');
        this.updateLanguagesBtn = document.getElementById('updateLanguages');
        this.languageGrid = document.querySelector('.language-grid');
        this.filterSelect = document.getElementById('languageFilter');
        this.languageStats = document.getElementById('languageStats');
        this.sortableTable = new SortableTable('languageTableBody', this.getSortValue.bind(this));
        this.lastUpdated = null;
        
        // Set default filter to "Active Languages"
        if (this.filterSelect) {
            this.filterSelect.value = 'active';
        }
        
        this.setupEventListeners();
        this.loadLanguages(); // Initial load
    }

    getSortValue(row, key) {
        const columnIndex = this.sortableTable.getColumnIndex(key);
        switch (key) {
            case 'code':
                return row.cells[columnIndex].textContent.toLowerCase();
            case 'name':
                return row.cells[columnIndex].textContent.toLowerCase();
            case 'status':
                return row.cells[columnIndex].textContent === 'Active' ? 1 : 0;
            default:
                return row.cells[columnIndex].textContent.toLowerCase();
        }
    }

    setupEventListeners() {
        this.updateLanguagesBtn.addEventListener('click', () => this.handleLanguageUpdate());
        this.filterSelect.addEventListener('change', () => this.loadLanguages());
    }

    async loadLanguages() {
        try {
            const data = await apiGet('/api/languages');
            const languages = this.filterLanguages(data.data);
            this.displayLanguages(languages);
            this.displayLanguageToggles(data.data);
            this.updateStats(data.data);
            this.lastUpdated = new Date();
        } catch (error) {
            showMessage(error.message, 'error', 'language');
        }
    }

    updateStats(languages) {
        if (!this.languageStats) return;

        const totalLanguages = languages.length;
        const activeLanguages = languages.filter(lang => lang.active).length;
        const inactiveLanguages = totalLanguages - activeLanguages;
        const lastUpdatedStr = this.lastUpdated ? 
            `Last Updated: ${this.lastUpdated.toLocaleString()}` : '';

        this.languageStats.innerHTML = `
            <div class="stats">
                <span>Total Languages: ${totalLanguages}</span>
                <span>Active: ${activeLanguages}</span>
                <span>Inactive: ${inactiveLanguages}</span>
                <span>${lastUpdatedStr}</span>
            </div>
        `;
    }

    filterLanguages(languages) {
        const filterValue = this.filterSelect.value;
        switch (filterValue) {
            case 'active':
                return languages.filter(lang => lang.active);
            case 'inactive':
                return languages.filter(lang => !lang.active);
            default:
                return languages;
        }
    }

    displayLanguageToggles(languages) {
        this.languageGrid.innerHTML = languages.map(lang => `
            <div class="language-toggle">
                <label>
                    <input type="checkbox" 
                           class="language-checkbox" 
                           data-code="${lang.code}"
                           data-name="${lang.name}"
                           ${lang.active ? 'checked' : ''}>
                    ${lang.name}
                </label>
            </div>
        `).join('');
    }

    async handleLanguageUpdate() {
        try {
            const languages = Array.from(document.querySelectorAll('.language-checkbox'))
                .filter(checkbox => checkbox.checked)
                .map(checkbox => ({
                    code: checkbox.dataset.code,
                    name: checkbox.dataset.name
                }));

            await apiPost('/api/languages/bulk', { languages });
            showMessage('Language settings updated successfully', 'success', 'language');
            await this.loadLanguages();
            document.dispatchEvent(new Event('languagesUpdated'));
        } catch (error) {
            showMessage(error.message, 'error', 'language');
        }
    }

    displayLanguages(languages) {
        if (!Array.isArray(languages)) {
            showMessage('Invalid language data received', 'error', 'language');
            return;
        }

        if (languages.length === 0) {
            this.languageTableBody.innerHTML = `
                <tr>
                    <td colspan="3" class="table__cell--empty">No languages found</td>
                </tr>
            `;
            return;
        }

        this.languageTableBody.innerHTML = languages
            .map(lang => this.createLanguageRow(lang))
            .join('');

        // Initialize sorting controls after displaying data
        this.sortableTable.setupSortingControls();
    }

    createLanguageRow(language) {
        return `
            <tr>
                <td class="table__cell">${language.code}</td>
                <td class="table__cell">${language.name}</td>
                <td class="table__cell">${language.active ? 'Active' : 'Inactive'}</td>
            </tr>
        `;
    }
}
</file>

<file path="packages/backend/public/js/main.js">
export const managers = {
    settings: null,
    languages: null,
    categories: null,
    foodItems: null,
    translations: null
};

export const EVENTS = {
    CATEGORY_UPDATED: 'categoryUpdated'
};

document.addEventListener('DOMContentLoaded', async () => {
    try {
        const { SettingsManager } = await import('./settings.js');
        const { LanguageManager } = await import('./languages.js');
        const { CategoryManager } = await import('./categories.js');
        const { FoodItemManager } = await import('./foodItems/index.js');
        const { TranslationManager } = await import('./translations.js');

        managers.settings = new SettingsManager();
        managers.languages = new LanguageManager();
        managers.categories = new CategoryManager();
        managers.foodItems = new FoodItemManager(managers.settings);
        managers.translations = new TranslationManager();
        
        await managers.settings.loadGlobalSettings();
        await managers.languages.loadLanguages();
        await managers.categories.loadCategories();
        await managers.foodItems.loadFoodItems();
        await managers.translations.loadTranslations();

        document.addEventListener(EVENTS.CATEGORY_UPDATED, async () => {
            if (managers.foodItems) {
                await managers.foodItems.loadCategories();
            }
        });

    } catch (error) {
        console.error('Error during initialization:', error);
    }
});
</file>

<file path="packages/backend/public/js/settings.js">
import { showMessage, apiGet, apiPost } from './utils.js';

export class SettingsManager {
    constructor() {
        this.globalUpperLimitInput = document.getElementById('globalUpperLimit');
        this.saveGlobalLimitBtn = document.getElementById('saveGlobalLimit');
        this.setupEventListeners();
    }

    setupEventListeners() {
        this.saveGlobalLimitBtn.addEventListener('click', () => this.saveGlobalSettings());
        this.globalUpperLimitInput.addEventListener('input', this.handleInputValidation.bind(this));
        this.globalUpperLimitInput.setAttribute('type', 'number');
        this.globalUpperLimitInput.setAttribute('min', '1');
    }

    async loadGlobalSettings() {
        try {
            const data = await apiGet('/api/settings');
            this.globalUpperLimitInput.value = data.data.globalUpperLimit;
        } catch (error) {
            showMessage(error.message, 'error', 'settings');
        }
    }

    async saveGlobalSettings() {
        const globalUpperLimit = parseInt(this.globalUpperLimitInput.value);
        if (isNaN(globalUpperLimit) || globalUpperLimit < 1) {
            showMessage('Global upper limit must be at least 1', 'error', 'settings');
            this.globalUpperLimitInput.value = 1;
            return;
        }

        try {
            await apiPost('/api/settings', { globalUpperLimit });
            showMessage('Global upper limit saved successfully', 'success', 'settings');
        } catch (error) {
            showMessage(error.message, 'error', 'settings');
        }
    }

    handleInputValidation(e) {
        const value = parseInt(e.target.value);
        if (value < 1) {
            e.target.value = 1;
        }
    }

    getCurrentLimit() {
        return parseInt(this.globalUpperLimitInput.value) || 10;
    }
}
</file>

<file path="packages/backend/public/js/translations.js">
import { showMessage, apiGet, apiPut, apiDelete, apiPost } from './utils.js';
import { SortableTable } from './utils/sortableTable.js';

export class TranslationManager {
    constructor() {
        this.translationTableBody = document.getElementById('translationTableBody');
        this.translationTypeRadios = document.querySelectorAll('input[name="translationType"]');
        this.filterLanguageSelect = document.getElementById('filterLanguage');
        this.customTextInput = document.getElementById('customText');
        this.addTranslationBtn = document.getElementById('addTranslation');
        this.translationStats = document.getElementById('translationStats');
        this.sortableTable = new SortableTable('translationTableBody', this.getSortValue.bind(this));
        this.setupEventListeners();
        this.currentType = 'category';
        this.lastUpdated = null;
        this.loadLanguagesFilter();
    }

    getSortValue(row, key) {
        const columnIndex = this.sortableTable.getColumnIndex(key);
        switch (key) {
            case 'originalText':
            case 'language':
            case 'translation':
            case 'type':
                return row.cells[columnIndex].textContent.toLowerCase();
            case 'created':
                return SortableTable.dateSortValue(row, columnIndex);
            default:
                return row.cells[columnIndex].textContent.toLowerCase();
        }
    }

    async loadLanguagesFilter() {
        try {
            const data = await apiGet('/api/languages');
            this.updateLanguageFilter(data.data);
            this.activeLanguages = data.data.filter(lang => lang.active);
        } catch (error) {
            showMessage(error.message, 'error', 'translation');
        }
    }

    updateLanguageFilter(languages) {
        if (!this.filterLanguageSelect) return;
        
        const currentValue = this.filterLanguageSelect.value;
        this.filterLanguageSelect.innerHTML = `
            <option value="">All Languages</option>
            ${languages
                .map(lang => `<option value="${lang.code}" ${lang.code === currentValue ? 'selected' : ''}>${lang.name}</option>`)
                .join('')}
        `;
    }

    isTypeCategory() {
        return this.currentType === 'category';
    }

    isTypeFoodItem() {
        return this.currentType === 'foodItem';
    }

    isTypeCustom() {
        return this.currentType === 'customInput';
    }

    setupEventListeners() {
        this.translationTypeRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                this.currentType = radio.value;
                this.loadTranslations();
            });
        });

        this.filterLanguageSelect.addEventListener('change', () => {
            this.loadTranslations();
        });

        document.addEventListener('languagesUpdated', () => {
            this.loadLanguagesFilter();
            this.loadTranslations();
        });

        if (this.customTextInput) {
            this.customTextInput.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') {
                    this.handleCustomTranslation();
                }
            });
        }

        if (this.addTranslationBtn) {
            this.addTranslationBtn.addEventListener('click', () => {
                this.handleCustomTranslation();
            });
        }

        this.addTableEventListeners();
    }

    async handleCustomTranslation() {
        const text = this.customTextInput.value.trim();
        if (!text) {
            showMessage('Please enter text to translate', 'error', 'translation');
            return;
        }

        try {
            const activeLanguages = await apiGet('/api/languages/active');
            const translations = [];
            let errors = 0;

            for (const language of activeLanguages.data) {
                try {
                    const response = await apiPost('/api/translations/custom', {
                        text,
                        languageCode: language.code,
                        type: 'customInput'
                    });
                    translations.push(response);
                } catch (error) {
                    errors++;
                    console.error(`Failed to translate to ${language.code}:`, error);
                }
            }

            this.customTextInput.value = '';
            const successCount = translations.length;
            const message = errors > 0 ? 
                `Custom text translated to ${successCount} languages (${errors} failed)` :
                `Custom text translated to ${successCount} languages`;
            showMessage(message, errors > 0 ? 'warning' : 'success', 'translation');
            
            // Select custom type and reload translations
            const customRadio = Array.from(this.translationTypeRadios)
                .find(radio => radio.value === 'customInput');
            if (customRadio) {
                customRadio.checked = true;
                this.currentType = 'customInput';
            }
            await this.loadTranslations();
        } catch (error) {
            showMessage(error.message, 'error', 'translation');
        }
    }

    addTableEventListeners() {
        this.translationTableBody.addEventListener('click', async (e) => {
            const target = e.target;
            if (target.classList.contains('edit-translation-btn')) {
                await this.handleEditTranslation(target);
            } else if (target.classList.contains('delete-translation-btn')) {
                await this.handleDeleteTranslation(target);
            }
        });
    }

    async loadTranslations() {
        try {
            let queryParams = new URLSearchParams();
            
            // Only add type for category and foodItem
            if (!this.isTypeCustom()) {
                queryParams.append('type', this.currentType);
            }
            
            if (this.filterLanguageSelect.value) {
                queryParams.append('languageCode', this.filterLanguageSelect.value);
            }

            // For custom type, use a different endpoint
            const endpoint = this.isTypeCustom() ? 
                '/api/translations/custom' : 
                `/api/translations?${queryParams}`;

            const response = await apiGet(endpoint);
            this.displayTranslations(response.data);
            this.updateStats(response.data);
            this.lastUpdated = new Date();
        } catch (error) {
            if (this.isTypeCustom()) {
                // If no custom translations yet, show empty state
                this.displayTranslations([]);
                this.updateStats([]);
            } else {
                showMessage(error.message, 'error', 'translation');
            }
        }
    }

    updateStats(translations) {
        if (!this.translationStats) return;

        const uniqueLanguages = new Set(translations.map(t => t.language.code)).size;
        const uniqueTexts = new Set(translations.map(t => 
            t.category?.name || t.foodItem?.name || t.originalText
        )).size;
        const lastUpdatedStr = this.lastUpdated ? 
            `Last Updated: ${this.lastUpdated.toLocaleString()}` : '';

        this.translationStats.innerHTML = `
            <div class="stats">
                <span>Total Translations: ${translations.length}</span>
                <span>Unique Items: ${uniqueTexts}</span>
                <span>Languages: ${uniqueLanguages}</span>
                <span>${lastUpdatedStr}</span>
            </div>
        `;
    }

    displayTranslations(translations) {
        this.translationTableBody.innerHTML = '';
        if (!translations || translations.length === 0) {
            const message = this.isTypeCustom() ? 
                'No custom translations found' : 
                'No translations found';
            this.translationTableBody.innerHTML = `
                <tr><td colspan="6" class="table__cell--empty">${message}</td></tr>
            `;
            return;
        }
        translations.forEach(translation => {
            const row = this.createTranslationRow(translation);
            this.translationTableBody.appendChild(row);
        });
        
        this.sortableTable.setupSortingControls();
    }

    createTranslationRow(translation) {
        const row = document.createElement('tr');
        const originalText = translation.category ? translation.category.name : 
                           (translation.foodItem ? translation.foodItem.name : translation.originalText);
        
        row.innerHTML = `
            <td class="table__cell">${originalText}</td>
            <td class="table__cell">${translation.language.name}</td>
            <td class="table__cell">${translation.translatedText}</td>
            <td class="table__cell">${this.getTranslationType(translation)}</td>
            <td class="table__cell">${new Date(translation.createdAt).toLocaleDateString()}</td>
            <td class="table__cell">
                <button class="edit-translation-btn" 
                        data-id="${translation.id}"
                        data-current-text="${translation.translatedText}">
                    Edit
                </button>
                <button class="delete-translation-btn" data-id="${translation.id}">
                    Delete
                </button>
            </td>
        `;
        
        return row;
    }

    getTranslationType(translation) {
        if (translation.category) return 'Category';
        if (translation.foodItem) return 'Food Item';
        return 'Custom';
    }

    async handleEditTranslation(button) {
        const id = button.dataset.id;
        const currentText = button.dataset.currentText;
        const newText = prompt('Enter new translation:', currentText);
        
        if (newText && newText !== currentText) {
            try {
                await apiPut(`/api/translations/${id}`, { translatedText: newText });
                showMessage('Translation updated successfully', 'success', 'translation');
                await this.loadTranslations();
            } catch (error) {
                showMessage(error.message, 'error', 'translation');
            }
        }
    }

    async handleDeleteTranslation(button) {
        const id = button.dataset.id;
        if (confirm('Are you sure you want to delete this translation?')) {
            try {
                await apiDelete(`/api/translations/${id}`);
                showMessage('Translation deleted successfully', 'success', 'translation');
                await this.loadTranslations();
            } catch (error) {
                showMessage(error.message, 'error', 'translation');
            }
        }
    }

    updateTranslationTargets() {
        this.loadTranslations();
    }
}
</file>

<file path="packages/backend/public/js/utils.js">
export function showMessage(message, type = 'info', section = null) {
    const messageArea = section ? 
        document.querySelector(`#${section}Section .message-area`) : 
        document.getElementById('messageArea');
    
    if (!messageArea) return;

    const messageElement = document.createElement('div');
    messageElement.className = `message message--${type}`;
    messageElement.textContent = message;
    
    messageArea.innerHTML = '';
    messageArea.appendChild(messageElement);

    if (type === 'success') {
        setTimeout(() => messageElement.remove(), 5000);
    }
}

export function clearMessages(section = null) {
    const messageArea = section ? 
        document.querySelector(`#${section}Section .message-area`) : 
        document.getElementById('messageArea');
    
    if (messageArea) {
        messageArea.innerHTML = '';
    }
}

export async function apiGet(endpoint) {
    try {
        const response = await fetch(endpoint);
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        console.error('API Get Error:', error);
        throw error;
    }
}

export async function apiPost(endpoint, data) {
    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data),
        });
        
        const responseData = await response.json();
        
        if (!response.ok) {
            throw new Error(responseData.message || `HTTP error! status: ${response.status}`);
        }
        
        return responseData;
    } catch (error) {
        console.error('API Post Error:', error);
        throw error;
    }
}

export async function apiPut(endpoint, data) {
    try {
        const response = await fetch(endpoint, {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data),
        });
        
        const responseData = await response.json();
        
        if (!response.ok) {
            throw new Error(responseData.message || `HTTP error! status: ${response.status}`);
        }
        
        return responseData;
    } catch (error) {
        console.error('API Put Error:', error);
        throw error;
    }
}

export async function apiDelete(endpoint) {
    try {
        const response = await fetch(endpoint, {
            method: 'DELETE',
        });
        
        const responseData = await response.json();
        
        if (!response.ok) {
            throw new Error(responseData.message || `HTTP error! status: ${response.status}`);
        }
        
        return responseData;
    } catch (error) {
        console.error('API Delete Error:', error);
        throw error;
    }
}

export function formatDate(dateString) {
    const date = new Date(dateString);
    return new Intl.DateTimeFormat('default', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
    }).format(date);
}
</file>

<file path="packages/backend/public/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Food Pantry Management - Test UI</title>
    <link rel="stylesheet" href="css/styles.css" />
</head>
<body>
    <h1>Food Pantry Management - Test UI</h1>

    <!-- Global Settings -->
    <div id="settingsSection" class="section">
        <h2>Global Settings</h2>
        <div class="message-area"></div>
        <div class="form__group">
            <label for="globalUpperLimit">Global Upper Limit:</label>
            <input type="number" id="globalUpperLimit" value="255" min="1">
            <button id="saveGlobalLimit" class="primary-button" type="submit">Save</button>
        </div>
        <p class="message message--note">
            Applies to all food items and categories set to "No Limit."<br>
            After adjusting the upper limit setting, click "Save" to apply it. 
        </p>
    </div>

    <!-- Language Management Section -->
    <div id="languageSection" class="section">
        <h2>Language Management</h2>
        <div class="message-area"></div>
        <p class="message message--warning">
            Note: Language support varies by region and complexity.<br>
            AI translations may contain errors and should be reviewed for accuracy.
        </p>
        
        <div class="language-grid">
            <!-- Languages will be dynamically populated here -->
        </div>
        
        <button id="updateLanguages">Update Language Settings</button>
        <p class="message message--note">
            Click on a language to toggle Active/Inactive state.<br>
            After making changes, click "Update Language Settings" to apply it. 
        </p>
        
        <div id="activeLanguages">
            <div class="filter-controls">
                <label for="languageFilter">Filter By:</label>
                <select id="languageFilter">
                    <option value="all">All Languages</option>
                    <option value="active">Active Languages</option>
                    <option value="inactive">Inactive Languages</option>
                </select>
            </div>

            <table class="table">
                <thead>
                    <tr>
                        <th class="table__header" data-sort="code">Code</th>
                        <th class="table__header" data-sort="name">Name</th>
                        <th class="table__header" data-sort="status">Status</th>
                    </tr>
                </thead>
                <tbody id="languageTableBody">
                    <!-- Active languages will be loaded here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Category Management Section -->
    <div id="categorySection" class="section">
        <h2>Category Management</h2>
        <div class="message-area"></div>
        <div id="categoryStats" class="stats-container">
            <!-- Stats will be dynamically populated here -->
        </div>
        <form id="categoryForm">
            <div class="form__group">
                <label for="categoryName">Category Name:</label>
                <input type="text" id="categoryName" name="categoryName" required>
            </div>
            <div class="form__group">
                <label for="categoryItemLimit">Item Limit:</label>
                <select id="categoryItemLimit" name="categoryItemLimit">
                    <!-- Options will be dynamically populated -->
                </select>
                <p class="message message--note">
                    Limits the total items a client can request within a category.<br>
                    Global Upper Limit applies when a category is set to 'No Limit.' 
                </p>
            </div>
            <input type="hidden" id="categoryId">
            <button type="submit">Add Category</button>
            <button type="button" id="resetForm">Clear Form</button>
        </form>
        <div id="categoryList">
            <h3>Categories</h3>
            <table class="table">
                <thead>
                    <tr>
                        <th class="table__header" data-sort="name">Name</th>
                        <th class="table__header" data-sort="limit">Item Limit</th>
                        <th class="table__header" data-sort="created">Created</th>
                        <th class="table__header">Actions</th>
                    </tr>
                </thead>
                <tbody id="categoryTableBody">
                    <!-- Categories will be loaded here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Food Items Section -->
    <div id="foodItemSection" class="section">
        <h2>Food Item Management</h2>
        <div class="message-area"></div>
        <div id="foodItemStats" class="stats-container">
            <!-- Stats will be dynamically populated here -->
        </div>
        <form id="foodItemForm">
            <!-- Important: Empty containers for dynamic form sections -->
            <div class="form-section input-section">
                <!-- Name, Category, and Limit inputs will be added here -->
                <input type="text" id="foodItemName" name="foodItemName" class="hidden">
                <select id="foodItemCategory" class="hidden"></select>
                <select id="itemLimitSelect" class="hidden"></select>
            </div>
            <div class="form-section status-section">
                <!-- Status flags will be added here -->
            </div>
            <div class="form-section dietary-section">
                <!-- Dietary flags will be added here -->
            </div>
            <input type="hidden" id="foodItemId">
            <button type="submit">Add Food Item</button>
            <button type="button" id="resetFoodItemForm">Clear Form</button>
        </form>
        <div id="foodItemList">
            <h3>Food Items</h3>
            <table class="table">
                <thead>
                    <tr>
                        <th class="table__header" data-sort="name">Name</th>
                        <th class="table__header" data-sort="category">Category</th>
                        <th class="table__header" data-sort="status">Status</th>
                        <th class="table__header" data-sort="dietary">Dietary</th>
                        <th class="table__header" data-sort="limit">Limit</th>
                        <th class="table__header" data-sort="created">Created</th>
                        <th class="table__header">Actions</th>
                    </tr>
                </thead>
                <tbody id="foodItemTableBody">
                    <!-- Food items will be loaded here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Translations Section -->
    <div id="translationSection" class="section">
        <h2>Translation Management</h2>
        <div class="message-area"></div>
        <div class="translation-controls">
            <div class="custom-translation-input form__group">
                <label for="customText">Custom Translation:</label>
                <div class="flex">
                    <input type="text" id="customText" placeholder="Enter text to translate">
                    <button type="submit" id="addTranslation" class="primary-button">Add Translation</button>
                </div>
            </div>

            <p class="message message--note">
                Translations are automatically generated for all languages marked "Active."<br>
                Manual edits may be overwritten during automated translation updates.
            </p>
            
            <div class="filter-controls">
                <div class="translation-type">
                    <label>
                        <input type="radio" name="translationType" value="category" checked>
                        Categories
                    </label>
                    <label>
                        <input type="radio" name="translationType" value="foodItem">
                        Food Items
                    </label>
                    <label>
                        <input type="radio" name="translationType" value="customInput">
                        Custom
                    </label>
                </div>
                
                <div class="language-filter">
                    <label for="filterLanguage">Filter By Language:</label>
                    <select id="filterLanguage">
                        <option value="">All Languages</option>
                    </select>
                </div>
            </div>
        </div>
    
        <div id="translationList">
            <div id="translationStats" class="stats-container">
                <!-- Stats will be dynamically populated here -->
            </div>
            <table class="table">
                <thead>
                    <tr>
                        <th class="table__header" data-sort="originalText">Original Text</th>
                        <th class="table__header" data-sort="language">Language</th>
                        <th class="table__header" data-sort="translation">Translation</th>
                        <th class="table__header" data-sort="type">Type</th>
                        <th class="table__header" data-sort="created">Created</th>
                        <th class="table__header">Actions</th>
                    </tr>
                </thead>
                <tbody id="translationTableBody"></tbody>
            </table>
        </div>
    </div>

    <!-- Load main.js as a module, which will import other JS modules -->
    <script type="module" src="js/main.js"></script>
</body>
</html>
</file>

<file path="packages/backend/public/sample-claude.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Modern Input Fields Sample</title>
    <style>
        /* Base styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;
            line-height: 1.4;
            color: #333;
            margin: 0;
            padding: 20px;
            background: #f8f9fa;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            background: white;
            padding: 32px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Form field container */
        .field-container {
            position: relative;
            margin-bottom: 24px;
        }

        /* Base input styles */
        .field-container input,
        .field-container select,
        .field-container textarea {
            width: 100%;
            padding: 12px 16px;
            font-size: 14px;
            line-height: 1.5;
            border: 1px solid #dadce0;
            border-radius: 4px;
            background: white;
            transition: all 0.2s ease;
            box-sizing: border-box;
            font-family: inherit;
        }

        /* Focus styles */
        .field-container input:focus,
        .field-container select:focus,
        .field-container textarea:focus {
            outline: none;
            border-color: #1a73e8;
            box-shadow: 0 0 0 4px rgba(26, 115, 232, 0.1);
        }

        /* Label styles */
        .field-container label {
            font-size: 14px;
            font-weight: 500;
            color: #5f6368;
            margin-bottom: 8px;
            display: block;
        }

        /* Helper text */
        .helper-text {
            font-size: 12px;
            color: #5f6368;
            margin-top: 4px;
        }

        /* Error state */
        .field-container.error input {
            border-color: #d93025;
        }

        .field-container.error .helper-text {
            color: #d93025;
        }

        /* Disabled state */
        .field-container input:disabled,
        .field-container select:disabled {
            background-color: #f1f3f4;
            border-color: #dadce0;
            color: #80868b;
            cursor: not-allowed;
        }

        /* Number input */
        input[type="number"] {
            -moz-appearance: textfield;
        }

        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Select styling */
        select {
            appearance: none;
            padding-right: 40px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%235f6368' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 24px;
        }

        /* Required indicator */
        .required::after {
            content: "*";
            color: #d93025;
            margin-left: 4px;
        }

        /* Responsive adjustments */
        @media screen and (max-width: 480px) {
            .container {
                padding: 16px;
            }
        }

        /* High Contrast support */
        @media (prefers-contrast: high) {
            .field-container input,
            .field-container select,
            .field-container textarea {
                border-width: 2px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Modern Form Fields</h2>

        <!-- Text input -->
        <div class="field-container">
            <label for="name" class="required">Category Name</label>
            <input type="text" id="name" placeholder="Enter category name"/>
            <div class="helper-text">3-36 characters, no special characters</div>
        </div>

        <!-- Select input -->
        <div class="field-container">
            <label for="limit">Item Limit</label>
            <select id="limit">
                <option value="">Select a limit</option>
                <option value="no-limit">No Limit</option>
                <option value="1">1 item</option>
                <option value="2">2 items</option>
            </select>
            <div class="helper-text">Global upper limit applies when set to 'No Limit'</div>
        </div>

        <!-- Number input -->
        <div class="field-container">
            <label for="global-limit" class="required">Global Upper Limit</label>
            <input type="number" id="global-limit" value="255" min="1"/>
            <div class="helper-text">Minimum value is 1</div>
        </div>

        <!-- Text input with error -->
        <div class="field-container error">
            <label for="error-example">Error Example</label>
            <input type="text" id="error-example" value="Duplicate name"/>
            <div class="helper-text">This category name already exists</div>
        </div>

        <!-- Disabled input -->
        <div class="field-container">
            <label for="disabled-example">Disabled Example</label>
            <input type="text" id="disabled-example" disabled value="Cannot modify"/>
            <div class="helper-text">This field cannot be modified</div>
        </div>
    </div>
</body>
</html>
</file>

<file path="packages/backend/public/sample-layout-part1.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Layout Sample</title>
    <style>
       @media screen and (max-width: 768px) {
            .container {
                padding: var(--space-md);
            }

            section {
                padding: var(--space-md);
            }

            .form-row {
                flex-direction: column;
                gap: var(--space-md);
            }

            .button {
                width: 100%;
                margin-top: var(--space-sm);
            }

            .button-group {
                flex-direction: column;
            }

            input[type="number"] {
                width: 100%;
            }

            .helper-text {
                width: 100%;
            }

            textarea {
                min-width: 100%;
            }

            .flags-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                padding: var(--space-md);
                gap: var(--space-sm);
            }

            .flag-toggle {
                padding: 10px;
            }
        }

        @media (prefers-contrast: high) {
            input, select, textarea, .flag-toggle {
                border-width: 2px;
            }

            .button-primary {
                border: 2px solid var(--color-primary);
            }

            input:focus, select:focus, textarea:focus {
                outline: 2px solid var(--color-primary);
                outline-offset: 2px;
            }

            .status-flags-group .flags-grid {
                border: 2px solid var(--color-info);
            }

            .dietary-flags-group .flags-grid {
                border: 2px solid var(--color-success);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <section>
            <h2>Global Settings</h2>
            <div class="form-row">
                <div class="form-field">
                    <label for="global-limit">Global Upper Limit:</label>
                    <input type="number" id="global-limit" min="1" value="255">
                    <div class="helper-text">Minimum value is 1</div>
                </div>
                <button class="button button-primary">Save</button>
            </div>
            <div class="message">
                This upper limit setting applies to all categories and food items set to "No Limit."<br>
                Adjust the limit and click "Save" to update.
            </div>
        </section>

        <section>
            <h2>Language Management</h2>
            <div class="form-row">
                <button class="button button-primary" style="margin-top: 0;">Update Language Settings</button>
            </div>
        </section>

        <section>
            <h2>Translation Management</h2>
            <div class="form-row">
                <div class="form-field">
                    <label for="custom-text">Custom Translation:</label>
                    <textarea 
                        id="custom-text" 
                        placeholder="Enter text to translate"
                        spellcheck="true"
                    ></textarea>
                    <div class="helper-text">Enter the text you want translated to all active languages</div>
                </div>
                <button class="button button-primary">Add Translation</button>
            </div>
        </section>

        <section>
            <h2>Food Item Management</h2>
            
            <div class="form-row">
                <div class="form-field">
                    <label for="item-name">Food Item Name:</label>
                    <input type="text" id="item-name" placeholder="Enter food item name">
                    <div class="helper-text">3-36 characters, no special characters</div>
                </div>
            </div>

            <div class="form-row">
                <div class="form-field">
                    <label for="item-category">Category:</label>
                    <select id="item-category">
                        <option value="">Select a category</option>
                        <option value="1">Canned Goods</option>
                        <option value="2">Fresh Produce</option>
                        <option value="3">Dairy</option>
                    </select>
                </div>
                <div class="form-field">
                    <label for="item-limit">Item Limit:</label>
                    <select id="item-limit">
                        <option value="no-limit">No Limit</option>
                        <option value="1">1 item</option>
                        <option value="2">2 items</option>
                        <option value="3">3 items</option>
                    </select>
                    <div class="helper-text">Per household/visit</div>
                </div>
            </div>

            <div class="status-flags-group">
                <h3>Status Flags</h3>
                <div class="flags-grid">
                    <div class="flag-toggle">
                        <label for="flag-low-stock">
                            <input type="checkbox" id="flag-low-stock">
                            Low Stock
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="flag-must-go">
                            <input type="checkbox" id="flag-must-go">
                            Must Go
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="flag-seasonal">
                            <input type="checkbox" id="flag-seasonal">
                            Seasonal
                        </label>
                    </div>
                </div>
            </div>

            <div class="dietary-flags-group">
                <h3>Dietary Flags</h3>
                <div class="flags-grid">
                    <div class="flag-toggle">
                        <label for="diet-gluten-free">
                            <input type="checkbox" id="diet-gluten-free">
                            Gluten Free
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="diet-vegetarian">
                            <input type="checkbox" id="diet-vegetarian">
                            Vegetarian
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="diet-vegan">
                            <input type="checkbox" id="diet-vegan">
                            Vegan
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="diet-kosher">
                            <input type="checkbox" id="diet-kosher">
                            Kosher
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="diet-halal">
                            <input type="checkbox" id="diet-halal">
                            Halal
                        </label>
                    </div>
                </div>
            </div>

            <div class="button-group">
                <button type="submit" class="button button-primary">Add Food Item</button>
                <button type="button" class="button button-secondary">Clear Form</button>
            </div>
        </section>
    </div>
</body>
</html>
</file>

<file path="packages/backend/public/sample-layout.html">
<!DOCTYPE html>
<html lang=\"en\">
<head>
    <meta charset=\"UTF-8\" />
    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>
    <title>Layout Sample</title>
    <style>
        /* Base styles */
        :root {
            --color-primary: #1a73e8;
            --color-primary-hover: #1557b0;
            --color-primary-active: #174ea6;
            --color-secondary-text: #5f6368;
            --color-border: #dadce0;
            --color-success: #4caf50;
            --color-info: #2196f3;
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
            --number-input-width: 120px;
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --radius-pill: 100px;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.05);
            --font-size-sm: 12px;
            --font-size-base: 14px;
            --font-size-lg: 16px;
            --font-size-xl: 20px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.4;
            color: #333;
            margin: 0;
            padding: 20px;
            background: #f8f9fa;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: var(--space-xl);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
        }

        section {
            margin-bottom: var(--space-xl);
            padding: var(--space-lg);
            border: 1px solid #dee2e6;
            border-radius: var(--radius-lg);
        }

        section:last-child {
            margin-bottom: 0;
        }

        h2 {
            color: #212529;
            font-size: var(--font-size-xl);
            margin: 0 0 var(--space-lg) 0;
        }

        h3 {
            color: #495057;
            font-size: var(--font-size-lg);
            font-weight: 600;
            margin: var(--space-lg) 0 var(--space-sm) 0;
            padding-bottom: var(--space-xs);
            border-bottom: 2px solid #e9ecef;
        }

        /* Form Layout */
        .form-row {
            display: flex;
            align-items: flex-start;
            gap: var(--space-md);
            margin-bottom: var(--space-lg);
        }

        .form-field {
            display: flex;
            flex-direction: column;
            min-width: 0;
            flex: 1;
        }

        /* Labels and Inputs */
        label {
            display: block;
            font-size: var(--font-size-base);
            font-weight: 500;
            color: var(--color-secondary-text);
            margin-bottom: var(--space-sm);
        }

        input, select {
            width: 100%;
            padding: 10px var(--space-md);
            font-size: var(--font-size-base);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            box-sizing: border-box;
            background-color: white;
            transition: all 0.2s ease;
        }

        select {
            appearance: none;
            padding-right: 36px;
            background-image: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%235f6368' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E\");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 24px;
        }

        input[type=\"number\"] {
            width: var(--number-input-width);
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 4px rgba(26, 115, 232, 0.1);
        }

        /* Textarea styles */
        textarea {
            width: 100%;
            min-width: 400px;
            height: 80px;
            padding: 10px var(--space-md);
            font-size: var(--font-size-base);
            font-family: inherit;
            line-height: 1.5;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            box-sizing: border-box;
            resize: vertical;
            transition: all 0.2s ease;
        }

        textarea:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 4px rgba(26, 115, 232, 0.1);
        }

        /* Buttons */
        .button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 120px;
            height: 40px;
            padding: 0 var(--space-lg);
            font-size: var(--font-size-base);
            font-weight: 500;
            border: none;
            border-radius: var(--radius-pill);
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 29px;
        }

        .button-primary {
            background: var(--color-primary);
            color: white;
        }

        .button-primary:hover {
            background: var(--color-primary-hover);
            box-shadow: var(--shadow-sm);
        }

        .button-primary:active {
            background: var(--color-primary-active);
        }

        .button-secondary {
            background: transparent;
            color: var(--color-primary);
            border: 1px solid currentColor;
        }

        .button-secondary:hover {
            background: rgba(26, 115, 232, 0.04);
        }

        .button-secondary:active {
            background: rgba(26, 115, 232, 0.1);
        }

        /* Button Groups */
        .button-group {
            display: flex;
            gap: var(--space-md);
            margin-top: var(--space-lg);
        }

        .button-group .button {
            margin-top: 0;
        }

        /* Helper Text */
        .helper-text {
            font-size: var(--font-size-sm);
            color: var(--color-secondary-text);
            margin-top: var(--space-xs);
        }

        .form-field:has(input[type=\"number\"]) .helper-text {
            width: var(--number-input-width);
        }

        /* Messages */
        .message {
            font-size: var(--font-size-base);
            padding: var(--space-md);
            margin-top: var(--space-md);
            border-radius: var(--radius-sm);
            background: #e7f5ff;
            border: 1px solid #b8daff;
            color: #004085;
        }

        /* Flag Groups */
        .dietary-flags-group,
        .status-flags-group {
            margin-bottom: var(--space-lg);
        }

        .dietary-flags-group h3,
        .status-flags-group h3 {
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: #202124;
            margin: 0 0 var(--space-sm) 0;
        }

        /* Flag Grid Layout */
        .flags-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: var(--space-md);
            margin: var(--space-lg) 0;
            padding: var(--space-lg);
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: var(--radius-lg);
        }

        /* Flag Toggle Items */
        .flag-toggle {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: var(--radius-md);
            padding: var(--space-sm);
            transition: all 0.2s ease;
        }

        .flag-toggle:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .flag-toggle label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            width: 100%;
            color: #495057;
            font-size: var(--font-size-base);
            font-weight: 500;
            margin: 0;
        }

        .flag-toggle input[type=\"checkbox\"] {
            width: 18px;
            height: 18px;
            border-radius: var(--radius-sm);
            border: 2px solid #dee2e6;
            cursor: pointer;
            margin: 0;
        }

        /* Status vs Dietary Visual Differentiation */
        .status-flags-group .flags-grid {
            border-color: rgba(33, 150, 243, 0.3);
            background: rgba(33, 150, 243, 0.02);
        }

        .dietary-flags-group .flags-grid {
            border-color: rgba(76, 175, 80, 0.3);
            background: rgba(76, 175, 80, 0.02);
        }

        @media screen and (max-width: 768px) {
            .container {
                padding: var(--space-md);
            }

            section {
                padding: var(--space-md);
            }

            .form-row {
                flex-direction: column;
                gap: var(--space-md);
            }

            .button {
                width: 100%;
                margin-top: var(--space-sm);
            }

            .button-group {
                flex-direction: column;
            }

            input[type=\"number\"] {
                width: 100%;
            }

            .helper-text {
                width: 100%;
            }

            textarea {
                min-width: 100%;
            }

            .flags-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                padding: var(--space-md);
                gap: var(--space-sm);
            }

            .flag-toggle {
                padding: 10px;
            }
        }

        @media (prefers-contrast: high) {
            input, select, textarea, .flag-toggle {
                border-width: 2px;
            }

            .button-primary {
                border: 2px solid var(--color-primary);
            }

            input:focus, select:focus, textarea:focus {
                outline: 2px solid var(--color-primary);
                outline-offset: 2px;
            }

            .status-flags-group .flags-grid {
                border: 2px solid var(--color-info);
            }

            .dietary-flags-group .flags-grid {
                border: 2px solid var(--color-success);
            }
        }
    </style>
</head>
<body>
    <div class=\"container\">
        <section>
            <h2>Global Settings</h2>
            <div class=\"form-row\">
                <div class=\"form-field\">
                    <label for=\"global-limit\">Global Upper Limit:</label>
                    <input type=\"number\" id=\"global-limit\" min=\"1\" value=\"255\">
                    <div class=\"helper-text\">Minimum value is 1</div>
                </div>
                <button class=\"button button-primary\">Save</button>
            </div>
            <div class=\"message\">
                This upper limit setting applies to all categories and food items set to \"No Limit.\"<br>
                Adjust the limit and click \"Save\" to update.
            </div>
        </section>

        <section>
            <h2>Language Management</h2>
            <div class=\"form-row\">
                <button class=\"button button-primary\" style=\"margin-top: 0;\">Update Language Settings</button>
            </div>
        </section>

        <section>
            <h2>Translation Management</h2>
            <div class=\"form-row\">
                <div class=\"form-field\">
                    <label for=\"custom-text\">Custom Translation:</label>
                    <textarea 
                        id=\"custom-text\" 
                        placeholder=\"Enter text to translate\"
                        spellcheck=\"true\"
                    ></textarea>
                    <div class=\"helper-text\">Enter the text you want translated to all active languages</div>
                </div>
                <button class=\"button button-primary\">Add Translation</button>
            </div>
        </section>

        <section>
            <h2>Food Item Management</h2>
            
            <div class=\"form-row\">
                <div class=\"form-field\">
                    <label for=\"item-name\">Food Item Name:</label>
                    <input type=\"text\" id=\"item-name\" placeholder=\"Enter food item name\">
                    <div class=\"helper-text\">3-36 characters, no special characters</div>
                </div>
            </div>

            <div class=\"form-row\">
                <div class=\"form-field\">
                    <label for=\"item-category\">Category:</label>
                    <select id=\"item-category\">
                        <option value=\"\">Select a category</option>
                        <option value=\"1\">Canned Goods</option>
                        <option value=\"2\">Fresh Produce</option>
                        <option value=\"3\">Dairy</option>
                    </select>
                </div>
                <div class=\"form-field\">
                    <label for=\"item-limit\">Item Limit:</label>
                    <select id=\"item-limit\">
                        <option value=\"no-limit\">No Limit</option>
                        <option value=\"1\">1 item</option>
                        <option value=\"2\">2 items</option>
                        <option value=\"3\">3 items</option>
                    </select>
                    <div class=\"helper-text\">Per household/visit</div>
                </div>
            </div>

            <!-- Status Flags -->
            <div class="status-flags-group">
                <h3>Status Flags</h3>
                <div class="flags-grid">
                    <div class="flag-toggle">
                        <label for="flag-low-stock">
                            <input type="checkbox" id="flag-low-stock">
                            Low Stock
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="flag-must-go">
                            <input type="checkbox" id="flag-must-go">
                            Must Go
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="flag-seasonal">
                            <input type="checkbox" id="flag-seasonal">
                            Seasonal
                        </label>
                    </div>
                </div>
            </div>

            <!-- Dietary Flags -->
            <div class="dietary-flags-group">
                <h3>Dietary Flags</h3>
                <div class="flags-grid">
                    <div class="flag-toggle">
                        <label for="diet-gluten-free">
                            <input type="checkbox" id="diet-gluten-free">
                            Gluten Free
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="diet-vegetarian">
                            <input type="checkbox" id="diet-vegetarian">
                            Vegetarian
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="diet-vegan">
                            <input type="checkbox" id="diet-vegan">
                            Vegan
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="diet-kosher">
                            <input type="checkbox" id="diet-kosher">
                            Kosher
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="diet-halal">
                            <input type="checkbox" id="diet-halal">
                            Halal
                        </label>
                    </div>
                </div>
            </div>

            <!-- Form Actions -->
            <div class="button-group">
                <button type="submit" class="button button-primary">Add Food Item</button>
                <button type="button" class="button button-secondary">Clear Form</button>
            </div>
        </section>
    </div>
</body>
</html>
</file>

<file path="packages/backend/public/sample-layoutv2.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Layout Sample</title>
    <style>
        /* Base styles */
        :root {
            --color-primary: #1a73e8;
            --color-primary-hover: #1557b0;
            --color-primary-active: #174ea6;
            --color-secondary-text: #5f6368;
            --color-border: #dadce0;
            --color-success: #4caf50;
            --color-info: #2196f3;
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
            --number-input-width: 120px;
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --radius-pill: 100px;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.05);
            --font-size-sm: 12px;
            --font-size-base: 14px;
            --font-size-lg: 16px;
            --font-size-xl: 20px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.4;
            color: #333;
            margin: 0;
            padding: 20px;
            background: #f8f9fa;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: var(--space-xl);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
        }

        section {
            margin-bottom: var(--space-xl);
            padding: var(--space-lg);
            border: 1px solid #dee2e6;
            border-radius: var(--radius-lg);
        }

        section:last-child {
            margin-bottom: 0;
        }

        h2 {
            color: #212529;
            font-size: var(--font-size-xl);
            margin: 0 0 var(--space-lg) 0;
        }

        h3 {
            color: #495057;
            font-size: var(--font-size-lg);
            font-weight: 600;
            margin: var(--space-lg) 0 var(--space-sm) 0;
            padding-bottom: var(--space-xs);
            border-bottom: 2px solid #e9ecef;
        }
        /* Buttons */
        .button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 120px;
            height: 40px;
            padding: 0 var(--space-lg);
            font-size: var(--font-size-base);
            font-weight: 500;
            border: none;
            border-radius: var(--radius-pill);
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 29px;
        }

        .button.button-primary {
            margin-left: 0; 
            margin-right: var(--space-sm);
        }

        .button-primary {
            background: var(--color-primary);
            color: white;
        }

        .button-primary:hover {
            background: var(--color-primary-hover);
            box-shadow: var(--shadow-sm);
        }

        .button-primary:active {
            background: var(--color-primary-active);
        }

        .button-secondary {
            background: transparent;
            color: var(--color-primary);
            border: 1px solid currentColor;
        }

        .button-secondary:hover {
            background: rgba(26, 115, 232, 0.04);
        }

        .button-secondary:active {
            background: rgba(26, 115, 232, 0.1);
        }

        /* Button Groups */
        .button-group {
            display: flex;
            gap: var(--space-md);
            margin-top: var(--space-lg);
        }

        .button-group .button {
            margin-top: 0;
        }
        /* Form Layout */
        .form-row {
            display: flex;
            align-items: flex-start;
            gap: var(--space-md);
            margin-bottom: var(--space-lg);
        }

        .form-field {
            display: flex;
            flex-direction: column;
            min-width: 0;
            flex: 1;
        }
        label {
            display: block;
            font-size: var(--font-size-base);
            font-weight: 500;
            color: var(--color-secondary-text);
            margin-bottom: var(--space-sm);
        }

        input, select {
            width: 100%;
            padding: 10px var(--space-md);
            font-size: var(--font-size-base);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            box-sizing: border-box;
            background-color: white;
            transition: all 0.2s ease;
        }

        select {
            appearance: none;
            padding-right: 36px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%235f6368' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 24px;
        }

        input[type="number"] {
            width: var(--number-input-width);
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 4px rgba(26, 115, 232, 0.1);
        }

        /* Textarea styles */
        textarea {
            width: 100%;
            min-width: 400px;
            height: 80px;
            padding: 10px var(--space-md);
            font-size: var(--font-size-base);
            font-family: inherit;
            line-height: 1.5;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            box-sizing: border-box;
            resize: vertical;
            transition: all 0.2s ease;
        }

        textarea:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 4px rgba(26, 115, 232, 0.1);
        }

        /* Helper Text */
        .helper-text {
            font-size: var(--font-size-sm);
            color: var(--color-secondary-text);
            margin-top: var(--space-xs);
        }

        .form-field:has(input[type="number"]) .helper-text {
            width: var(--number-input-width);
        }

        /* Messages */
        .message {
            font-size: var(--font-size-base);
            padding: var(--space-md);
            margin-top: var(--space-md);
            border-radius: var(--radius-sm);
            background: #e7f5ff;
            border: 1px solid #b8daff;
            color: #004085;
        }

        /* Flag Groups */
        .dietary-flags-group,
        .status-flags-group {
            margin-bottom: var(--space-lg);
        }
        .dietary-flags-group h3,
        .status-flags-group h3 {
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: #202124;
            margin: 0 0 var(--space-sm) 0;
        }

        /* Flag Grid Layout */
        .flags-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: var(--space-md);
            margin: var(--space-lg) 0;
            padding: var(--space-lg);
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: var(--radius-lg);
        }

        /* Flag Toggle Items */
        .flag-toggle {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: var(--radius-md);
            padding: var(--space-sm);
            transition: all 0.2s ease;
        }

        .flag-toggle:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .flag-toggle label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            width: 100%;
            color: #495057;
            font-size: var(--font-size-base);
            font-weight: 500;
            margin: 0;
        }

        .flag-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            border-radius: var(--radius-sm);
            border: 2px solid #dee2e6;
            cursor: pointer;
            margin: 0;
        }

        /* Status vs Dietary Visual Differentiation */
        .status-flags-group .flags-grid {
            border-color: rgba(33, 150, 243, 0.3);
            background: rgba(33, 150, 243, 0.02);
        }

        .dietary-flags-group .flags-grid {
            border-color: rgba(76, 175, 80, 0.3);
            background: rgba(76, 175, 80, 0.02);
        }
        @media screen and (max-width: 768px) {
            .container {
                padding: var(--space-md);
            }

            section {
                padding: var(--space-md);
            }

            .form-row {
                flex-direction: column;
                gap: var(--space-md);
            }

            .button {
                width: 100%;
                margin-top: var(--space-sm);
            }

            .button-group {
                flex-direction: column;
            }

            input[type="number"] {
                width: 100%;
            }

            .helper-text {
                width: 100%;
            }

            textarea {
                min-width: 100%;
            }

            .flags-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                padding: var(--space-md);
                gap: var(--space-sm);
            }

            .flag-toggle {
                padding: 10px;
            }
        }

        @media (prefers-contrast: high) {
            input, select, textarea, .flag-toggle {
                border-width: 2px;
            }

            .button-primary {
                border: 2px solid var(--color-primary);
            }

            input:focus, select:focus, textarea:focus {
                outline: 2px solid var(--color-primary);
                outline-offset: 2px;
            }

            .status-flags-group .flags-grid {
                border: 2px solid var(--color-info);
            }

            .dietary-flags-group .flags-grid {
                border: 2px solid var(--color-success);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <section>
            <h2>Global Settings</h2>
            <div class="form-row">
                <div class="form-field">
                    <label for="global-limit">Global Upper Limit:</label>
                    <input type="number" id="global-limit" min="1" value="255">
                    <div class="helper-text">Minimum value is 1</div>
                </div>
                <button class="button button-primary">Save</button>
            </div>
            <div class="message">
                This upper limit setting applies to all categories and food items set to "No Limit."<br>
                Adjust the limit and click "Save" to update.
            </div>
        </section>

        <section>
            <h2>Language Management</h2>
            <div class="form-row">
                <button class="button button-primary" style="margin-top: 0;">Update Language Settings</button>
            </div>
        </section>

        <section>
            <h2>Translation Management</h2>
            <div class="form-row">
                <div class="form-field">
                    <label for="custom-text">Custom Translation:</label>
                    <textarea 
                        id="custom-text" 
                        placeholder="Enter text to translate"
                        spellcheck="true"
                    ></textarea>
                    <div class="helper-text">Enter the text you want translated to all active languages</div>
                </div>
                <button class="button button-primary">Add Translation</button>
            </div>
        </section>
    <section>
            <h2>Food Item Management</h2>
            
            <div class="form-row">
                <div class="form-field">
                    <label for="item-name">Food Item Name:</label>
                    <input type="text" id="item-name" placeholder="Enter food item name">
                    <div class="helper-text">3-36 characters, no special characters</div>
                </div>
            </div>

            <div class="form-row">
                <div class="form-field">
                    <label for="item-category">Category:</label>
                    <select id="item-category">
                        <option value="">Select a category</option>
                        <option value="1">Canned Goods</option>
                        <option value="2">Fresh Produce</option>
                        <option value="3">Dairy</option>
                    </select>
                </div>
                <div class="form-field">
                    <label for="item-limit">Item Limit:</label>
                    <select id="item-limit">
                        <option value="no-limit">No Limit</option>
                        <option value="1">1 item</option>
                        <option value="2">2 items</option>
                        <option value="3">3 items</option>
                    </select>
                    <div class="helper-text">Per household/visit</div>
                </div>
            </div>

            <div class="status-flags-group">
                <h3>Status Flags</h3>
                <div class="flags-grid">
                    <div class="flag-toggle">
                        <label for="flag-low-stock">
                            <input type="checkbox" id="flag-low-stock">
                            Low Stock
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="flag-must-go">
                            <input type="checkbox" id="flag-must-go">
                            Must Go
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="flag-seasonal">
                            <input type="checkbox" id="flag-seasonal">
                            Seasonal
                        </label>
                    </div>
                </div>
            </div>

            <div class="dietary-flags-group">
                <h3>Dietary Flags</h3>
                <div class="flags-grid">
                    <div class="flag-toggle">
                        <label for="diet-gluten-free">
                            <input type="checkbox" id="diet-gluten-free">
                            Gluten Free
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="diet-vegetarian">
                            <input type="checkbox" id="diet-vegetarian">
                            Vegetarian
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="diet-vegan">
                            <input type="checkbox" id="diet-vegan">
                            Vegan
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="diet-kosher">
                            <input type="checkbox" id="diet-kosher">
                            Kosher
                        </label>
                    </div>
                    <div class="flag-toggle">
                        <label for="diet-halal">
                            <input type="checkbox" id="diet-halal">
                            Halal
                        </label>
                    </div>
                </div>
            </div>

            <div class="button-group">
                <button type="submit" class="button button-primary">Add Food Item</button>
                <button type="button" class="button button-secondary">Clear Form</button>
            </div>
        </section>
    </div>
</body>
</html>
</file>

<file path="packages/backend/public/sample.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Modern Form Example</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f5f5f5;
      padding: 20px;
      max-width: 600px;
      margin: auto;
    }
    .field-container {
      position: relative;
      margin-bottom: 24px;
    }
    /* Common styles for inputs and selects */
    .field-container input,
    .field-container select,
    .field-container textarea {
      width: 100%;
      padding: 12px 8px;
      border: none;
      border-bottom: 2px solid #ccc;
      background: none;
      font-size: 16px;
      outline: none;
      transition: border-color 0.3s;
      box-sizing: border-box;
    }
    /* Focus effect */
    .field-container input:focus,
    .field-container select:focus,
    .field-container textarea:focus {
      border-bottom: 2px solid #1a73e8;
    }
    /* Floating label */
    .field-container label {
      position: absolute;
      top: 12px;
      left: 8px;
      font-size: 16px;
      color: #aaa;
      pointer-events: none;
      transition: 0.3s;
    }
    /* Move label up when input has text or focus */
    .field-container input:focus + label,
    .field-container input:not(:placeholder-shown) + label,
    .field-container select:focus + label,
    .field-container select:not([value=""]) + label,
    .field-container textarea:focus + label,
    .field-container textarea:not(:placeholder-shown) + label {
      top: -8px;
      font-size: 12px;
      color: #1a73e8;
    }
    /* Icons */
    .field-icon {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 20px;
      color: #aaa;
    }
    .leading-icon {
      left: 8px;
    }
    .trailing-icon {
      right: 8px;
      cursor: pointer;
    }
    .with-leading-icon {
      padding-left: 36px;
    }
    .with-trailing-icon {
      padding-right: 36px;
    }
    /* Helper and error text */
    .helper-text,
    .error-text {
      font-size: 12px;
      color: #aaa;
      margin-top: 4px;
    }
    .error-text {
      color: #d93025;
    }
    /* Outlined container */
    .outlined {
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 16px 8px 8px; 
    }
    .outlined label {
      background-color: #f5f5f5;
      padding: 0 4px;
      left: 16px;
    }
    /* Responsive (optional) */
    @media (max-width: 480px) {
      body {
        padding: 10px;
      }
      .outlined {
        padding: 12px 8px 8px;
      }
    }
  </style>
</head>
<body>
  <h1>Modern Form Fields</h1>

  <!-- Filled Text Field -->
  <div class="field-container">
    <input type="text" id="filled" placeholder=" " />
    <label for="filled">Filled Text</label>
  </div>

  <!-- Outlined Text Field -->
  <div class="field-container outlined">
    <input type="text" id="outlined" placeholder=" " />
    <label for="outlined">Outlined Text</label>
  </div>

  <!-- Text Field with Leading Icon -->
  <div class="field-container">
    <span class="field-icon leading-icon">🔍</span>
    <input type="text" id="search" placeholder=" " class="with-leading-icon" />
    <label for="search">Search</label>
  </div>

  <!-- Password Field with Trailing Icon -->
  <div class="field-container">
    <input
      type="password"
      id="password"
      placeholder=" "
      class="with-trailing-icon"
    />
    <label for="password">Password</label>
    <span class="field-icon trailing-icon" onclick="togglePassword()">
      👁️
    </span>
    <div class="helper-text">At least 8 characters.</div>
  </div>

  <!-- Textarea -->
  <div class="field-container">
    <textarea id="message" rows="3" placeholder=" "></textarea>
    <label for="message">Your Message</label>
  </div>

  <!-- Dropdown Menu -->
  <div class="field-container">
    <select id="dropdown" value="">
      <option value="" disabled selected hidden></option>
      <option value="option1">Option 1</option>
      <option value="option2">Option 2</option>
      <option value="option3">Option 3</option>
    </select>
    <label for="dropdown">Select an Option</label>
    <div class="helper-text">Choose from the dropdown.</div>
  </div>

  <!-- Dropdown with Outlined Style -->
  <div class="field-container outlined">
    <select id="dropdown-outlined" value="">
      <option value="" disabled selected hidden></option>
      <option value="optionA">Option A</option>
      <option value="optionB">Option B</option>
      <option value="optionC">Option C</option>
    </select>
    <label for="dropdown-outlined">Outlined Dropdown</label>
  </div>

  <!-- Simulate Error State -->
  <div class="field-container">
    <input type="text" id="error-field" placeholder=" " />
    <label for="error-field">Username</label>
    <div class="error-text">Username is already taken.</div>
  </div>

  <script>
    function togglePassword() {
      const passInput = document.getElementById("password");
      passInput.type = passInput.type === "password" ? "text" : "password";
    }
  </script>
</body>
</html>
</file>

<file path="packages/backend/src/config/languageConfig.ts">
export const LanguageConfig = {
    DEFAULT_LANGUAGE: 'en',
    SUPPORTED_LANGUAGES: [
        { code: 'en', name: 'English' },
        { code: 'sq', name: 'Albanian' },
        { code: 'am', name: 'Amharic' },
        { code: 'ar', name: 'Arabic' },
        { code: 'hy', name: 'Armenian' },
        { code: 'bn', name: 'Bengali' },
        { code: 'bs', name: 'Bosnian' },
        { code: 'bg', name: 'Bulgarian' },
        { code: 'my', name: 'Burmese' },
        { code: 'ca', name: 'Catalan' },
        { code: 'zh', name: 'Chinese' },
        { code: 'hr', name: 'Croatian' },
        { code: 'cs', name: 'Czech' },
        { code: 'da', name: 'Danish' },
        { code: 'nl', name: 'Dutch' },
        { code: 'et', name: 'Estonian' },
        { code: 'fi', name: 'Finnish' },
        { code: 'fr', name: 'French' },
        { code: 'ka', name: 'Georgian' },
        { code: 'de', name: 'German' },
        { code: 'el', name: 'Greek' },
        { code: 'gu', name: 'Gujarati' },
        { code: 'hi', name: 'Hindi' },
        { code: 'hu', name: 'Hungarian' },
        { code: 'is', name: 'Icelandic' },
        { code: 'id', name: 'Indonesian' },
        { code: 'it', name: 'Italian' },
        { code: 'ja', name: 'Japanese' },
        { code: 'kn', name: 'Kannada' },
        { code: 'kk', name: 'Kazakh' },
        { code: 'ko', name: 'Korean' },
        { code: 'lv', name: 'Latvian' },
        { code: 'lt', name: 'Lithuanian' },
        { code: 'mk', name: 'Macedonian' },
        { code: 'ms', name: 'Malay' },
        { code: 'ml', name: 'Malayalam' },
        { code: 'mr', name: 'Marathi' },
        { code: 'mn', name: 'Mongolian' },
        { code: 'no', name: 'Norwegian' },
        { code: 'fa', name: 'Persian' },
        { code: 'pl', name: 'Polish' },
        { code: 'pt', name: 'Portuguese' },
        { code: 'pa', name: 'Punjabi' },
        { code: 'ro', name: 'Romanian' },
        { code: 'ru', name: 'Russian' },
        { code: 'sr', name: 'Serbian' },
        { code: 'sk', name: 'Slovak' },
        { code: 'sl', name: 'Slovenian' },
        { code: 'so', name: 'Somali' },
        { code: 'es', name: 'Spanish' },
        { code: 'sw', name: 'Swahili' },
        { code: 'sv', name: 'Swedish' },
        { code: 'tl', name: 'Tagalog' },
        { code: 'ta', name: 'Tamil' },
        { code: 'te', name: 'Telugu' },
        { code: 'th', name: 'Thai' },
        { code: 'tr', name: 'Turkish' },
        { code: 'uk', name: 'Ukrainian' },
        { code: 'ur', name: 'Urdu' },
        { code: 'vi', name: 'Vietnamese' }
    ]
};

export const DEFAULT_ACTIVE_LANGUAGES = ['en', 'es', 'fr', 'zh'];

export const isValidLanguageCode = (code: string): boolean => {
    return LanguageConfig.SUPPORTED_LANGUAGES.some(lang => lang.code === code);
};

export const getLanguageName = (code: string): string => {
    const language = LanguageConfig.SUPPORTED_LANGUAGES.find(lang => lang.code === code);
    return language ? language.name : code;
};

export const getDefaultLanguages = () => {
    return LanguageConfig.SUPPORTED_LANGUAGES.map(lang => ({
        ...lang,
        active: DEFAULT_ACTIVE_LANGUAGES.includes(lang.code)
    }));
};
</file>

<file path="packages/backend/src/middleware/errorHandler.ts">
import { Request, Response, NextFunction } from 'express';
import { ApiError, isApiError } from '../utils/ApiError';
import { SettingsValidationError } from '../utils/ApiError';

export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  // Handle known ApiError types
  if (isApiError(err)) {
    return res.status(err.statusCode).json({
      success: false,
      status: err.statusCode,
      message: err.message,
      stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
  }

  // Handle settings-specific errors
  if (err instanceof SettingsValidationError) {
    return res.status(400).json({
      success: false,
      status: 400,
      message: err.message,
      stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
  }

  // Handle unknown errors
  return res.status(500).json({
    success: false,
    status: 500,
    message: 'Internal Server Error',
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
  });
};
</file>

<file path="packages/backend/src/middleware/requestLogger.ts">
import { Request, Response, NextFunction } from 'express';

export const requestLogger = (req: Request, res: Response, next: NextFunction) => {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] ${req.method} ${req.url}`);
  next();
};
</file>

<file path="packages/backend/src/routes/categoryRoutes.ts">
import { Router } from 'express';
import { CategoryService } from '../services/CategoryService';
import { ApiResponse } from '../utils/ApiResponse';
import { ApiError } from '../utils/ApiError';

const router = Router();
const categoryService = new CategoryService();

// GET /categories
router.get('/', async (req, res, next) => {
    try {
        const categories = await categoryService.findAll();
        res.json(ApiResponse.success(categories));
    } catch (error) {
        next(error);
    }
});

// GET /categories/:id
router.get('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid category ID');
        }

        const category = await categoryService.findById(id);
        if (!category) {
            throw new ApiError(404, 'Category not found');
        }

        res.json(ApiResponse.success(category));
    } catch (error) {
        next(error);
    }
});

// POST /categories
router.post('/', async (req, res, next) => {
    try {
        const { name, itemLimit = 0 } = req.body;
        if (!name || name.trim() === '') {
            throw new ApiError(400, 'Category name is required');
        }

        const parsedLimit = parseInt(itemLimit);
        if (isNaN(parsedLimit) || parsedLimit < 0) {
            throw new ApiError(400, 'Item limit must be a non-negative number');
        }

        const category = await categoryService.create({ 
            name: name.trim(), 
            itemLimit: parsedLimit 
        });

        res.status(201).json(ApiResponse.success(category, 'Category created successfully'));
    } catch (error) {
        next(error);
    }
});

// PUT /categories/:id
router.put('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid category ID');
        }

        const { name, itemLimit } = req.body;
        const updateData: { name?: string; itemLimit?: number } = {};

        if (name !== undefined) {
            if (name.trim() === '') {
                throw new ApiError(400, 'Category name cannot be empty');
            }
            updateData.name = name.trim();
        }

        if (itemLimit !== undefined) {
            const parsedLimit = parseInt(itemLimit);
            if (isNaN(parsedLimit) || parsedLimit < 0) {
                throw new ApiError(400, 'Item limit must be a non-negative number');
            }
            updateData.itemLimit = parsedLimit;
        }

        const category = await categoryService.update(id, updateData);
        res.json(ApiResponse.success(category, 'Category updated successfully'));
    } catch (error) {
        next(error);
    }
});

// DELETE /categories/:id
router.delete('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid category ID');
        }

        await categoryService.delete(id);
        res.json(ApiResponse.success(null, 'Category deleted successfully'));
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="packages/backend/src/routes/foodItemRoutes.ts">
import { Router } from 'express';
import { FoodItemService } from '../services/FoodItemService';
import { ApiResponse } from '../utils/ApiResponse';
import { ApiError } from '../utils/ApiError';

const router = Router();
const foodItemService = new FoodItemService();

// GET /food-items
router.get('/', async (req, res, next) => {
  try {
    const { categoryId, includeOutOfStock, page, limit } = req.query;
    
    const params = {
      categoryId: categoryId ? parseInt(categoryId as string) : undefined,
      includeOutOfStock: includeOutOfStock === 'true',
      page: page ? parseInt(page as string) : 1,
      limit: limit ? parseInt(limit as string) : 50
    };

    const items = await foodItemService.findAll(params);
    return res.json(ApiResponse.success(items));
  } catch (error) {
    next(error);
  }
});

// GET /food-items/:id
router.get('/:id', async (req, res, next) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      throw new ApiError(400, 'Invalid food item ID');
    }

    const foodItem = await foodItemService.findById(id);
    res.json(ApiResponse.success(foodItem));
  } catch (error) {
    next(error);
  }
});

// POST /food-items
router.post('/', async (req, res, next) => {
  try {
    const { 
      name, 
      categoryId,
      itemLimit,
      inStock,
      mustGo,
      lowSupply,
      kosher,
      halal,
      vegetarian,
      vegan,
      glutenFree,
      organic,
      readyToEat,
      customFields 
    } = req.body;

    if (!name || typeof name !== 'string') {
      throw new ApiError(400, 'Name is required and must be a string');
    }

    if (!categoryId || typeof categoryId !== 'number') {
      throw new ApiError(400, 'Valid category ID is required');
    }

    const foodItem = await foodItemService.create({
      name,
      categoryId,
      itemLimit,
      inStock,
      mustGo,
      lowSupply,
      kosher,
      halal,
      vegetarian,
      vegan,
      glutenFree,
      organic,
      readyToEat,
      customFields
    });

    res.status(201).json(ApiResponse.success(foodItem, 'Food item created successfully'));
  } catch (error) {
    next(error);
  }
});

// PUT /food-items/:id
router.put('/:id', async (req, res, next) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      throw new ApiError(400, 'Invalid food item ID');
    }

    console.log('Update Food Item - Request Body:', req.body);
    console.log('Update Food Item - ID:', id);

    // Check if the item exists
    const existingItem = await foodItemService.findById(id);
    if (!existingItem) {
      throw new ApiError(404, 'Food item not found');
    }

    console.log('Existing Item Found:', existingItem);

    // Type check categoryId
    if (req.body.categoryId && typeof req.body.categoryId !== 'number') {
      console.log('Invalid categoryId type:', typeof req.body.categoryId);
      throw new ApiError(400, 'Category ID must be a number');
    }

    // Validate update data
    const updateData = {
      name: req.body.name,
      categoryId: req.body.categoryId,
      itemLimit: req.body.itemLimit,
      limitType: req.body.limitType,
      inStock: req.body.inStock,
      mustGo: req.body.mustGo,
      lowSupply: req.body.lowSupply,
      kosher: req.body.kosher,
      halal: req.body.halal,
      vegetarian: req.body.vegetarian,
      vegan: req.body.vegan,
      glutenFree: req.body.glutenFree,
      organic: req.body.organic,
      readyToEat: req.body.readyToEat
    };

    console.log('Processed Update Data:', updateData);

    const foodItem = await foodItemService.update(id, updateData);
    console.log('Update Successful:', foodItem);

    res.json(ApiResponse.success(foodItem, 'Food item updated successfully'));
  } catch (error) {
    console.error('Update Error:', error);
    next(error);
  }
});

// DELETE /food-items/:id
router.delete('/:id', async (req, res, next) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      throw new ApiError(400, 'Invalid food item ID');
    }

    // Check if the item exists
    const existingItem = await foodItemService.findById(id);
    if (!existingItem) {
      throw new ApiError(404, 'Food item not found');
    }

    await foodItemService.delete(id);
    res.json(ApiResponse.success(null, 'Food item deleted successfully'));
  } catch (error) {
    next(error);
  }
});

export default router;
</file>

<file path="packages/backend/src/routes/languageRoutes.ts">
import { Router } from 'express';
import { LanguageService } from '../services/LanguageService';
import { ApiResponse } from '../utils/ApiResponse';
import { ApiError } from '../utils/ApiError';

const router = Router();
const languageService = new LanguageService();

// GET /api/languages
router.get('/', async (req, res, next) => {
    try {
        console.log('GET /api/languages - Starting request');
        const languages = await languageService.findAll();
        console.log(`GET /api/languages - Found ${languages.length} languages`);
        res.json(ApiResponse.success(languages));
    } catch (error) {
        console.error('GET /api/languages - Error:', error);
        next(error);
    }
});

// POST /api/languages/bulk
router.post('/bulk', async (req, res, next) => {
    try {
        console.log('POST /api/languages/bulk - Starting request');
        const { languages } = req.body;
        
        if (!Array.isArray(languages)) {
            throw new ApiError(400, 'Invalid languages data');
        }

        const updatedLanguages = await languageService.bulkUpdate(languages);
        console.log(`POST /api/languages/bulk - Updated ${updatedLanguages.length} languages`);
        res.json(ApiResponse.success(updatedLanguages, 'Languages updated successfully'));
    } catch (error) {
        console.error('POST /api/languages/bulk - Error:', error);
        next(error);
    }
});

// GET /api/languages/active
router.get('/active', async (req, res, next) => {
    try {
        console.log('GET /api/languages/active - Starting request');
        const languages = await languageService.findActive();
        console.log(`GET /api/languages/active - Found ${languages.length} active languages`);
        res.json(ApiResponse.success(languages));
    } catch (error) {
        console.error('GET /api/languages/active - Error:', error);
        next(error);
    }
});

export default router;
</file>

<file path="packages/backend/src/routes/settingsRoutes.ts">
import { Router } from 'express';
import { PrismaClient } from '@prisma/client';
import { ApiResponse } from '../utils/ApiResponse';
import { SettingsValidationError } from '../utils/ApiError';

const router = Router();
const prisma = new PrismaClient();

// GET /api/settings
router.get('/', async (req, res, next) => {
    try {
        const settings = await prisma.settings.findUnique({
            where: { id: 1 }
        });

        // If no settings exist, return default value of 10
        if (!settings) {
            return res.json(ApiResponse.success({
                globalUpperLimit: 10
            }));
        }

        res.json(ApiResponse.success({
            globalUpperLimit: settings.globalUpperLimit
        }));
    } catch (error) {
        next(error);
    }
});

// POST /api/settings
router.post('/', async (req, res, next) => {
    try {
        const { globalUpperLimit } = req.body;

        // Validate input
        if (globalUpperLimit === undefined || globalUpperLimit === null) {
            throw new SettingsValidationError('Global upper limit is required');
        }

        if (typeof globalUpperLimit !== 'number' || !Number.isInteger(globalUpperLimit)) {
            throw new SettingsValidationError('Global upper limit must be an integer');
        }

        if (globalUpperLimit < 1) {
            throw new SettingsValidationError('Global upper limit must be at least 1');
        }

        const settings = await prisma.settings.upsert({
            where: { id: 1 },
            update: {
                globalUpperLimit,
                updatedAt: new Date()
            },
            create: {
                globalUpperLimit,
                id: 1
            }
        });

        res.json(ApiResponse.success(settings, 'Settings updated successfully'));
    } catch (error) {
        next(error);
    } finally {
        await prisma.$disconnect(); // Ensure Prisma disconnects after handling the request
    }
});

export default router;
</file>

<file path="packages/backend/src/routes/translationRoutes.ts">
import { Router } from 'express';
import { TranslationService } from '../services/TranslationService';
import { ApiResponse } from '../utils/ApiResponse';
import { ApiError } from '../utils/ApiError';

const router = Router();
const translationService = new TranslationService();

// GET /translations
router.get('/', async (req, res, next) => {
    try {
        const { languageCode, categoryId, foodItemId, type } = req.query;
        console.log('Translation query params:', { languageCode, categoryId, foodItemId, type });

        if (type && !['category', 'foodItem', 'customInput'].includes(type as string)) {
            throw new ApiError(400, 'Invalid type parameter. Must be "category", "foodItem", or "customInput"');
        }

        const params = {
            languageCode: languageCode as string,
            categoryId: categoryId ? parseInt(categoryId as string) : undefined,
            foodItemId: foodItemId ? parseInt(foodItemId as string) : undefined,
            type: type as 'category' | 'foodItem' | 'customInput' | undefined
        };
        console.log('Processed params:', params);

        const translations = await translationService.findAll(params);
        console.log('Found translations:', translations);

        res.json(ApiResponse.success(translations));
    } catch (error) {
        console.error('Translation error:', error);
        next(error);
    }
});

// GET /translations/custom
router.get('/custom', async (req, res, next) => {
    try {
        const { languageCode } = req.query;
        const translations = await translationService.findCustom(languageCode as string);
        res.json(ApiResponse.success(translations));
    } catch (error) {
        next(error);
    }
});

// GET /translations/language/:languageCode
router.get('/language/:languageCode', async (req, res, next) => {
    try {
        const { languageCode } = req.params;
        const { categoryId, foodItemId } = req.query;

        const params = {
            categoryId: categoryId ? parseInt(categoryId as string) : undefined,
            foodItemId: foodItemId ? parseInt(foodItemId as string) : undefined
        };

        const translations = await translationService.findByLanguage(languageCode, params);
        res.json(ApiResponse.success(translations));
    } catch (error) {
        next(error);
    }
});

// POST /translations/custom
router.post('/custom', async (req, res, next) => {
    try {
        const { text, languageCode } = req.body;
        if (!text || !languageCode) {
            throw new ApiError(400, 'Text and language code are required');
        }

        const translation = await translationService.createCustom(text, languageCode);
        res.status(201).json(ApiResponse.success(translation, 'Custom translation created successfully'));
    } catch (error) {
        next(error);
    }
});

// POST /translations/category/:categoryId
router.post('/category/:categoryId', async (req, res, next) => {
    try {
        const categoryId = parseInt(req.params.categoryId);
        if (isNaN(categoryId)) {
            throw new ApiError(400, 'Invalid category ID');
        }

        const { languageCode, translatedText } = req.body;
        if (!languageCode || !translatedText) {
            throw new ApiError(400, 'Language code and translated text are required');
        }

        const translation = await translationService.createForCategory(categoryId, {
            languageCode,
            translatedText
        });

        res.status(201).json(ApiResponse.success(translation, 'Translation created successfully'));
    } catch (error) {
        next(error);
    }
});

// POST /translations/food-item/:foodItemId
router.post('/food-item/:foodItemId', async (req, res, next) => {
    try {
        const foodItemId = parseInt(req.params.foodItemId);
        if (isNaN(foodItemId)) {
            throw new ApiError(400, 'Invalid food item ID');
        }

        const { languageCode, translatedText } = req.body;
        if (!languageCode || !translatedText) {
            throw new ApiError(400, 'Language code and translated text are required');
        }

        const translation = await translationService.createForFoodItem(foodItemId, {
            languageCode,
            translatedText
        });

        res.status(201).json(ApiResponse.success(translation, 'Translation created successfully'));
    } catch (error) {
        next(error);
    }
});

// GET /translations/:id
router.get('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid translation ID');
        }

        const translation = await translationService.findById(id);
        res.json(ApiResponse.success(translation));
    } catch (error) {
        next(error);
    }
});

// PUT /translations/:id
router.put('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid translation ID');
        }

        const translation = await translationService.findById(id);
        if (!translation) {
            throw new ApiError(404, 'Translation not found');
        }

        const { translatedText } = req.body;
        if (!translatedText) {
            throw new ApiError(400, 'Translated text is required');
        }

        const updatedTranslation = await translationService.update(id, { translatedText });
        res.json(ApiResponse.success(updatedTranslation, 'Translation updated successfully'));
    } catch (error) {
        next(error);
    }
});

// DELETE /translations/:id
router.delete('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid translation ID');
        }

        const translation = await translationService.findById(id);
        if (!translation) {
            throw new ApiError(404, 'Translation not found');
        }

        await translationService.delete(id);
        res.json(ApiResponse.success(null, 'Translation deleted successfully'));
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="packages/backend/src/services/openai/__tests__/OpenAIService.test.ts">
import { OpenAIService } from '../OpenAIService';
import { ApiError } from '../../../utils/ApiError';

// Mock OpenAI responses
const mockCreateCompletion = jest.fn();
jest.mock('openai', () => ({
    OpenAI: jest.fn().mockImplementation(() => ({
        chat: {
            completions: {
                create: mockCreateCompletion
            }
        }
    }))
}));

describe('OpenAIService', () => {
    let service: OpenAIService;

    beforeEach(() => {
        process.env.OPENAI_API_KEY = 'test-key';
        process.env.OPENAI_MODEL = 'gpt-4o-mini';
        mockCreateCompletion.mockClear();
        service = new OpenAIService();
    });

    describe('initialization', () => {
        it('should initialize with valid API key', () => {
            expect(() => new OpenAIService()).not.toThrow();
        });

        it('should throw error when API key is missing', () => {
            delete process.env.OPENAI_API_KEY;
            expect(() => new OpenAIService()).toThrow('OpenAI API key is not configured');
        });
    });

    describe('translateText', () => {
        beforeEach(() => {
            mockCreateCompletion.mockResolvedValue({
                choices: [{ message: { content: 'manzana', role: 'assistant' } }]
            });
        });

        it('should translate text successfully', async () => {
            const result = await service.translateText('apple', 'es', 'foodItem');
            expect(result).toBe('manzana');
            expect(mockCreateCompletion).toHaveBeenCalledWith(expect.objectContaining({
                temperature: 0.3,
                max_tokens: 100
            }));
        });

        it('should handle empty responses', async () => {
            mockCreateCompletion.mockResolvedValue({
                choices: [{ message: { content: '', role: 'assistant' } }]
            });
            await expect(service.translateText('apple', 'es', 'foodItem'))
                .rejects
                .toThrow('Translation failed - empty response');
        });

        it('should handle API errors', async () => {
            mockCreateCompletion.mockRejectedValue(new Error('API Error'));
            await expect(service.translateText('apple', 'es', 'foodItem'))
                .rejects
                .toThrow('Translation failed: API Error');
        });
    });

    describe('testConnection', () => {
        it('should return true for successful connection', async () => {
            mockCreateCompletion.mockResolvedValue({
                choices: [{ message: { content: 'OK', role: 'assistant' } }]
            });
            const result = await service.testConnection();
            expect(result).toBe(true);
        });

        it('should return false for failed connection', async () => {
            mockCreateCompletion.mockRejectedValue(new Error('Connection failed'));
            const result = await service.testConnection();
            expect(result).toBe(false);
        });
    });

    describe('bulkTranslate', () => {
        const testItems = [
            { id: 1, text: 'apple' },
            { id: 2, text: 'banana' }
        ];

        beforeEach(() => {
            mockCreateCompletion
                .mockResolvedValueOnce({
                    choices: [{ message: { content: 'manzana', role: 'assistant' } }]
                })
                .mockResolvedValueOnce({
                    choices: [{ message: { content: 'plátano', role: 'assistant' } }]
                });
        });

        it('should translate multiple items successfully', async () => {
            const results = await service.bulkTranslate(testItems, 'es', 'foodItem');
            expect(results).toEqual([
                { id: 1, translation: 'manzana' },
                { id: 2, translation: 'plátano' }
            ]);
        });

        it('should handle partial failures in bulk translation', async () => {
            mockCreateCompletion
                .mockResolvedValueOnce({
                    choices: [{ message: { content: 'manzana', role: 'assistant' } }]
                })
                .mockRejectedValueOnce(new Error('API Error'));

            const results = await service.bulkTranslate(testItems, 'es', 'foodItem');
            expect(results).toEqual([
                { id: 1, translation: 'manzana' },
                { id: 2, translation: '' }
            ]);
        });

        it('should respect rate limiting with delays', async () => {
            const startTime = Date.now();
            await service.bulkTranslate(testItems, 'es', 'foodItem');
            const duration = Date.now() - startTime;
            expect(duration).toBeGreaterThanOrEqual(200); // At least 200ms delay
        });
    });
});
</file>

<file path="packages/backend/src/services/openai/OpenAIService.ts">
import { OpenAI } from 'openai';
import { ApiError } from '../../utils/ApiError';
import { LanguageConfig, getLanguageName } from '../../config/languageConfig';

export class OpenAIService {
    private client: OpenAI;
    private readonly maxRetries = 3;
    private readonly retryDelay = 1000; // 1 second

    constructor() {
        if (!process.env.OPENAI_API_KEY) {
            throw new ApiError(500, 'OpenAI API key is not configured');
        }
        this.client = new OpenAI({ 
            apiKey: process.env.OPENAI_API_KEY,
            maxRetries: this.maxRetries
        });
    }

    async translateText(
        text: string, 
        targetLanguage: string, 
        context: 'category' | 'foodItem' | 'customInput'
    ): Promise<string> {
        const languageName = getLanguageName(targetLanguage);
        
        try {
            const systemPrompt = this.buildSystemPrompt(context, languageName);
            const response = await this.client.chat.completions.create({
                model: process.env.OPENAI_MODEL || 'gpt-4o-mini',
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: text }
                ],
                temperature: 0.3, // Lower temperature for more consistent translations
                max_tokens: 100  // Limit response length for efficiency
            });

            const translation = response.choices[0]?.message?.content?.trim();
            if (!translation) {
                throw new ApiError(500, 'Translation failed - empty response');
            }

            return translation;
        } catch (error) {
            console.error('Translation error:', error);
            throw new ApiError(500, `Translation failed: ${(error as Error).message}`);
        }
    }

    private buildSystemPrompt(context: 'category' | 'foodItem' | 'customInput', languageName: string): string {
        const contextPrompts = {
            category: `You are a professional translator for grocery/pharmacy categories. Translate to ${languageName}. Output only translation.`,
            foodItem: `translator for grocery/pharmacy items. Translate to ${languageName}. Output only translation.`,
            customInput: `You are a professional translator for nonprofit food pantry and social services. Translate to ${languageName}. Output only translation.`
        };

        return contextPrompts[context];
    }

    async testConnection(): Promise<boolean> {
        try {
            const response = await this.client.chat.completions.create({
                model: process.env.OPENAI_MODEL || 'gpt-4o-mini',
                messages: [
                    { role: 'system', content: 'Respond with "OK" if you can read this.' },
                    { role: 'user', content: 'Connection test' }
                ],
                max_tokens: 5
            });
            
            return response.choices[0]?.message?.content?.includes('OK') ?? false;
        } catch (error) {
            console.error('OpenAI connection test failed:', error);
            return false;
        }
    }

    async bulkTranslate(
        items: Array<{ id: number; text: string }>, 
        targetLanguage: string, 
        context: 'category' | 'foodItem' | 'customInput'
    ): Promise<Array<{ id: number; translation: string }>> {
        const results = [];
        
        for (const item of items) {
            try {
                const translation = await this.translateText(item.text, targetLanguage, context);
                results.push({ id: item.id, translation });
                // Add small delay between requests to respect rate limits
                await new Promise(resolve => setTimeout(resolve, 200));
            } catch (error) {
                console.error(`Translation failed for item ${item.id}:`, error);
                results.push({ id: item.id, translation: '' });
            }
        }

        return results;
    }
}
</file>

<file path="packages/backend/src/services/CategoryService.ts">
import { PrismaClient, Category } from '@prisma/client';
import { ApiError } from '../utils/ApiError';
import { TranslationService } from './TranslationService';
import { ErrorTypes, ErrorMessages } from '../utils/errorConstants';
import { handleServiceError } from '../utils/errorHandler';
import { ValidationUtils } from '../utils/validationUtils';

export class CategoryService {
    private prisma: PrismaClient;
    private translationService: TranslationService;

    constructor() {
        this.prisma = new PrismaClient();
        this.translationService = new TranslationService();
    }

    async create(data: { name: string; itemLimit?: number }): Promise<Category> {
        try {
            // Validate name
            const validationResult = await ValidationUtils.validateInput(data.name, 'category');
            if (!validationResult.isValid) {
                throw new ApiError(400, validationResult.error || 'Invalid input');
            }

            // Validate itemLimit
            if (data.itemLimit !== undefined) {
                if (data.itemLimit < 0) {
                    throw new ApiError(400, 'Item limit cannot be negative');
                }
            }

            const category = await this.prisma.category.create({
                data: {
                    name: validationResult.normalizedValue!,
                    itemLimit: data.itemLimit || 0
                },
                include: {
                    translations: {
                        include: {
                            language: true
                        }
                    }
                }
            });

            this.translationService.generateAutomaticTranslations(category.id, 'category')
                .catch(error => console.error('Translation generation failed:', error));

            return category;
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.CREATE_ERROR('category'));
        }
    }

    async findAll(): Promise<Category[]> {
        try {
            return await this.prisma.category.findMany({
                include: {
                    translations: {
                        include: {
                            language: true
                        }
                    }
                }
            });
        } catch (error) {
            throw handleServiceError(error, 'Error fetching categories');
        }
    }

    async findById(id: number): Promise<Category | null> {
        try {
            const category = await this.prisma.category.findUnique({
                where: { id },
                include: {
                    translations: {
                        include: {
                            language: true
                        }
                    }
                }
            });

            if (!category) {
                throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.CATEGORY_NOT_FOUND);
            }

            return category;
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.CATEGORY_NOT_FOUND);
        }
    }

    async update(id: number, data: { name?: string; itemLimit?: number }): Promise<Category> {
        try {
            const existingCategory = await this.findById(id);

            if (data.name) {
                // Validate name
                const validationResult = await ValidationUtils.validateInput(data.name, 'category', id);
                if (!validationResult.isValid) {
                    throw new ApiError(400, validationResult.error || 'Invalid input');
                }
                data.name = validationResult.normalizedValue!;
            }

            // Validate itemLimit
            if (data.itemLimit !== undefined) {
                if (data.itemLimit < 0) {
                    throw new ApiError(400, 'Item limit cannot be negative');
                }
            }

            const updated = await this.prisma.category.update({
                where: { id },
                data: {
                    name: data.name,
                    itemLimit: data.itemLimit
                },
                include: {
                    translations: {
                        include: {
                            language: true
                        }
                    }
                }
            });

            if (existingCategory && data.name && data.name !== existingCategory.name) {
                this.translationService.generateAutomaticTranslations(id, 'category')
                    .catch(error => console.error('Translation update failed:', error));
            }

            return updated;
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.UPDATE_ERROR('category'));
        }
    }

    async delete(id: number): Promise<void> {
        try {
            await this.findById(id);
            await this.prisma.category.delete({ where: { id } });
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.DELETE_ERROR('category'));
        }
    }
}
</file>

<file path="packages/backend/src/services/FoodItemService.ts">
import { PrismaClient, FoodItem, Prisma } from '@prisma/client';
import { ApiError } from '../utils/ApiError';
import { TranslationService } from './TranslationService';
import { ErrorTypes, ErrorMessages } from '../utils/errorConstants';
import { handleServiceError } from '../utils/errorHandler';
import { ValidationUtils } from '../utils/validationUtils';

type FoodItemCreateInput = Prisma.FoodItemCreateInput;
type FoodItemUpdateInput = Prisma.FoodItemUpdateInput;

export class FoodItemService {
  private prisma: PrismaClient;
  private translationService: TranslationService;
  private testMode: boolean;

  constructor(testMode = false) {
    this.prisma = new PrismaClient();
    this.translationService = new TranslationService();
    this.testMode = testMode;
  }

  private async generateTranslations(foodItemId: number): Promise<void> {
    if (this.testMode) return;
    try {
      await this.translationService.generateAutomaticTranslations(foodItemId, 'foodItem');
    } catch (error) {
      console.error(`Failed to generate translations for food item ${foodItemId}:`, error);
    }
  }

  async create(data: {
    name: string;
    categoryId: number;
    imageUrl?: string;
    thumbnailUrl?: string;
    itemLimit?: number;
    limitType?: string;
    inStock?: boolean;
    mustGo?: boolean;
    lowSupply?: boolean;
    kosher?: boolean;
    halal?: boolean;
    vegetarian?: boolean;
    vegan?: boolean;
    glutenFree?: boolean;
    organic?: boolean;
    readyToEat?: boolean;
    customFields?: { key: string; value: string; }[];
  }): Promise<FoodItem> {
    try {
      // Validate name
      const validationResult = await ValidationUtils.validateInput(data.name, 'foodItem');
      if (!validationResult.isValid) {
        throw new ApiError(400, validationResult.error || 'Invalid input');
      }

      const category = await this.prisma.category.findUnique({
        where: { id: data.categoryId }
      });

      if (!category) {
        throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_CATEGORY);
      }

      const { customFields, categoryId, ...foodItemData } = data;

      const createData: FoodItemCreateInput = {
        ...foodItemData,
        name: validationResult.normalizedValue!,
        limitType: foodItemData.limitType || 'perHousehold',
        category: {
          connect: { id: categoryId }
        },
        customFields: customFields ? {
          create: customFields
        } : undefined
      };

      const foodItem = await this.prisma.foodItem.create({
        data: createData,
        include: {
          category: true,
          translations: {
            include: {
              language: true
            }
          },
          customFields: true
        }
      });

      this.generateTranslations(foodItem.id);

      return foodItem;
    } catch (error) {
      throw handleServiceError(error, ErrorMessages.CREATE_ERROR('food item'));
    }
  }

  async update(id: number, data: {
    name?: string;
    categoryId?: number;
    imageUrl?: string;
    thumbnailUrl?: string;
    itemLimit?: number;
    limitType?: string;
    inStock?: boolean;
    mustGo?: boolean;
    lowSupply?: boolean;
    kosher?: boolean;
    halal?: boolean;
    vegetarian?: boolean;
    vegan?: boolean;
    glutenFree?: boolean;
    organic?: boolean;
    readyToEat?: boolean;
    customFields?: { key: string; value: string; }[];
  }): Promise<FoodItem> {
    try {
      const existingItem = await this.prisma.foodItem.findUnique({
        where: { id },
        include: { customFields: true }
      });

      if (!existingItem) {
        throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.FOOD_ITEM_NOT_FOUND);
      }

      if (data.name) {
        const validationResult = await ValidationUtils.validateInput(data.name, 'foodItem', id);
        if (!validationResult.isValid) {
          throw new ApiError(400, validationResult.error || 'Invalid input');
        }
        data.name = validationResult.normalizedValue!;
      }

      if (data.categoryId) {
        const category = await this.prisma.category.findUnique({
          where: { id: data.categoryId }
        });

        if (!category) {
          throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_CATEGORY);
        }
      }

      const { customFields, categoryId, ...updateData } = data;

      const prismaUpdateData: FoodItemUpdateInput = {
        ...updateData,
        ...(categoryId && {
          category: {
            connect: { id: categoryId }
          }
        })
      };

      const updatedItem = await this.prisma.foodItem.update({
        where: { id },
        data: prismaUpdateData,
        include: {
          category: true,
          translations: {
            include: {
              language: true
            }
          },
          customFields: true
        }
      });

      if (data.name && data.name !== existingItem.name) {
        this.generateTranslations(id);
      }

      return updatedItem;
    } catch (error) {
      throw handleServiceError(error, ErrorMessages.UPDATE_ERROR('food item'));
    }
  }

  async findById(id: number): Promise<FoodItem | null> {
    try {
      const item = await this.prisma.foodItem.findUnique({
        where: { id },
        include: {
          category: true,
          translations: {
            include: {
              language: true
            }
          }
        }
      });

      if (!item) {
        throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.FOOD_ITEM_NOT_FOUND);
      }

      return item;
    } catch (error) {
      throw handleServiceError(error, ErrorMessages.FOOD_ITEM_NOT_FOUND);
    }
  }

  async findAll(params: {
    categoryId?: number;
    includeOutOfStock?: boolean;
  } = {}): Promise<FoodItem[]> {
    try {
      const { categoryId, includeOutOfStock = true } = params;
      
      return await this.prisma.foodItem.findMany({
        where: {
          ...(categoryId && { categoryId }),
          ...(!includeOutOfStock && { inStock: true })
        },
        include: {
          category: true,
          translations: {
            include: {
              language: true
            }
          }
        }
      });
    } catch (error) {
      throw handleServiceError(error, 'Error fetching food items');
    }
  }

  async delete(id: number): Promise<void> {
    try {
      const existingItem = await this.findById(id);
      if (!existingItem) {
        throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.FOOD_ITEM_NOT_FOUND);
      }

      await this.prisma.foodItem.delete({
        where: { id }
      });
    } catch (error) {
      throw handleServiceError(error, ErrorMessages.DELETE_ERROR('food item'));
    }
  }
}
</file>

<file path="packages/backend/src/services/LanguageService.ts">
import { PrismaClient, Language } from '@prisma/client';
import { ApiError } from '../utils/ApiError';
import { TranslationService } from './TranslationService';
import { LanguageConfig, getDefaultLanguages } from '../config/languageConfig';

export class LanguageService {
    private prisma: PrismaClient;
    private translationService: TranslationService;
    private static initializationPromise: Promise<void> | null = null;

    constructor() {
        this.prisma = new PrismaClient();
        this.translationService = new TranslationService();
    }

    private async initializeLanguages(): Promise<void> {
        if (LanguageService.initializationPromise) {
            await LanguageService.initializationPromise;
            return;
        }

        LanguageService.initializationPromise = (async () => {
            try {
                const count = await this.prisma.language.count();
                if (count === 0) {
                    console.log('Initializing default languages...');
                    const defaultLanguages = getDefaultLanguages();
                    
                    // Insert languages one by one to handle race conditions
                    for (const lang of defaultLanguages) {
                        await this.prisma.language.upsert({
                            where: { code: lang.code },
                            create: {
                                code: lang.code,
                                name: lang.name,
                                active: lang.active,
                                createdAt: new Date(),
                                updatedAt: new Date()
                            },
                            update: {} // No updates if exists
                        });
                    }
                    console.log('Default languages initialized successfully');
                }
            } catch (error) {
                console.error('Error initializing languages:', error);
                throw new ApiError(500, 'Error initializing languages');
            } finally {
                LanguageService.initializationPromise = null;
            }
        })();

        await LanguageService.initializationPromise;
    }

    async findAll(): Promise<Language[]> {
        try {
            await this.initializeLanguages();
            return await this.prisma.language.findMany({
                orderBy: { name: 'asc' }
            });
        } catch (error) {
            console.error('Error in findAll:', error);
            throw new ApiError(500, 'Error fetching languages');
        }
    }

    async bulkUpdate(languages: { code: string; name: string; }[]): Promise<Language[]> {
        try {
            await this.initializeLanguages();

            await this.prisma.language.updateMany({
                data: { active: false }
            });

            const operations = languages.map(lang => 
                this.prisma.language.update({
                    where: { code: lang.code },
                    data: { 
                        active: true,
                        updatedAt: new Date()
                    }
                })
            );

            await this.prisma.$transaction(operations);

            for (const lang of languages) {
                await this.generateTranslationsForLanguage(lang.code);
            }

            return this.findAll();
        } catch (error) {
            console.error('Error in bulkUpdate:', error);
            throw new ApiError(500, `Error updating languages: ${error.message}`);
        }
    }

    async findByCode(code: string): Promise<Language> {
        try {
            await this.initializeLanguages();
            const lang = await this.prisma.language.findUnique({
                where: { code }
            });
            if (!lang) {
                throw new ApiError(404, `Language '${code}' not found`);
            }
            return lang;
        } catch (error) {
            console.error('Error in findByCode:', error);
            if (error instanceof ApiError) throw error;
            throw new ApiError(500, `Error fetching language: ${error.message}`);
        }
    }

    async findActive(): Promise<Language[]> {
        try {
            await this.initializeLanguages();
            return await this.prisma.language.findMany({
                where: { active: true },
                orderBy: { name: 'asc' }
            });
        } catch (error) {
            console.error('Error in findActive:', error);
            throw new ApiError(500, `Error fetching active languages: ${error.message}`);
        }
    }

    private async generateTranslationsForLanguage(languageCode: string): Promise<void> {
        try {
            const [categories, foodItems] = await Promise.all([
                this.prisma.category.findMany(),
                this.prisma.foodItem.findMany()
            ]);

            for (const category of categories) {
                await this.translationService.generateAutomaticTranslations(
                    category.id,
                    'category'
                ).catch(error => {
                    console.error(`Failed to translate category ${category.id} to ${languageCode}:`, error);
                });
            }

            for (const item of foodItems) {
                await this.translationService.generateAutomaticTranslations(
                    item.id,
                    'foodItem'
                ).catch(error => {
                    console.error(`Failed to translate food item ${item.id} to ${languageCode}:`, error);
                });
            }
        } catch (error) {
            console.error(`Failed to generate translations for language ${languageCode}:`, error);
        }
    }
}
</file>

<file path="packages/backend/src/services/TranslationService.ts">
import { PrismaClient } from '@prisma/client';
import { ApiError } from '../utils/ApiError';
import { OpenAIService } from './openai/OpenAIService';
import { LanguageConfig } from '../config/languageConfig';
import { ErrorTypes, ErrorMessages } from '../utils/errorConstants';
import { handleServiceError } from '../utils/errorHandler';

type ItemType = 'category' | 'foodItem' | 'customInput';

interface CreateTranslationData {
    languageCode: string;
    translatedText: string;
    isAutomatic?: boolean;
}

export class TranslationService {
    private prisma: PrismaClient;
    private openAI: OpenAIService;

    constructor() {
        this.prisma = new PrismaClient();
        this.openAI = new OpenAIService();
    }

    async findAll(params: { 
        languageCode?: string; 
        categoryId?: number; 
        foodItemId?: number;
        type?: ItemType;
    }) {
        try {
            const whereClause: any = {
                AND: [
                    params.languageCode ? { language: { code: params.languageCode } } : {},
                    params.categoryId ? { categoryId: params.categoryId } : {},
                    params.foodItemId ? { foodItemId: params.foodItemId } : {}
                ]
            };

            if (params.type) {
                if (params.type === 'category') {
                    whereClause.AND.push({ categoryId: { not: null }, foodItemId: null });
                } else if (params.type === 'foodItem') {
                    whereClause.AND.push({ foodItemId: { not: null }, categoryId: null });
                } else if (params.type === 'customInput') {
                    whereClause.AND.push({ categoryId: null, foodItemId: null });
                }
            }

            return await this.prisma.translation.findMany({
                where: whereClause,
                include: { 
                    language: true,
                    category: true,
                    foodItem: true
                }
            });
        } catch (error) {
            throw handleServiceError(error, 'Error fetching translations');
        }
    }

    async findCustom(languageCode?: string) {
        try {
            const whereClause: any = {
                categoryId: null,
                foodItemId: null
            };

            if (languageCode) {
                whereClause.language = { code: languageCode };
            }

            return await this.prisma.translation.findMany({
                where: whereClause,
                include: {
                    language: true
                }
            });
        } catch (error) {
            throw handleServiceError(error, 'Error fetching custom translations');
        }
    }

    async findById(id: number) {
        try {
            const translation = await this.prisma.translation.findUnique({
                where: { id },
                include: { language: true }
            });

            if (!translation) {
                throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.TRANSLATION_NOT_FOUND);
            }

            return translation;
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.TRANSLATION_NOT_FOUND);
        }
    }

    async findByLanguage(languageCode: string, params: { categoryId?: number; foodItemId?: number }) {
        try {
            const language = await this.prisma.language.findFirst({
                where: { code: languageCode, active: true }
            });

            if (!language) {
                throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_LANGUAGE);
            }

            return await this.prisma.translation.findMany({
                where: {
                    languageId: language.id,
                    ...(params.categoryId && { categoryId: params.categoryId }),
                    ...(params.foodItemId && { foodItemId: params.foodItemId })
                },
                include: { language: true }
            });
        } catch (error) {
            throw handleServiceError(error, `Error fetching translations for language: ${languageCode}`);
        }
    }

    async createCustom(text: string, languageCode: string) {
        try {
            const language = await this.prisma.language.findFirst({
                where: { code: languageCode, active: true }
            });

            if (!language) {
                throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_LANGUAGE);
            }

            // Get translation from OpenAI
            const translatedText = await this.openAI.translateText(
                text,
                languageCode,
                'customInput'
            );

            // Store translation with original text in metadata
            return await this.prisma.translation.create({
                data: {
                    translatedText,
                    originalText: text,  // Store original text for reference
                    languageId: language.id,
                    isAutomatic: true
                },
                include: { language: true }
            });
        } catch (error) {
            throw handleServiceError(error, 'Error creating custom translation');
        }
    }

    async createForCategory(categoryId: number, data: CreateTranslationData) {
        try {
            const category = await this.prisma.category.findUnique({
                where: { id: categoryId }
            });

            if (!category) {
                throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.CATEGORY_NOT_FOUND);
            }

            const language = await this.prisma.language.findFirst({
                where: { code: data.languageCode, active: true }
            });

            if (!language) {
                throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_LANGUAGE);
            }

            const existingTranslation = await this.prisma.translation.findFirst({
                where: {
                    categoryId,
                    languageId: language.id
                }
            });

            if (existingTranslation) {
                return this.update(existingTranslation.id, { 
                    translatedText: data.translatedText,
                    isAutomatic: data.isAutomatic ?? false
                });
            }

            return await this.prisma.translation.create({
                data: {
                    translatedText: data.translatedText,
                    categoryId,
                    languageId: language.id,
                    isAutomatic: data.isAutomatic ?? false
                },
                include: { language: true }
            });
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.CREATE_ERROR('category translation'));
        }
    }

    async createForFoodItem(foodItemId: number, data: CreateTranslationData) {
        try {
            const foodItem = await this.prisma.foodItem.findUnique({
                where: { id: foodItemId }
            });

            if (!foodItem) {
                throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.FOOD_ITEM_NOT_FOUND);
            }

            const language = await this.prisma.language.findFirst({
                where: { code: data.languageCode, active: true }
            });

            if (!language) {
                throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_LANGUAGE);
            }

            const existingTranslation = await this.prisma.translation.findFirst({
                where: {
                    foodItemId,
                    languageId: language.id
                }
            });

            if (existingTranslation) {
                return this.update(existingTranslation.id, { 
                    translatedText: data.translatedText,
                    isAutomatic: data.isAutomatic ?? false
                });
            }

            return await this.prisma.translation.create({
                data: {
                    translatedText: data.translatedText,
                    foodItemId,
                    languageId: language.id,
                    isAutomatic: data.isAutomatic ?? false
                },
                include: { language: true }
            });
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.CREATE_ERROR('food item translation'));
        }
    }

    async update(id: number, data: { translatedText: string; isAutomatic?: boolean }) {
        try {
            const translation = await this.findById(id);

            return await this.prisma.translation.update({
                where: { id },
                data: {
                    translatedText: data.translatedText,
                    isAutomatic: data.isAutomatic ?? translation.isAutomatic
                },
                include: { language: true }
            });
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.UPDATE_ERROR('translation'));
        }
    }

    async generateAutomaticTranslations(itemId: number, itemType: ItemType) {
        try {
            const item = itemType === 'category' 
                ? await this.prisma.category.findUnique({ where: { id: itemId } })
                : await this.prisma.foodItem.findUnique({ where: { id: itemId } });

            if (!item) {
                throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages[itemType === 'category' ? 'CATEGORY_NOT_FOUND' : 'FOOD_ITEM_NOT_FOUND']);
            }

            const activeLanguages = await this.prisma.language.findMany({
                where: { active: true }
            });

            const results = [];
            for (const language of activeLanguages) {
                if (language.code === LanguageConfig.DEFAULT_LANGUAGE) continue;

                try {
                    const translation = await this.openAI.translateText(
                        item.name,
                        language.code,
                        itemType
                    );

                    const createMethod = itemType === 'category' 
                        ? this.createForCategory.bind(this)
                        : this.createForFoodItem.bind(this);

                    const savedTranslation = await createMethod(
                        itemId,
                        {
                            languageCode: language.code,
                            translatedText: translation,
                            isAutomatic: true
                        }
                    );

                    results.push(savedTranslation);
                } catch (error) {
                    console.error(`Failed translation for ${itemType} ${itemId} in ${language.code}:`, error);
                }
            }

            return results;
        } catch (error) {
            throw handleServiceError(error, 'Error generating automatic translations');
        }
    }

    async delete(id: number) {
        try {
            await this.findById(id);
            await this.prisma.translation.delete({
                where: { id }
            });
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.DELETE_ERROR('translation'));
        }
    }
}
</file>

<file path="packages/backend/src/tests/utils/dbHelpers.ts">
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export const cleanDatabase = async () => {
  await prisma.translation.deleteMany({});
  await prisma.customField.deleteMany({});
  await prisma.foodItem.deleteMany({});
  await prisma.category.deleteMany({});
  await prisma.language.deleteMany({});
  await prisma.settings.deleteMany({});
};

export const disconnectDatabase = async () => {
  await cleanDatabase();
  await prisma.$disconnect();
};

export { prisma };
</file>

<file path="packages/backend/src/tests/utils/testFactories.ts">
import { prisma } from './dbHelpers';

export const createTestCategory = async (name = 'Test Category') => {
  return prisma.category.create({
    data: { name }
  });
};

export const createTestFoodItem = async (categoryId: number, data = {}) => {
  return prisma.foodItem.create({
    data: {
      name: 'Test Food Item',
      categoryId,
      inStock: true,
      itemLimit: 0,
      limitType: 'perHousehold',
      ...data
    }
  });
};

export const createTestLanguage = async (data = {}) => {
  return prisma.language.create({
    data: {
      code: 'en',
      name: 'English',
      active: true,
      ...data
    }
  });
};

export const createTestTranslation = async (data: {
  categoryId?: number;
  foodItemId?: number;
  languageId: number;
}) => {
  return prisma.translation.create({
    data: {
      translatedText: 'Test Translation',
      ...data
    }
  });
};
</file>

<file path="packages/backend/src/tests/utils/testHelpers.ts">
import { Express } from 'express';
import request from 'supertest';

export const expectSuccessResponse = (response: request.Response) => {
  expect(response.body.success).toBe(true);
  expect(response.body.data).toBeDefined();
};

export const expectErrorResponse = (response: request.Response) => {
  expect(response.body.success).toBe(false);
  expect(response.body.error).toBeDefined();
};

export const testCrudEndpoints = (app: Express, baseUrl: string, validPayload: any) => {
  describe('CRUD Operations', () => {
    let createdId: number;

    it('should create resource', async () => {
      const response = await request(app)
        .post(baseUrl)
        .send(validPayload)
        .expect(201);

      expectSuccessResponse(response);
      createdId = response.body.data.id;
    });

    it('should get all resources', async () => {
      const response = await request(app)
        .get(baseUrl)
        .expect(200);

      expectSuccessResponse(response);
      expect(Array.isArray(response.body.data)).toBe(true);
    });

    it('should get specific resource', async () => {
      const response = await request(app)
        .get(`${baseUrl}/${createdId}`)
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.id).toBe(createdId);
    });

    it('should update resource', async () => {
      const response = await request(app)
        .put(`${baseUrl}/${createdId}`)
        .send(validPayload)
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.id).toBe(createdId);
    });

    it('should delete resource', async () => {
      await request(app)
        .delete(`${baseUrl}/${createdId}`)
        .expect(200);

      await request(app)
        .get(`${baseUrl}/${createdId}`)
        .expect(404);
    });
  });
};
</file>

<file path="packages/backend/src/tests/categoryRoutes.test.ts">
import { createApp } from '../index';
import { cleanDatabase } from './utils/dbHelpers';
import { createTestCategory } from './utils/testFactories';
import { expectSuccessResponse, expectErrorResponse, testCrudEndpoints } from './utils/testHelpers';
import request from 'supertest';

describe('Category Routes', () => {
  const app = createApp();
  
  beforeEach(async () => {
    await cleanDatabase();
  });

  // Test all CRUD endpoints
  testCrudEndpoints(app, '/api/categories', { name: 'Test Category' });

  // Additional category-specific tests
  describe('Category Validations', () => {
    it('should reject empty category name', async () => {
      const response = await request(app)
        .post('/api/categories')
        .send({ name: '' })
        .expect(400);

      expectErrorResponse(response);
    });

    it('should handle duplicate category names', async () => {
      const category = await createTestCategory('Duplicate');
      
      const response = await request(app)
        .post('/api/categories')
        .send({ name: 'Duplicate' })
        .expect(400);

      expectErrorResponse(response);
    });
  });
});
</file>

<file path="packages/backend/src/tests/CategoryService.test.ts">
import { CategoryService } from '../services/CategoryService';
import { ApiError } from '../utils/ApiError';

describe('CategoryService', () => {
  let categoryService: CategoryService;

  beforeEach(() => {
    categoryService = new CategoryService();
  });

  describe('create', () => {
    it('should create a new category', async () => {
      const testData = { name: 'Test Category' };
      const result = await categoryService.create(testData);
      
      expect(result).toBeDefined();
      expect(result.name).toBe(testData.name);
      expect(result.id).toBeDefined();
    });
  });

  describe('findAll', () => {
    it('should return all categories', async () => {
      // Create test categories
      await categoryService.create({ name: 'Category 1' });
      await categoryService.create({ name: 'Category 2' });

      const categories = await categoryService.findAll();
      
      expect(categories).toBeDefined();
      expect(Array.isArray(categories)).toBe(true);
      expect(categories.length).toBeGreaterThanOrEqual(2);
    });
  });

  describe('findById', () => {
    it('should find category by id', async () => {
      const created = await categoryService.create({ name: 'Test Category' });
      const found = await categoryService.findById(created.id);
      
      expect(found).toBeDefined();
      expect(found?.id).toBe(created.id);
      expect(found?.name).toBe(created.name);
    });

    it('should throw ApiError if category not found', async () => {
      await expect(categoryService.findById(-1))
        .rejects
        .toThrow(ApiError);
    });
  });

  describe('update', () => {
    it('should update category', async () => {
      const created = await categoryService.create({ name: 'Original Name' });
      const updated = await categoryService.update(created.id, { name: 'Updated Name' });
      
      expect(updated).toBeDefined();
      expect(updated.id).toBe(created.id);
      expect(updated.name).toBe('Updated Name');
    });
  });

  describe('delete', () => {
    it('should delete category', async () => {
      const created = await categoryService.create({ name: 'To Delete' });
      
      await expect(categoryService.delete(created.id))
        .resolves
        .not
        .toThrow();

      await expect(categoryService.findById(created.id))
        .rejects
        .toThrow(ApiError);
    });
  });
});
</file>

<file path="packages/backend/src/tests/foodItemRoutes.test.ts">
import { createApp } from '../index';
import { cleanDatabase } from './utils/dbHelpers';
import { createTestCategory, createTestFoodItem } from './utils/testFactories';
import { expectSuccessResponse, expectErrorResponse, testCrudEndpoints } from './utils/testHelpers';
import request from 'supertest';

describe('Food Item Routes', () => {
  const app = createApp();
  let testCategoryId: number;
  
  beforeEach(async () => {
    await cleanDatabase();
    const category = await createTestCategory();
    testCategoryId = category.id;
  });

  const validPayload = {
    name: 'Test Food Item',
    categoryId: 0, // Will be set in beforeAll
    inStock: true,
    itemLimit: 0,
    limitType: 'perHousehold'
  };

  beforeAll(() => {
    // Update payload with actual category ID
    validPayload.categoryId = testCategoryId;
  });

  // Test all CRUD endpoints
  testCrudEndpoints(app, '/api/food-items', validPayload);

  describe('Food Item Validations', () => {
    it('should reject empty name', async () => {
      const response = await request(app)
        .post('/api/food-items')
        .send({ ...validPayload, name: '' })
        .expect(400);

      expectErrorResponse(response);
    });

    it('should reject invalid category', async () => {
      const response = await request(app)
        .post('/api/food-items')
        .send({ ...validPayload, categoryId: -1 })
        .expect(400);

      expectErrorResponse(response);
    });

    it('should validate limit type', async () => {
      const response = await request(app)
        .post('/api/food-items')
        .send({ ...validPayload, limitType: 'invalid' })
        .expect(400);

      expectErrorResponse(response);
    });
  });

  describe('Stock Filtering', () => {
    beforeEach(async () => {
      await createTestFoodItem(testCategoryId, { inStock: true });
      await createTestFoodItem(testCategoryId, { inStock: false });
    });

    it('should filter out-of-stock items by default', async () => {
      const response = await request(app)
        .get('/api/food-items')
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.every((item: any) => item.inStock)).toBe(true);
    });

    it('should include out-of-stock items when requested', async () => {
      const response = await request(app)
        .get('/api/food-items?includeOutOfStock=true')
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.some((item: any) => !item.inStock)).toBe(true);
    });
  });
});
</file>

<file path="packages/backend/src/tests/FoodItemService.test.ts">
import { FoodItemService } from '../services/FoodItemService';
import { ApiError } from '../utils/ApiError';
import { cleanDatabase } from './utils/dbHelpers';
import { createTestCategory, createTestFoodItem } from './utils/testFactories';

describe('FoodItemService', () => {
  let foodItemService: FoodItemService;
  let testCategoryId: number;

  beforeEach(async () => {
    foodItemService = new FoodItemService();
    await cleanDatabase();
    const category = await createTestCategory();
    testCategoryId = category.id;
  });

  describe('create', () => {
    it('should create a food item', async () => {
      const testData = {
        name: 'Test Food',
        categoryId: testCategoryId,
        inStock: true,
        itemLimit: 0,
        limitType: 'perHousehold'
      };
      const result = await foodItemService.create(testData);
      
      expect(result).toBeDefined();
      expect(result.name).toBe(testData.name);
      expect(result.categoryId).toBe(testCategoryId);
      expect(result.id).toBeDefined();
    });

    it('should validate category exists', async () => {
      const testData = {
        name: 'Test Food',
        categoryId: -1,
        inStock: true,
        itemLimit: 0,
        limitType: 'perHousehold'
      };
      await expect(foodItemService.create(testData)).rejects.toThrow(ApiError);
    });
  });

  describe('findAll', () => {
    it('should return all food items', async () => {
      await createTestFoodItem(testCategoryId, { name: 'Food 1' });
      await createTestFoodItem(testCategoryId, { name: 'Food 2' });

      const items = await foodItemService.findAll();
      expect(items.length).toBeGreaterThanOrEqual(2);
    });

    it('should filter out-of-stock items', async () => {
      await createTestFoodItem(testCategoryId, { name: 'In Stock', inStock: true });
      await createTestFoodItem(testCategoryId, { name: 'Out of Stock', inStock: false });

      const items = await foodItemService.findAll({ includeOutOfStock: false });
      expect(items.every(item => item.inStock)).toBe(true);
    });
  });

  describe('findById', () => {
    it('should find food item by id', async () => {
      const created = await createTestFoodItem(testCategoryId);
      const found = await foodItemService.findById(created.id);
      
      expect(found).toBeDefined();
      expect(found?.id).toBe(created.id);
    });

    it('should throw ApiError if not found', async () => {
      await expect(foodItemService.findById(-1)).rejects.toThrow(ApiError);
    });
  });

  describe('update', () => {
    it('should update food item', async () => {
      const created = await createTestFoodItem(testCategoryId);
      const updated = await foodItemService.update(created.id, { name: 'Updated Name' });
      
      expect(updated.name).toBe('Updated Name');
      expect(updated.id).toBe(created.id);
    });

    it('should validate category on update', async () => {
      const created = await createTestFoodItem(testCategoryId);
      await expect(foodItemService.update(created.id, { categoryId: -1 }))
        .rejects.toThrow(ApiError);
    });
  });

  describe('delete', () => {
    it('should delete food item', async () => {
      const created = await createTestFoodItem(testCategoryId);
      await foodItemService.delete(created.id);
      await expect(foodItemService.findById(created.id)).rejects.toThrow(ApiError);
    });
  });

  describe('limitType handling', () => {
    it('should handle per-household limits', async () => {
      const item = await createTestFoodItem(testCategoryId, {
        itemLimit: 5,
        limitType: 'perHousehold'
      });
      expect(item.limitType).toBe('perHousehold');
      expect(item.itemLimit).toBe(5);
    });

    it('should handle per-person limits', async () => {
      const item = await createTestFoodItem(testCategoryId, {
        itemLimit: 2,
        limitType: 'perPerson'
      });
      expect(item.limitType).toBe('perPerson');
      expect(item.itemLimit).toBe(2);
    });
  });
});
</file>

<file path="packages/backend/src/tests/languageRoutes.test.ts">
import request from 'supertest';
import { createApp } from '../index';
import { PrismaClient } from '@prisma/client';

describe('Language Routes', () => {
  const app = createApp();
  const prisma = new PrismaClient();

  beforeEach(async () => {
    await prisma.translation.deleteMany({});
    await prisma.foodItem.deleteMany({});
    await prisma.category.deleteMany({});
    await prisma.language.deleteMany({});
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  describe('POST /api/languages', () => {
    it('should create a new language', async () => {
      const response = await request(app)
        .post('/api/languages')
        .send({ code: 'fr', name: 'French' })
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.code).toBe('fr');
      expect(response.body.data.name).toBe('French');
    });

    it('should reject if code is missing', async () => {
      const response = await request(app)
        .post('/api/languages')
        .send({})
        .expect(400);

      expect(response.body.success).toBe(false);
    });

    it('should reject duplicates', async () => {
      await prisma.language.create({ data: { code: 'fr', name: 'French', active: true } });

      const response = await request(app)
        .post('/api/languages')
        .send({ code: 'fr', name: 'French' })
        .expect(400);

      expect(response.body.success).toBe(false);
    });
  });

  describe('GET /api/languages', () => {
    beforeEach(async () => {
      await prisma.language.create({
        data: { code: 'es', name: 'Spanish', active: true }
      });
      await prisma.language.create({
        data: { code: 'ru', name: 'Russian', active: true }
      });
    });

    it('should return all active languages', async () => {
      const response = await request(app)
        .get('/api/languages')
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(Array.isArray(response.body.data)).toBe(true);
      expect(response.body.data.length).toBe(2);
      const codes = response.body.data.map((l: any) => l.code);
      expect(codes).toContain('es');
      expect(codes).toContain('ru');
    });
  });
});
</file>

<file path="packages/backend/src/tests/limitType.test.ts">
import { PrismaClient } from '@prisma/client';
import { FoodItemService } from '../services/FoodItemService';

describe('FoodItem LimitType Tests', () => {
    let prisma: PrismaClient;
    let foodItemService: FoodItemService;
    let testCategoryId: number;

    beforeAll(async () => {
        prisma = new PrismaClient();
        foodItemService = new FoodItemService(true); // Enable test mode
        // Clear any existing data
        await prisma.translation.deleteMany();
        await prisma.foodItem.deleteMany();
        await prisma.category.deleteMany();
        
        const category = await prisma.category.create({
            data: { name: 'Test Category' }
        });
        testCategoryId = category.id;
    });

    afterEach(async () => {
        await prisma.translation.deleteMany();
        await prisma.foodItem.deleteMany();
    });

    afterAll(async () => {
        await prisma.$transaction([
            prisma.translation.deleteMany(),
            prisma.foodItem.deleteMany(),
            prisma.category.deleteMany()
        ]);
        await prisma.$disconnect();
    });

    it('creates food item with perPerson limitType', async () => {
        const foodItem = await foodItemService.create({
            name: 'Test Item',
            categoryId: testCategoryId,
            itemLimit: 2,
            limitType: 'perPerson'
        });

        expect(foodItem.limitType).toBe('perPerson');
    });

    it('defaults to perHousehold when limitType not specified', async () => {
        const foodItem = await foodItemService.create({
            name: 'Test Item 2',
            categoryId: testCategoryId
        });
        
        expect(foodItem.limitType).toBe('perHousehold');
    });

    it('updates limitType successfully', async () => {
        const foodItem = await foodItemService.create({
            name: 'Test Item 3',
            categoryId: testCategoryId,
            limitType: 'perHousehold'
        });
        
        const updated = await foodItemService.update(foodItem.id, {
            limitType: 'perPerson'
        });
        
        expect(updated.limitType).toBe('perPerson');
    });
});
</file>

<file path="packages/backend/src/tests/settings.test.ts">
describe('Settings API', () => {
    it('should get default settings', async () => {
        const response = await request(app)
            .get('/api/settings')
            .expect(200);
        
        expect(response.body.data.globalUpperLimit).toBeDefined();
    });

    it('should update settings', async () => {
        const response = await request(app)
            .post('/api/settings')
            .send({ globalUpperLimit: 50 })
            .expect(200);
        
        expect(response.body.data.globalUpperLimit).toBe(50);
    });
});
</file>

<file path="packages/backend/src/tests/settingsRoutes.test.ts">
import request from 'supertest';
import { createApp } from '../index';
import { PrismaClient } from '@prisma/client';

describe('Settings Routes', () => {
    const app = createApp();
    const prisma = new PrismaClient();

    beforeEach(async () => {
        await prisma.settings.deleteMany({});
    });

    afterAll(async () => {
        await prisma.$disconnect();
    });

    describe('GET /api/settings', () => {
        it('should return default settings when none exist', async () => {
            const response = await request(app)
                .get('/api/settings')
                .expect(200);

            expect(response.body).toEqual({
                success: true,
                data: { globalUpperLimit: 10 }
            });
        });

        it('should return existing settings', async () => {
            await prisma.settings.create({
                data: {
                    id: 1,
                    globalUpperLimit: 20
                }
            });

            const response = await request(app)
                .get('/api/settings')
                .expect(200);

            expect(response.body).toEqual({
                success: true,
                data: { globalUpperLimit: 20 }
            });
        });
    });

    describe('POST /api/settings', () => {
        it('should create new settings when none exist', async () => {
            const response = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 30 })
                .expect(200);

            expect(response.body).toEqual({
                success: true,
                data: expect.objectContaining({
                    id: 1,
                    globalUpperLimit: 30
                }),
                message: 'Settings updated successfully'
            });
        });

        it('should update existing settings', async () => {
            await prisma.settings.create({
                data: {
                    id: 1,
                    globalUpperLimit: 20
                }
            });

            const response = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 40 })
                .expect(200);

            expect(response.body).toEqual({
                success: true,
                data: expect.objectContaining({
                    id: 1,
                    globalUpperLimit: 40
                }),
                message: 'Settings updated successfully'
            });
        });

        it('should reject non-numeric global upper limit', async () => {
            const response = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 'invalid' })
                .expect(400);

            expect(response.body).toEqual({
                success: false,
                message: 'Global upper limit must be an integer',
                status: 400
            });
        });

        it('should reject negative global upper limit', async () => {
            const response = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: -1 })
                .expect(400);

            expect(response.body).toEqual({
                success: false,
                message: 'Global upper limit cannot be negative',
                status: 400
            });
        });

        it('should reject missing global upper limit', async () => {
            const response = await request(app)
                .post('/api/settings')
                .send({})
                .expect(400);

            expect(response.body).toEqual({
                success: false,
                message: 'Global upper limit is required',
                status: 400
            });
        });

        it('should reject decimal global upper limit', async () => {
            const response = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 10.5 })
                .expect(400);

            expect(response.body).toEqual({
                success: false,
                message: 'Global upper limit must be an integer',
                status: 400
            });
        });
    });

    describe('Settings persistence', () => {
        it('should maintain settings across requests', async () => {
            await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 50 })
                .expect(200);

            const response = await request(app)
                .get('/api/settings')
                .expect(200);

            expect(response.body).toEqual({
                success: true,
                data: { globalUpperLimit: 50 }
            });
        });

        it('should update updatedAt timestamp when modified', async () => {
            const createResponse = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 60 })
                .expect(200);

            const initialTimestamp = new Date(createResponse.body.data.updatedAt).getTime();

            // Wait a bit to ensure timestamp difference
            await new Promise(resolve => setTimeout(resolve, 1000));

            const updateResponse = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 70 })
                .expect(200);

            const updatedTimestamp = new Date(updateResponse.body.data.updatedAt).getTime();
            expect(updatedTimestamp).toBeGreaterThan(initialTimestamp);
        });
    });
});
</file>

<file path="packages/backend/src/tests/setup.ts">
import { cleanDatabase, disconnectDatabase } from './utils/dbHelpers';
import dotenv from 'dotenv';

// Load test environment variables
dotenv.config({ path: '.env.test' });

// Before all tests
beforeAll(async () => {
  await cleanDatabase();
});

// After all tests
afterAll(async () => {
  await disconnectDatabase();
});
</file>

<file path="packages/backend/src/tests/translationRoutes.test.ts">
import { createApp } from '../index';
import { cleanDatabase } from './utils/dbHelpers';
import { createTestCategory, createTestFoodItem, createTestLanguage, createTestTranslation } from './utils/testFactories';
import { expectSuccessResponse, expectErrorResponse } from './utils/testHelpers';
import request from 'supertest';

describe('Translation Routes', () => {
  const app = createApp();
  let testLanguageId: number;
  let testCategoryId: number;
  let testFoodItemId: number;

  beforeEach(async () => {
    await cleanDatabase();
    
    const language = await createTestLanguage();
    testLanguageId = language.id;
    
    const category = await createTestCategory();
    testCategoryId = category.id;
    
    const foodItem = await createTestFoodItem(category.id);
    testFoodItemId = foodItem.id;
  });

  describe('GET /api/translations/language/:languageCode', () => {
    beforeEach(async () => {
      await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });
      await createTestTranslation({
        foodItemId: testFoodItemId,
        languageId: testLanguageId
      });
    });

    it('should get translations by language code', async () => {
      const response = await request(app)
        .get('/api/translations/language/en')
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.length).toBe(2);
    });

    it('should filter by type', async () => {
      const response = await request(app)
        .get('/api/translations/language/en?type=category')
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.every((t: any) => t.categoryId)).toBe(true);
    });
  });

  describe('POST /api/translations/category/:categoryId', () => {
    it('should create category translation', async () => {
      const response = await request(app)
        .post(`/api/translations/category/${testCategoryId}`)
        .send({
          languageId: testLanguageId,
          translatedText: 'Test Translation'
        })
        .expect(201);

      expectSuccessResponse(response);
      expect(response.body.data.categoryId).toBe(testCategoryId);
    });

    it('should validate inputs', async () => {
      const response = await request(app)
        .post(`/api/translations/category/${testCategoryId}`)
        .send({
          languageId: -1,
          translatedText: ''
        })
        .expect(400);

      expectErrorResponse(response);
    });
  });

  describe('POST /api/translations/food-item/:foodItemId', () => {
    it('should create food item translation', async () => {
      const response = await request(app)
        .post(`/api/translations/food-item/${testFoodItemId}`)
        .send({
          languageId: testLanguageId,
          translatedText: 'Test Translation'
        })
        .expect(201);

      expectSuccessResponse(response);
      expect(response.body.data.foodItemId).toBe(testFoodItemId);
    });

    it('should validate inputs', async () => {
      const response = await request(app)
        .post(`/api/translations/food-item/${testFoodItemId}`)
        .send({
          languageId: -1,
          translatedText: ''
        })
        .expect(400);

      expectErrorResponse(response);
    });
  });

  describe('PUT /api/translations/:id', () => {
    it('should update translation', async () => {
      const translation = await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });

      const response = await request(app)
        .put(`/api/translations/${translation.id}`)
        .send({ translatedText: 'Updated Text' })
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.translatedText).toBe('Updated Text');
    });
  });

  describe('DELETE /api/translations/:id', () => {
    it('should delete translation', async () => {
      const translation = await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });

      await request(app)
        .delete(`/api/translations/${translation.id}`)
        .expect(200);

      // Verify deletion
      await request(app)
        .get(`/api/translations/${translation.id}`)
        .expect(404);
    });
  });
});
</file>

<file path="packages/backend/src/tests/TranslationService.test.ts">
import { TranslationService } from '../services/TranslationService';
import { ApiError } from '../utils/ApiError';
import { cleanDatabase } from './utils/dbHelpers';
import { createTestCategory, createTestFoodItem, createTestLanguage, createTestTranslation } from './utils/testFactories';

describe('TranslationService', () => {
  let translationService: TranslationService;
  let testLanguageId: number;
  let testCategoryId: number;
  let testFoodItemId: number;

  beforeEach(async () => {
    translationService = new TranslationService();
    await cleanDatabase();
    
    const language = await createTestLanguage();
    testLanguageId = language.id;
    
    const category = await createTestCategory();
    testCategoryId = category.id;
    
    const foodItem = await createTestFoodItem(category.id);
    testFoodItemId = foodItem.id;
  });

  describe('createForCategory', () => {
    it('should create category translation', async () => {
      const result = await translationService.createForCategory({
        categoryId: testCategoryId,
        languageId: testLanguageId,
        translatedText: 'Test Translation'
      });

      expect(result).toBeDefined();
      expect(result.categoryId).toBe(testCategoryId);
      expect(result.languageId).toBe(testLanguageId);
    });

    it('should validate category exists', async () => {
      await expect(translationService.createForCategory({
        categoryId: -1,
        languageId: testLanguageId,
        translatedText: 'Test'
      })).rejects.toThrow(ApiError);
    });
  });

  describe('createForFoodItem', () => {
    it('should create food item translation', async () => {
      const result = await translationService.createForFoodItem({
        foodItemId: testFoodItemId,
        languageId: testLanguageId,
        translatedText: 'Test Translation'
      });

      expect(result).toBeDefined();
      expect(result.foodItemId).toBe(testFoodItemId);
      expect(result.languageId).toBe(testLanguageId);
    });

    it('should validate food item exists', async () => {
      await expect(translationService.createForFoodItem({
        foodItemId: -1,
        languageId: testLanguageId,
        translatedText: 'Test'
      })).rejects.toThrow(ApiError);
    });
  });

  describe('findByLanguage', () => {
    beforeEach(async () => {
      await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });
      await createTestTranslation({
        foodItemId: testFoodItemId,
        languageId: testLanguageId
      });
    });

    it('should find all translations for language', async () => {
      const translations = await translationService.findByLanguage(testLanguageId);
      expect(translations.length).toBe(2);
    });

    it('should filter by type', async () => {
      const categoryTranslations = await translationService.findByLanguage(
        testLanguageId,
        'category'
      );
      expect(categoryTranslations.every(t => t.categoryId !== null)).toBe(true);

      const foodItemTranslations = await translationService.findByLanguage(
        testLanguageId,
        'foodItem'
      );
      expect(foodItemTranslations.every(t => t.foodItemId !== null)).toBe(true);
    });
  });

  describe('update', () => {
    it('should update translation text', async () => {
      const translation = await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });

      const updated = await translationService.update(
        translation.id,
        'Updated Text'
      );
      
      expect(updated.translatedText).toBe('Updated Text');
    });
  });

  describe('delete', () => {
    it('should delete translation', async () => {
      const translation = await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });

      await translationService.delete(translation.id);
      
      const translations = await translationService.findByLanguage(testLanguageId);
      expect(translations.find(t => t.id === translation.id)).toBeUndefined();
    });
  });
});
</file>

<file path="packages/backend/src/utils/ApiError.ts">
export class ApiError extends Error {
  public isOperational: boolean;

  constructor(
    public statusCode: number,
    message: string,
    isOperational = true,
    stack = ''
  ) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;

    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

/**
 * Custom error class for settings-related validation errors.
 * Inherits from ApiError with a fixed status code of 400.
 */
export class SettingsValidationError extends ApiError {
  constructor(message: string) {
    super(400, message);
  }
}

/**
 * Type guard to identify ApiError instances.
 */
export const isApiError = (error: unknown): error is ApiError => {
  return error instanceof ApiError;
};
</file>

<file path="packages/backend/src/utils/ApiResponse.ts">
export class ApiResponse {
  public readonly success: boolean;
  public readonly data: any;
  public readonly message?: string;
  public readonly pagination?: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
  };

  constructor(success: boolean, data: any, message?: string, pagination?: any) {
      this.success = success;
      this.data = data;
      this.message = message;
      this.pagination = pagination;
  }

  static success(data: any, message?: string, pagination?: any): ApiResponse {
      return new ApiResponse(true, data, message, pagination);
  }

  static error(message: string): ApiResponse {
      return new ApiResponse(false, null, message);
  }

  static paginated(items: any[], page: number, limit: number, total: number): ApiResponse {
      const totalPages = Math.ceil(total / limit);
      return new ApiResponse(true, items, undefined, { page, limit, total, totalPages });
  }
}
</file>

<file path="packages/backend/src/utils/errorConstants.ts">
export const ErrorTypes = {
  VALIDATION: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  INTERNAL: 500
} as const;

export const ErrorMessages = {
  // Entity not found
  CATEGORY_NOT_FOUND: 'Category not found',
  FOOD_ITEM_NOT_FOUND: 'Food item not found',
  TRANSLATION_NOT_FOUND: 'Translation not found',
  LANGUAGE_NOT_FOUND: 'Language not found',
  SETTING_NOT_FOUND: 'Setting not found',

  // Invalid inputs
  INVALID_CATEGORY: 'Invalid category ID',
  INVALID_LANGUAGE: 'Invalid or inactive language code',
  INVALID_LIMIT_TYPE: 'Invalid limit type',
  
  // Operation errors
  CREATE_ERROR: (entity: string) => `Error creating ${entity}`,
  UPDATE_ERROR: (entity: string) => `Error updating ${entity}`,
  DELETE_ERROR: (entity: string) => `Error deleting ${entity}`,
  TRANSLATION_ERROR: (lang: string) => `Error generating translation for language: ${lang}`
} as const;
</file>

<file path="packages/backend/src/utils/errorHandler.ts">
import { ApiError } from './ApiError';
import { ErrorTypes } from './errorConstants';
import { Prisma } from '@prisma/client';

export const handleServiceError = (error: unknown, defaultMessage: string): never => {
  console.error('Service Error:', error);

  if (error instanceof ApiError) {
    throw error;
  }

  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case 'P2002':
        throw new ApiError(400, 'This entry already exists');
      case 'P2003':
        throw new ApiError(400, 'Invalid reference. Please check your inputs.');
      case 'P2025':
        throw new ApiError(404, 'Item not found');
      default:
        console.error('Prisma error:', error);
        throw new ApiError(400, defaultMessage);
    }
  }

  if (error instanceof Prisma.PrismaClientValidationError) {
    console.error('Validation error:', error);
    throw new ApiError(400, 'Invalid input data');
  }

  if (error instanceof Prisma.PrismaClientInitializationError) {
    console.error('Database initialization error:', error);
    throw new ApiError(500, 'Database connection error');
  }

  if (error instanceof Error) {
    console.error('Unhandled error:', error);
    throw new ApiError(400, error.message || defaultMessage);
  }

  throw new ApiError(500, defaultMessage);
};
</file>

<file path="packages/backend/src/utils/validationUtils.ts">
import { PrismaClient } from '@prisma/client';
import { ApiError } from './ApiError';

const prisma = new PrismaClient();

export interface ValidationResult {
    isValid: boolean;
    error?: string;
    normalizedValue?: string;
}

export class ValidationUtils {
    private static readonly MAX_LENGTH = 36;
    private static readonly MIN_LENGTH = 3;

    static async validateInput(
        input: string,
        type: 'category' | 'foodItem',
        existingId?: number
    ): Promise<ValidationResult> {
        try {
            input = input.trim();

            if (input.length > this.MAX_LENGTH) {
                return {
                    isValid: false,
                    error: `Input cannot exceed ${this.MAX_LENGTH} characters, including spaces.`
                };
            }

            if (input.length < this.MIN_LENGTH) {
                return {
                    isValid: false,
                    error: 'Input must be at least three characters long.'
                };
            }

            const letterCount = (input.match(/[a-zA-Z]/g) || []).length;
            if (letterCount < 3) {
                return {
                    isValid: false,
                    error: 'Input must include at least three letters.'
                };
            }

            if (/\s{2,}/.test(input)) {
                return {
                    isValid: false,
                    error: 'Input contains unnecessary spaces.'
                };
            }

            const words = input.toLowerCase().split(' ');
            const uniqueWords = new Set(words);
            if (uniqueWords.size !== words.length) {
                return {
                    isValid: false,
                    error: 'Input contains repeated words.'
                };
            }

            const normalizedInput = input.toLowerCase();

            // Check categories using LIKE query for SQLite
            const existingCategory = await prisma.category.findFirst({
                where: {
                    name: {
                        contains: normalizedInput
                    },
                    NOT: existingId ? { id: existingId } : undefined
                }
            });

            if (existingCategory && 
                existingCategory.name.toLowerCase() === normalizedInput) {
                return {
                    isValid: false,
                    error: type === 'category' ? 
                        'This category already exists.' : 
                        'This name already exists as a category.'
                };
            }

            // Check food items using LIKE query for SQLite
            const existingFoodItem = await prisma.foodItem.findFirst({
                where: {
                    name: {
                        contains: normalizedInput
                    },
                    NOT: existingId ? { id: existingId } : undefined
                }
            });

            if (existingFoodItem && 
                existingFoodItem.name.toLowerCase() === normalizedInput) {
                return {
                    isValid: false,
                    error: type === 'foodItem' ? 
                        'This food item already exists.' : 
                        'This name already exists as a food item.'
                };
            }

            const titleCaseInput = input
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ');

            return {
                isValid: true,
                normalizedValue: titleCaseInput
            };
        } catch (error) {
            console.error('Validation error:', error);
            throw new ApiError(400, 'Validation failed. Please try again.');
        } finally {
            await prisma.$disconnect();
        }
    }

    static formatForDisplay(input: string): string {
        return input
            .split(' ')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join(' ');
    }
}
</file>

<file path="packages/backend/src/index.ts">
import dotenv from 'dotenv';
dotenv.config(); // Call this first, before importing anything else that relies on env vars

import express from 'express';
import cors from 'cors';
import { requestLogger } from './middleware/requestLogger';
import { errorHandler } from './middleware/errorHandler';
import { ApiResponse } from './utils/ApiResponse';
import categoryRoutes from './routes/categoryRoutes';
import foodItemRoutes from './routes/foodItemRoutes';
import translationRoutes from './routes/translationRoutes';
import languageRoutes from './routes/languageRoutes';
import settingsRoutes from './routes/settingsRoutes';
import path from 'path';

// Create and configure express app
export const createApp = () => {
    const app = express();

    // Middleware
    app.use(cors());
    app.use(express.json());
    app.use(requestLogger);

    // Serve static files from public directory
    app.use(express.static(path.join(__dirname, '../public')));

    // Routes
    app.use('/api/categories', categoryRoutes);
    app.use('/api/food-items', foodItemRoutes);
    app.use('/api/translations', translationRoutes);
    app.use('/api/languages', languageRoutes);
    app.use('/api/settings', settingsRoutes);    // Add this line

    // Basic health check endpoint
    app.get('/health', (req, res) => {
        res.status(200).json(ApiResponse.success({
            uptime: process.uptime(),
            timestamp: new Date().toISOString()
        }));
    });

    // Error handling middleware (must be after all other middleware and routes)
    app.use(errorHandler);
    return app;
};

// Only start the server if this file is run directly
if (require.main === module) {
    const app = createApp();
    const PORT = process.env.PORT || 3000;
    app.listen(PORT, () => {
        console.log(`Server running on port ${PORT}`);
    });
}
</file>

<file path="packages/backend/.env.example">
DATABASE_URL="file:../../data/food-pantry.db"
OPENAI_API_KEY="your-api-key-here"
</file>

<file path="packages/backend/jest-setup.js">
const { TextEncoder, TextDecoder } = require('util');
global.TextEncoder = TextEncoder;
global.TextDecoder = TextDecoder;
</file>

<file path="packages/backend/jest.config.js">
module.exports = {
    projects: [
        {
            displayName: 'backend',
            testEnvironment: 'node',
            testMatch: [
                '<rootDir>/src/tests/*.test.ts',
                '<rootDir>/src/services/**/*.test.ts'
            ],
            transform: {
                '^.+\\.(ts|tsx)$': 'ts-jest'
            },
            setupFilesAfterEnv: [
                '<rootDir>/src/tests/setup.ts'
            ],
            moduleNameMapper: {
                '^@/(.*)$': '<rootDir>/src/$1'
            }
        },
        {
            displayName: 'frontend',
            testEnvironment: 'jsdom',
            testMatch: [
                '<rootDir>/src/tests/frontend/*.test.js'
            ],
            transform: {
                '^.+\\.(js|jsx)$': 'babel-jest'
            },
            setupFilesAfterEnv: [
                '<rootDir>/src/tests/frontend/setup.js'
            ]
        }
    ],
    collectCoverage: true,
    coverageDirectory: 'coverage',
    coverageReporters: ['text', 'lcov'],
    testTimeout: 30000,
    detectOpenHandles: true
}
</file>

<file path="packages/backend/package.json">
{
    "name": "@sql-react-app/backend",
    "version": "0.1.0",
    "private": true,
    "scripts": {
        "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
        "build": "tsc",
        "start": "node dist/index.js",
        "prisma:generate": "prisma generate",
        "prisma:migrate": "prisma migrate deploy",
        "prisma:studio": "prisma studio",
        "test": "jest",
        "test:watch": "jest --watch",
        "test:coverage": "jest --coverage",
        "test:unit": "jest src/tests/limitType.test.ts",
        "test:frontend": "jest src/tests/frontend/",
        "test:fooditems": "jest public/js/foodItems/__tests__/ --config public/js/foodItems/__tests__/jest.config.js",
        "test:fooditems:watch": "npm run test:fooditems -- --watch",
        "test:fooditems:coverage": "npm run test:fooditems -- --coverage",
        "test:fooditems:report": "node public/js/foodItems/__tests__/utils/generateCoverage.js",
        "test:fooditems:full": "npm run test:fooditems:coverage && npm run test:fooditems:report",
        "lint": "eslint . --ext .ts"
    },
    "dependencies": {
        "@prisma/client": "^6.1.0",
        "cors": "^2.8.5",
        "dotenv": "^16.3.1",
        "express": "^4.18.2",
        "express-validator": "^7.0.1",
        "openai": "^4.76.0",
        "winston": "^3.11.0"
    },
    "devDependencies": {
        "@babel/core": "^7.26.0",
        "@babel/plugin-transform-modules-commonjs": "^7.26.3",
        "@babel/preset-env": "^7.26.0",
        "@babel/preset-typescript": "^7.26.0",
        "@types/cors": "^2.8.17",
        "@types/express": "^4.17.21",
        "@types/jest": "^29.5.11",
        "@types/node": "^20.10.4",
        "@types/supertest": "^6.0.2",
        "@typescript-eslint/eslint-plugin": "^6.13.2",
        "@typescript-eslint/parser": "^6.13.2",
        "babel-jest": "^29.7.0",
        "eslint": "^8.55.0",
        "jest": "^29.7.0",
        "jest-environment-jsdom": "^29.7.0",
        "jest-junit": "^16.0.0",
        "prisma": "^6.1.0",
        "supertest": "^7.0.0",
        "ts-jest": "^29.1.1",
        "ts-node-dev": "^2.0.0",
        "typescript": "^5.3.3"
    }
}
</file>

<file path="packages/backend/tsconfig.json">
{
    "compilerOptions": {
      "target": "es2020",
      "module": "commonjs",
      "lib": ["es2020"],
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "outDir": "dist",
      "rootDir": "src",
      "experimentalDecorators": true,
      "emitDecoratorMetadata": true,
      "resolveJsonModule": true
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "dist"]
  }
</file>

<file path="packages/frontend/package.json">
{
    "name": "@sql-react-app/frontend",
    "version": "0.1.0",
    "private": true,
    "dependencies": {
      "react": "^18.2.0",
      "react-dom": "^18.2.0"
    },
    "devDependencies": {
      "@types/react": "^18.2.0",
      "@types/react-dom": "^18.2.0",
      "typescript": "^5.3.3"
    }
}
</file>

<file path=".gitignore">
.DS_Store
packages/backend/.env
node_modules
*.log
node_modules/
data/
.repomixignore
repomix-output.xml
repomix.config.json
coding-prompt.md
codebase.md
project-overview.md
project-structure.md
Initial_prompt_v01.txt
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 MattGeiger

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
  "name": "wth-food-shopping-lists",
  "version": "1.0.0",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "dev": "npm run dev --workspace=@sql-react-app/backend",
    "build": "npm run build --workspace=@sql-react-app/backend",
    "test": "npm run test --workspace=@sql-react-app/backend",
    "lint": "npm run lint --workspace=@sql-react-app/backend"
  },
  "devDependencies": {
    "@types/jsdom": "^21.1.7",
    "jsdom": "^25.0.1",
    "typescript": "^5.3.3"
  }
}
</file>

<file path="project-tree.txt">
.
├── CHANGELOG.md
├── Initial_prompt_v02.txt
├── LICENSE
├── README.md
├── codebase.md
├── packages
│   ├── backend
│   │   ├── jest-setup.js
│   │   ├── jest.config.js
│   │   ├── prisma
│   │   │   ├── migrations
│   │   │   │   ├── 20241130003245_init
│   │   │   │   │   └── migration.sql
│   │   │   │   ├── 20241207052011_add_language_model_and_make_language_id_optional
│   │   │   │   │   └── migration.sql
│   │   │   │   ├── 20241209004222_add_settings_model
│   │   │   │   │   └── migration.sql
│   │   │   │   ├── 20241220064500_add_limit_type
│   │   │   │   │   └── migration.sql
│   │   │   │   ├── 20241221195000_add_category_limit
│   │   │   │   │   └── migration.sql
│   │   │   │   ├── 20241222002000_add_unique_name_constraints
│   │   │   │   │   └── migration.sql
│   │   │   │   ├── 20241225021031_add_original_text_to_translations
│   │   │   │   │   └── migration.sql
│   │   │   │   └── migration_lock.toml
│   │   │   └── schema.prisma
│   │   ├── project-tree.txt
│   │   ├── public
│   │   │   ├── css
│   │   │   │   ├── components
│   │   │   │   │   ├── forms.css
│   │   │   │   │   ├── languages.css
│   │   │   │   │   ├── messages.css
│   │   │   │   │   └── tables.css
│   │   │   │   ├── layout
│   │   │   │   │   └── sections.css
│   │   │   │   └── styles.css
│   │   │   ├── index.html
│   │   │   ├── js
│   │   │   │   ├── categories.js
│   │   │   │   ├── foodItems
│   │   │   │   │   ├── FoodItemManager.js
│   │   │   │   │   ├── __tests__
│   │   │   │   │   │   ├── FoodItemManager.test.js
│   │   │   │   │   │   ├── README.md
│   │   │   │   │   │   ├── babel.config.js
│   │   │   │   │   │   ├── coverage
│   │   │   │   │   │   │   ├── clover.xml
│   │   │   │   │   │   │   ├── lcov-report
│   │   │   │   │   │   │   │   ├── base.css
│   │   │   │   │   │   │   │   ├── block-navigation.js
│   │   │   │   │   │   │   │   ├── favicon.png
│   │   │   │   │   │   │   │   ├── index.html
│   │   │   │   │   │   │   │   ├── prettify.css
│   │   │   │   │   │   │   │   ├── prettify.js
│   │   │   │   │   │   │   │   ├── sort-arrow-sprite.png
│   │   │   │   │   │   │   │   └── sorter.js
│   │   │   │   │   │   │   └── lcov.info
│   │   │   │   │   │   ├── coverage-template.md
│   │   │   │   │   │   ├── handlers
│   │   │   │   │   │   │   ├── formData.test.js
│   │   │   │   │   │   │   ├── submit.test.js
│   │   │   │   │   │   │   └── validation.test.js
│   │   │   │   │   │   ├── jest.config.js
│   │   │   │   │   │   ├── setup.js
│   │   │   │   │   │   ├── ui
│   │   │   │   │   │   │   ├── forms.test.js
│   │   │   │   │   │   │   ├── stats.test.js
│   │   │   │   │   │   │   └── table.test.js
│   │   │   │   │   │   └── utils
│   │   │   │   │   │       ├── assertions.js
│   │   │   │   │   │       ├── generateCoverage.js
│   │   │   │   │   │       ├── testFactories.js
│   │   │   │   │   │       └── testHelpers.js
│   │   │   │   │   ├── handlers
│   │   │   │   │   │   ├── formData.js
│   │   │   │   │   │   ├── submit.js
│   │   │   │   │   │   └── validation.js
│   │   │   │   │   ├── index.js
│   │   │   │   │   ├── ui
│   │   │   │   │   │   ├── forms.js
│   │   │   │   │   │   ├── stats.js
│   │   │   │   │   │   └── table.js
│   │   │   │   │   └── utils
│   │   │   │   │       └── errorHandler.js
│   │   │   │   ├── foodItems.js
│   │   │   │   ├── languages.js
│   │   │   │   ├── main.js
│   │   │   │   ├── settings.js
│   │   │   │   ├── translations.js
│   │   │   │   ├── utils
│   │   │   │   │   └── sortableTable.js
│   │   │   │   └── utils.js
│   │   │   ├── sample-claude.html
│   │   │   ├── sample-layout-part1.html
│   │   │   ├── sample-layout.html
│   │   │   ├── sample-layoutv2.html
│   │   │   └── sample.html
│   │   └── src
│   │       ├── config
│   │       │   └── languageConfig.ts
│   │       ├── index.ts
│   │       ├── middleware
│   │       │   ├── errorHandler.ts
│   │       │   └── requestLogger.ts
│   │       ├── routes
│   │       │   ├── categoryRoutes.ts
│   │       │   ├── foodItemRoutes.ts
│   │       │   ├── languageRoutes.ts
│   │       │   ├── settingsRoutes.ts
│   │       │   └── translationRoutes.ts
│   │       ├── services
│   │       │   ├── CategoryService.ts
│   │       │   ├── FoodItemService.ts
│   │       │   ├── LanguageService.ts
│   │       │   ├── TranslationService.ts
│   │       │   └── openai
│   │       │       ├── OpenAIService.ts
│   │       │       └── __tests__
│   │       │           └── OpenAIService.test.ts
│   │       ├── tests
│   │       │   ├── CategoryService.test.ts
│   │       │   ├── FoodItemService.test.ts
│   │       │   ├── TranslationService.test.ts
│   │       │   ├── categoryRoutes.test.ts
│   │       │   ├── foodItemRoutes.test.ts
│   │       │   ├── languageRoutes.test.ts
│   │       │   ├── limitType.test.ts
│   │       │   ├── settings.test.ts
│   │       │   ├── settingsRoutes.test.ts
│   │       │   ├── setup.ts
│   │       │   ├── translationRoutes.test.ts
│   │       │   └── utils
│   │       │       ├── dbHelpers.ts
│   │       │       ├── testFactories.ts
│   │       │       └── testHelpers.ts
│   │       └── utils
│   │           ├── ApiError.ts
│   │           ├── ApiResponse.ts
│   │           ├── errorConstants.ts
│   │           ├── errorHandler.ts
│   │           └── validationUtils.ts
│   ├── data
│   │   └── food-pantry.db
│   └── repomix-output.xml
├── project-overview.md
├── project-structure.md
├── project-tree.txt
└── repomix-output.xml

39 directories, 112 files
</file>

</repository_files>
