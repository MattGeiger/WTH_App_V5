This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-21T18:30:02.625Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
.github/
  ISSUE_TEMPLATE/
    bug_report.md
    feature_request.md
packages/
  backend/
    prisma/
      migrations/
        20241130003245_init/
          migration.sql
        20241207052011_add_language_model_and_make_language_id_optional/
          migration.sql
        20241209004222_add_settings_model/
          migration.sql
        20241220064500_add_limit_type/
          migration.sql
        migration_lock.toml
      schema.prisma
    public/
      css/
        components/
          forms.css
          languages.css
          messages.css
          tables.css
        layout/
          sections.css
        styles.css
      js/
        categories.js
        foodItems.js
        languages.js
        main.js
        settings.js
        translations.js
        utils.js
      index.html
    src/
      config/
        languageConfig.ts
      middleware/
        errorHandler.ts
        requestLogger.ts
      routes/
        categoryRoutes.ts
        foodItemRoutes.ts
        languageRoutes.ts
        settingsRoutes.ts
        translationRoutes.ts
      services/
        openai/
          __tests__/
            OpenAIService.test.ts
          OpenAIService.ts
        CategoryService.ts
        FoodItemService.ts
        LanguageService.ts
        TranslationService.ts
      tests/
        utils/
          dbHelpers.ts
          testFactories.ts
          testHelpers.ts
        categoryRoutes.test.ts
        CategoryService.test.ts
        foodItemRoutes.test.ts
        FoodItemService.test.ts
        languageRoutes.test.ts
        limitType.test.ts
        settings.test.ts
        settingsRoutes.test.ts
        setup.ts
        translationRoutes.test.ts
        TranslationService.test.ts
      utils/
        ApiError.ts
        ApiResponse.ts
        errorConstants.ts
        errorHandler.ts
      index.ts
    .env.example
    jest-setup.js
    jest.config.js
    package.json
    tsconfig.json
  frontend/
    package.json
.gitignore
.repomixignore
CHANGELOG.md
LICENSE
package.json
project-tree.txt
README.md
repomix.config.json
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path=".github/ISSUE_TEMPLATE/bug_report.md">
---
name: Bug report
about: Create a report to help us improve
title: '[BUG] '
labels: bug
assignees: ''

---

### Description
A clear and concise description of what the bug is.

### Steps to Reproduce
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

### Expected Behavior
A clear and concise description of what you expected to happen.

### Actual Behavior
What actually happens instead of the expected behavior.

### Environment
- Browser: [e.g., Chrome, Safari]
- Version: [e.g., 22]
- OS: [e.g., macOS, Windows]
- Node version:
- Other relevant config:

### Logs/Screenshots
```
[Add relevant logs here]
```

### Investigation Progress
- [ ] Step 1
- [ ] Step 2

### Additional Context
Add any other context about the problem here.

### Related Changes
- List any related changes, commits, or PRs
</file>

<file path=".github/ISSUE_TEMPLATE/feature_request.md">
---
name: Feature request
about: Suggest an idea for this project
title: '[FEATURE] '
labels: enhancement
assignees: ''

---

### Problem Statement
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

### Proposed Solution
A clear and concise description of what you want to happen.

### Alternative Solutions
A clear and concise description of any alternative solutions or features you've considered.

### Additional Context
Add any other context or screenshots about the feature request here.

### Implementation Checklist
- [ ] Task 1
- [ ] Task 2

### Impact Analysis
Describe the impact this feature would have on:
- Performance
- Security
- User Experience
- Maintenance
</file>

<file path="packages/backend/prisma/migrations/20241130003245_init/migration.sql">
-- CreateTable
CREATE TABLE "Category" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "name" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- CreateTable
CREATE TABLE "FoodItem" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "name" TEXT NOT NULL,
    "categoryId" INTEGER NOT NULL,
    "imageUrl" TEXT,
    "thumbnailUrl" TEXT,
    "itemLimit" INTEGER,
    "inStock" BOOLEAN NOT NULL DEFAULT true,
    "mustGo" BOOLEAN NOT NULL DEFAULT false,
    "lowSupply" BOOLEAN NOT NULL DEFAULT false,
    "kosher" BOOLEAN NOT NULL DEFAULT false,
    "halal" BOOLEAN NOT NULL DEFAULT false,
    "vegetarian" BOOLEAN NOT NULL DEFAULT false,
    "vegan" BOOLEAN NOT NULL DEFAULT false,
    "glutenFree" BOOLEAN NOT NULL DEFAULT false,
    "organic" BOOLEAN NOT NULL DEFAULT false,
    "readyToEat" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "FoodItem_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "Translation" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "language" TEXT NOT NULL,
    "translatedText" TEXT NOT NULL,
    "categoryId" INTEGER,
    "foodItemId" INTEGER,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "Translation_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "Translation_foodItemId_fkey" FOREIGN KEY ("foodItemId") REFERENCES "FoodItem" ("id") ON DELETE SET NULL ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "CustomField" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "key" TEXT NOT NULL,
    "value" TEXT NOT NULL,
    "foodItemId" INTEGER NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "CustomField_foodItemId_fkey" FOREIGN KEY ("foodItemId") REFERENCES "FoodItem" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateIndex
CREATE INDEX "FoodItem_categoryId_idx" ON "FoodItem"("categoryId");

-- CreateIndex
CREATE UNIQUE INDEX "Translation_language_categoryId_key" ON "Translation"("language", "categoryId");

-- CreateIndex
CREATE UNIQUE INDEX "Translation_language_foodItemId_key" ON "Translation"("language", "foodItemId");

-- CreateIndex
CREATE INDEX "CustomField_foodItemId_idx" ON "CustomField"("foodItemId");
</file>

<file path="packages/backend/prisma/migrations/20241207052011_add_language_model_and_make_language_id_optional/migration.sql">
/*
  Warnings:

  - You are about to drop the column `language` on the `Translation` table. All the data in the column will be lost.

*/
-- CreateTable
CREATE TABLE "Language" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "code" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "active" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- RedefineTables
PRAGMA defer_foreign_keys=ON;
PRAGMA foreign_keys=OFF;
CREATE TABLE "new_Translation" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "translatedText" TEXT NOT NULL,
    "categoryId" INTEGER,
    "foodItemId" INTEGER,
    "languageId" INTEGER,
    "isAutomatic" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "Translation_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "Translation_foodItemId_fkey" FOREIGN KEY ("foodItemId") REFERENCES "FoodItem" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "Translation_languageId_fkey" FOREIGN KEY ("languageId") REFERENCES "Language" ("id") ON DELETE SET NULL ON UPDATE CASCADE
);
INSERT INTO "new_Translation" ("categoryId", "createdAt", "foodItemId", "id", "translatedText", "updatedAt") SELECT "categoryId", "createdAt", "foodItemId", "id", "translatedText", "updatedAt" FROM "Translation";
DROP TABLE "Translation";
ALTER TABLE "new_Translation" RENAME TO "Translation";
CREATE INDEX "Translation_languageId_idx" ON "Translation"("languageId");
CREATE UNIQUE INDEX "Translation_languageId_categoryId_key" ON "Translation"("languageId", "categoryId");
CREATE UNIQUE INDEX "Translation_languageId_foodItemId_key" ON "Translation"("languageId", "foodItemId");
PRAGMA foreign_keys=ON;
PRAGMA defer_foreign_keys=OFF;

-- CreateIndex
CREATE UNIQUE INDEX "Language_code_key" ON "Language"("code");
</file>

<file path="packages/backend/prisma/migrations/20241209004222_add_settings_model/migration.sql">
-- CreateTable
CREATE TABLE "Settings" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT DEFAULT 1,
    "globalUpperLimit" INTEGER NOT NULL DEFAULT 10,
    "updatedAt" DATETIME NOT NULL
);
</file>

<file path="packages/backend/prisma/migrations/20241220064500_add_limit_type/migration.sql">
-- Add limitType field to FoodItem
ALTER TABLE FoodItem ADD COLUMN limitType TEXT DEFAULT 'perHousehold';
</file>

<file path="packages/backend/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "sqlite"
</file>

<file path="packages/backend/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Category {
  id          Int           @id @default(autoincrement())
  name        String        // English name as base
  items       FoodItem[]
  translations Translation[]
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model FoodItem {
  id            Int           @id @default(autoincrement())
  name          String        // English name as base
  categoryId    Int
  category      Category      @relation(fields: [categoryId], references: [id])
  translations  Translation[]
  
  // Image handling
  imageUrl      String?
  thumbnailUrl  String?
  
  // Inventory management
  itemLimit     Int?
  limitType     String        @default("perHousehold")  // "perHousehold" or "perPerson"
  inStock       Boolean       @default(true)
  mustGo        Boolean       @default(false)
  lowSupply     Boolean       @default(false)
  
  // Dietary attributes
  kosher        Boolean       @default(false)
  halal         Boolean       @default(false)
  vegetarian    Boolean       @default(false)
  vegan         Boolean       @default(false)
  glutenFree    Boolean       @default(false)
  
  // Quality attributes
  organic       Boolean       @default(false)
  readyToEat    Boolean       @default(false)
  
  // Custom fields for flexibility
  customFields  CustomField[]
  
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  @@index([categoryId])
}

model Translation {
  id             Int       @id @default(autoincrement())
  translatedText String
  categoryId     Int?
  category       Category? @relation(fields: [categoryId], references: [id])
  foodItemId     Int?
  foodItem       FoodItem? @relation(fields: [foodItemId], references: [id])
  languageId     Int?
  language       Language? @relation(fields: [languageId], references: [id])
  isAutomatic    Boolean   @default(false)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  @@unique([languageId, categoryId])
  @@unique([languageId, foodItemId])
  @@index([languageId])
}

model Language {
  id           Int           @id @default(autoincrement())
  code         String        @unique  // ISO 639-1 language code (e.g., "en", "es", "zh")
  name         String        // Display name (e.g., "English", "Spanish", "Chinese")
  active       Boolean       @default(true)
  translations Translation[]
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
}

model CustomField {
  id          Int       @id @default(autoincrement())
  key         String
  value       String
  foodItemId  Int
  foodItem    FoodItem  @relation(fields: [foodItemId], references: [id])
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  @@index([foodItemId])
}

model Settings {
  id              Int      @id @default(1)
  globalUpperLimit Int     @default(10)
  updatedAt       DateTime @updatedAt
}
</file>

<file path="packages/backend/public/css/components/forms.css">
.form__group {
    margin: 10px 0;
}

.toggle-group {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin: 10px 0;
}

.toggle-group__label {
    display: flex;
    align-items: center;
    gap: 5px;
}

.limit-options {
    display: flex;
    align-items: center;
    gap: 20px;
}

.lang-select {
    display: flex;
    align-items: center;
    gap: 10px;
}

.lang-select__label {
    width: 120px;
}
</file>

<file path="packages/backend/public/css/components/languages.css">
.language-grid {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 10px;
    margin: 20px 0;
}

.language-item {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 0.9em;
}

.translation-type {
    display: flex;
    gap: 20px;
}
</file>

<file path="packages/backend/public/css/components/messages.css">
.message-area {
    margin-bottom: 1rem;
    min-height: 2rem;
}

.message {
    padding: 0.75rem 1rem;
    margin: 0.5rem 0;
    border-radius: 4px;
}

.message--success {
    background-color: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
}

.message--error {
    background-color: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
}

.message--warning {
    background-color: #fff3cd;
    color: #856404;
    border: 1px solid #ffeeba;
}

.message--info {
    background-color: #d1ecf1;
    color: #0c5460;
    border: 1px solid #bee5eb;
}

.message--note {
    background-color: #e2e3e5;
    color: #383d41;
    border: 1px solid #d6d8db;
    font-size: 0.9em;
}
</file>

<file path="packages/backend/public/css/components/tables.css">
.table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
}

.table__cell {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
}

.table__header {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
    background-color: #f8f9fa;
}
</file>

<file path="packages/backend/public/css/layout/sections.css">
.section {
    margin: 20px 0;
    padding: 20px;
    border: 1px solid #ccc;
}

.filter-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}
</file>

<file path="packages/backend/public/css/styles.css">
/* Base styles and imports */
@import 'components/messages.css';
@import 'components/tables.css';
@import 'components/forms.css';
@import 'components/languages.css';
@import 'layout/sections.css';

/* Global styles */
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;
    line-height: 1.4;
    color: #333;
    margin: 0;
    padding: 20px;
}

h1, h2, h3, h4 {
    margin-top: 0;
    margin-bottom: 0.5em;
}
</file>

<file path="packages/backend/public/js/categories.js">
import { showMessage, apiGet, apiPost, apiPut, apiDelete } from './utils.js';

export class CategoryManager {
    constructor() {
        this.form = document.getElementById('categoryForm');
        this.tableBody = document.getElementById('categoryTableBody');
        this.resetButton = document.getElementById('resetForm');
        this.setupEventListeners();
    }

    setupEventListeners() {
        this.form.addEventListener('submit', this.handleSubmit.bind(this));
        this.resetButton.addEventListener('click', () => this.resetForm());
        this.addTableEventListeners();
    }

    addTableEventListeners() {
        this.tableBody.addEventListener('click', (e) => {
            const target = e.target;
            if (target.classList.contains('edit-btn')) {
                this.editCategory(target.dataset.id, target.dataset.name);
            } else if (target.classList.contains('delete-btn')) {
                this.deleteCategory(target.dataset.id);
            }
        });
    }

    async handleSubmit(e) {
        e.preventDefault();
        const name = document.getElementById('categoryName').value.trim();
        const id = document.getElementById('categoryId').value;

        try {
            if (id) {
                await apiPut(`/api/categories/${id}`, { name });
                showMessage('Category updated successfully', 'success', 'category');
            } else {
                await apiPost('/api/categories', { name });
                showMessage('Category created successfully', 'success', 'category');
            }
            this.resetForm();
            await this.loadCategories();
        } catch (error) {
            showMessage(error.message, 'error', 'category');
        }
    }

    async loadCategories() {
        try {
            const data = await apiGet('/api/categories');
            this.displayCategories(data.data);
        } catch (error) {
            showMessage(error.message, 'error', 'category');
        }
    }

    displayCategories(categories) {
        this.tableBody.innerHTML = categories.map(category => `
            <tr>
                <td class="table__cell">${category.name}</td>
                <td class="table__cell">${new Date(category.createdAt).toLocaleDateString()}</td>
                <td class="table__cell">
                    <button class="edit-btn" data-id="${category.id}" data-name="${category.name}">Edit</button>
                    <button class="delete-btn" data-id="${category.id}">Delete</button>
                </td>
            </tr>
        `).join('');
    }

    async deleteCategory(id) {
        if (!confirm('Are you sure you want to delete this category?')) return;

        try {
            await apiDelete(`/api/categories/${id}`);
            showMessage('Category deleted successfully', 'success', 'category');
            await this.loadCategories();
        } catch (error) {
            showMessage(error.message, 'error', 'category');
        }
    }

    editCategory(id, name) {
        document.getElementById('categoryId').value = id;
        document.getElementById('categoryName').value = name;
        this.form.querySelector('button[type="submit"]').textContent = 'Update Category';
    }

    resetForm() {
        this.form.reset();
        document.getElementById('categoryId').value = '';
        this.form.querySelector('button[type="submit"]').textContent = 'Add Category';
    }
}
</file>

<file path="packages/backend/public/js/foodItems.js">
import { showMessage, apiGet, apiPost, apiPut, apiDelete } from './utils.js';
import { managers } from './main.js';

export class FoodItemManager {
    constructor(settingsManager) {
        this.settingsManager = settingsManager;
        this.form = document.getElementById('foodItemForm');
        this.tableBody = document.getElementById('foodItemTableBody');
        this.itemLimitValue = document.getElementById('itemLimitValue');
        this.resetButton = document.getElementById('resetFoodItemForm');
        this.categorySelect = document.getElementById('foodItemCategory');
        this.setupEventListeners();
    }

    setupEventListeners() {
        this.form.addEventListener('submit', this.handleSubmit.bind(this));
        this.resetButton.addEventListener('click', () => this.resetForm());
        this.itemLimitValue.addEventListener('input', this.handleLimitValidation.bind(this));
    }

    async loadCategories() {
        try {
            const data = await apiGet('/api/categories');
            this.categorySelect.innerHTML = data.data
                .map(category => `<option value="${category.id}">${category.name}</option>`)
                .join('');
        } catch (error) {
            showMessage(error.message, 'error', 'foodItem');
        }
    }

    handleLimitValidation(e) {
        const globalUpperLimit = this.settingsManager.getCurrentLimit();
        let value = parseInt(e.target.value);

        if (isNaN(value) || value < 0) {
            e.target.value = 0;
        } else if (value > globalUpperLimit) {
            e.target.value = globalUpperLimit;
        }
    }

    async handleSubmit(e) {
        e.preventDefault();
        const data = this.collectFormData();
        const id = document.getElementById('foodItemId').value;

        try {
            if (id) {
                await apiPut(`/api/food-items/${id}`, data);
                showMessage('Food item updated successfully', 'success', 'foodItem');
            } else {
                await apiPost('/api/food-items', data);
                showMessage('Food item created successfully', 'success', 'foodItem');
            }
            this.resetForm();
            await this.loadFoodItems();
        } catch (error) {
            showMessage(error.message, 'error', 'foodItem');
        }
    }

    collectFormData() {
        const limitType = document.querySelector('input[name="limitType"]:checked').value;
        let itemLimit = parseInt(this.itemLimitValue.value);
        if (isNaN(itemLimit)) itemLimit = 0;
        if (itemLimit < 0) itemLimit = 0;

        const globalUpperLimit = this.settingsManager.getCurrentLimit();
        if (itemLimit > globalUpperLimit) itemLimit = globalUpperLimit;

        return {
            name: document.getElementById('foodItemName').value.trim(),
            categoryId: parseInt(document.getElementById('foodItemCategory').value),
            itemLimit,
            limitType,
            inStock: document.getElementById('foodItemInStock').checked,
            mustGo: document.getElementById('foodItemMustGo').checked,
            lowSupply: document.getElementById('foodItemLowSupply').checked,
            kosher: document.getElementById('foodItemKosher').checked,
            halal: document.getElementById('foodItemHalal').checked,
            vegetarian: document.getElementById('foodItemVegetarian').checked,
            vegan: document.getElementById('foodItemVegan').checked,
            glutenFree: document.getElementById('foodItemGlutenFree').checked,
            organic: document.getElementById('foodItemOrganic').checked,
            readyToEat: document.getElementById('foodItemReadyToEat').checked
        };
    }

    async loadFoodItems() {
        try {
            await this.loadCategories(); // Load categories for the dropdown
            const data = await apiGet('/api/food-items?includeOutOfStock=true');
            this.displayFoodItems(data.data);
            if (managers.translations) {
                await managers.translations.loadTranslations();
            }
        } catch (error) {
            showMessage(error.message, 'error', 'foodItem');
        }
    }

    displayFoodItems(foodItems) {
        if (!Array.isArray(foodItems) || foodItems.length === 0) {
            this.tableBody.innerHTML = '<tr><td colspan="7">No food items found</td></tr>';
            return;
        }

        this.tableBody.innerHTML = foodItems
            .map(item => this.createFoodItemRow(item))
            .join('');

        this.addTableEventListeners();
    }

    createFoodItemRow(item) {
        const status = this.formatStatus(item);
        const dietary = this.formatDietary(item);
        const limitDisplay = this.formatLimit(item);

        const itemData = {
            id: item.id,
            name: item.name,
            categoryId: item.category?.id,
            itemLimit: item.itemLimit,
            limitType: item.limitType,
            inStock: item.inStock,
            mustGo: item.mustGo,
            lowSupply: item.lowSupply,
            kosher: item.kosher,
            halal: item.halal,
            vegetarian: item.vegetarian,
            vegan: item.vegan,
            glutenFree: item.glutenFree,
            organic: item.organic,
            readyToEat: item.readyToEat
        };

        const itemDataString = JSON.stringify(itemData).replace(/'/g, "\\'");

        return `
            <tr>
                <td>${item.name}</td>
                <td>${item.category?.name || 'Unknown'}</td>
                <td>${status || 'None'}</td>
                <td>${dietary || 'None'}</td>
                <td>${limitDisplay}</td>
                <td>${new Date(item.createdAt).toLocaleDateString()}</td>
                <td>
                    <button class="edit-food-item-btn" data-item='${itemDataString}'>
                        Edit
                    </button>
                    <button class="delete-food-item-btn" data-id="${item.id}">
                        Delete
                    </button>
                </td>
            </tr>
        `;
    }

    addTableEventListeners() {
        this.tableBody.querySelectorAll('.edit-food-item-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const itemData = btn.getAttribute('data-item');
                this.editFoodItem(itemData);
            });
        });

        this.tableBody.querySelectorAll('.delete-food-item-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const { id } = btn.dataset;
                this.deleteFoodItem(id);
            });
        });
    }

    formatStatus(item) {
        return [
            item.inStock ? 'In Stock' : 'Out of Stock',
            item.mustGo ? 'Must Go' : '',
            item.lowSupply ? 'Low Supply' : '',
            item.readyToEat ? 'Ready to Eat' : ''
        ].filter(Boolean).join(', ');
    }

    formatDietary(item) {
        return [
            item.kosher ? 'Kosher' : '',
            item.halal ? 'Halal' : '',
            item.vegetarian ? 'Vegetarian' : '',
            item.vegan ? 'Vegan' : '',
            item.glutenFree ? 'GF' : '',
            item.organic ? 'Organic' : ''
        ].filter(Boolean).join(', ');
    }

    formatLimit(item) {
        if (item.itemLimit === 0) {
            return 'No Limit';
        }
        const limitType = item.limitType === 'perPerson' ? 'Per Person' : 'Per Household';
        return `${item.itemLimit} ${limitType}`;
    }

    editFoodItem(itemData) {
        const data = typeof itemData === 'string' ? JSON.parse(itemData) : itemData;
        this.populateForm(data);
        this.form.querySelector('button[type="submit"]').textContent = 'Update Food Item';
    }

    populateForm(data) {
        document.getElementById('foodItemId').value = data.id;
        document.getElementById('foodItemName').value = data.name;
        document.getElementById('foodItemCategory').value = data.categoryId;
        document.getElementById('foodItemInStock').checked = data.inStock;
        document.getElementById('foodItemMustGo').checked = data.mustGo;
        document.getElementById('foodItemLowSupply').checked = data.lowSupply;
        document.getElementById('foodItemKosher').checked = data.kosher;
        document.getElementById('foodItemHalal').checked = data.halal;
        document.getElementById('foodItemVegetarian').checked = data.vegetarian;
        document.getElementById('foodItemVegan').checked = data.vegan;
        document.getElementById('foodItemGlutenFree').checked = data.glutenFree;
        document.getElementById('foodItemOrganic').checked = data.organic;
        document.getElementById('foodItemReadyToEat').checked = data.readyToEat;

        const globalUpperLimit = this.settingsManager.getCurrentLimit();
        const limitTypeInputs = document.querySelectorAll('input[name="limitType"]');
        
        limitTypeInputs.forEach(r => {
            r.checked = (r.value === data.limitType);
        });

        const limitValue = Math.min(data.itemLimit, globalUpperLimit);
        this.itemLimitValue.value = limitValue;
    }

    async deleteFoodItem(id) {
        if (!confirm('Are you sure you want to delete this food item?')) return;
        
        try {
            await apiDelete(`/api/food-items/${id}`);
            showMessage('Food item deleted successfully', 'success', 'foodItem');
            await this.loadFoodItems();
        } catch (error) {
            showMessage(error.message, 'error', 'foodItem');
        }
    }

    resetForm() {
        this.form.reset();
        document.getElementById('foodItemId').value = '';
        this.form.querySelector('button[type="submit"]').textContent = 'Add Food Item';
    }
}
</file>

<file path="packages/backend/public/js/languages.js">
import { showMessage, apiGet, apiPost } from './utils.js';

export class LanguageManager {
    constructor() {
        this.languageTableBody = document.getElementById('languageTableBody');
        this.updateLanguagesBtn = document.getElementById('updateLanguages');
        this.languageGrid = document.querySelector('.language-grid');
        this.setupEventListeners();
    }

    setupEventListeners() {
        this.updateLanguagesBtn.addEventListener('click', () => this.handleLanguageUpdate());
    }

    async loadLanguages() {
        try {
            const data = await apiGet('/api/languages');
            this.displayLanguages(data.data);
            this.displayLanguageToggles(data.data);
        } catch (error) {
            showMessage(error.message, 'error', 'language');
        }
    }

    displayLanguageToggles(languages) {
        this.languageGrid.innerHTML = languages.map(lang => `
            <div class="language-toggle">
                <label>
                    <input type="checkbox" 
                           class="language-checkbox" 
                           data-code="${lang.code}"
                           data-name="${lang.name}"
                           ${lang.active ? 'checked' : ''}>
                    ${lang.name}
                </label>
            </div>
        `).join('');
    }

    async handleLanguageUpdate() {
        try {
            const languages = Array.from(document.querySelectorAll('.language-checkbox'))
                .filter(checkbox => checkbox.checked)
                .map(checkbox => ({
                    code: checkbox.dataset.code,
                    name: checkbox.dataset.name
                }));

            await apiPost('/api/languages/bulk', { languages });
            showMessage('Language settings updated successfully', 'success', 'language');
            await this.loadLanguages();
            document.dispatchEvent(new Event('languagesUpdated'));
        } catch (error) {
            showMessage(error.message, 'error', 'language');
        }
    }

    displayLanguages(languages) {
        if (!Array.isArray(languages)) {
            showMessage('Invalid language data received', 'error', 'language');
            return;
        }

        this.languageTableBody.innerHTML = languages
            .map(lang => this.createLanguageRow(lang))
            .join('');
    }

    createLanguageRow(language) {
        return `
            <tr>
                <td class="table__cell">${language.code}</td>
                <td class="table__cell">${language.name}</td>
                <td class="table__cell">${language.active ? 'Active' : 'Inactive'}</td>
            </tr>
        `;
    }
}
</file>

<file path="packages/backend/public/js/main.js">
import { SettingsManager } from './settings.js';
import { LanguageManager } from './languages.js';
import { CategoryManager } from './categories.js';
import { FoodItemManager } from './foodItems.js';
import { TranslationManager } from './translations.js';

// Initialize managers and export them for module access
export const managers = {
    settings: null,
    languages: null,
    categories: null,
    foodItems: null,
    translations: null
};

// Initialize application
document.addEventListener('DOMContentLoaded', async () => {
    try {
        // Create instances
        managers.settings = new SettingsManager();
        managers.languages = new LanguageManager();
        managers.categories = new CategoryManager();
        managers.foodItems = new FoodItemManager(managers.settings);
        managers.translations = new TranslationManager();
        
        // Initial data loads
        await managers.settings.loadGlobalSettings();
        await managers.languages.loadLanguages();
        await managers.categories.loadCategories();
        await managers.foodItems.loadFoodItems();
        await managers.translations.loadTranslations();

        console.log('Application initialized successfully');
    } catch (error) {
        console.error('Error during initialization:', error);
    }
});
</file>

<file path="packages/backend/public/js/settings.js">
import { showMessage, apiGet, apiPost } from './utils.js';

export class SettingsManager {
    constructor() {
        this.globalUpperLimitInput = document.getElementById('globalUpperLimit');
        this.saveGlobalLimitBtn = document.getElementById('saveGlobalLimit');
        this.setupEventListeners();
    }

    setupEventListeners() {
        this.saveGlobalLimitBtn.addEventListener('click', () => this.saveGlobalSettings());
        this.globalUpperLimitInput.addEventListener('input', this.handleInputValidation.bind(this));
        this.globalUpperLimitInput.setAttribute('type', 'number');
        this.globalUpperLimitInput.setAttribute('min', '1');
    }

    async loadGlobalSettings() {
        try {
            const data = await apiGet('/api/settings');
            this.globalUpperLimitInput.value = data.data.globalUpperLimit;
        } catch (error) {
            showMessage(error.message, 'error', 'settings');
        }
    }

    async saveGlobalSettings() {
        const globalUpperLimit = parseInt(this.globalUpperLimitInput.value);
        if (isNaN(globalUpperLimit) || globalUpperLimit < 1) {
            showMessage('Global upper limit must be at least 1', 'error', 'settings');
            this.globalUpperLimitInput.value = 1;
            return;
        }

        try {
            await apiPost('/api/settings', { globalUpperLimit });
            showMessage('Global upper limit saved successfully', 'success', 'settings');
        } catch (error) {
            showMessage(error.message, 'error', 'settings');
        }
    }

    handleInputValidation(e) {
        const value = parseInt(e.target.value);
        if (value < 1) {
            e.target.value = 1;
        }
    }

    getCurrentLimit() {
        return parseInt(this.globalUpperLimitInput.value) || 10;
    }
}
</file>

<file path="packages/backend/public/js/translations.js">
import { showMessage, apiGet, apiPut, apiDelete } from './utils.js';

export class TranslationManager {
    constructor() {
        this.translationTableBody = document.getElementById('translationTableBody');
        this.translationTypeRadios = document.querySelectorAll('input[name="translationType"]');
        this.filterLanguageSelect = document.getElementById('filterLanguage');
        this.setupEventListeners();
        this.currentType = 'category';
        this.loadLanguagesFilter();
    }

    async loadLanguagesFilter() {
        try {
            const data = await apiGet('/api/languages');
            this.updateLanguageFilter(data.data);
        } catch (error) {
            showMessage(error.message, 'error', 'translation');
        }
    }

    updateLanguageFilter(languages) {
        if (!this.filterLanguageSelect) return;
        
        const currentValue = this.filterLanguageSelect.value;
        this.filterLanguageSelect.innerHTML = `
            <option value="">All Languages</option>
            ${languages
                .map(lang => `<option value="${lang.code}" ${lang.code === currentValue ? 'selected' : ''}>${lang.name}</option>`)
                .join('')}
        `;
    }

    isTypeCategory() {
        return this.currentType === 'category';
    }

    isTypeFoodItem() {
        return this.currentType === 'foodItem';
    }

    setupEventListeners() {
        this.translationTypeRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                this.currentType = radio.value;
                this.loadTranslations();
            });
        });

        this.filterLanguageSelect.addEventListener('change', () => {
            this.loadTranslations();
        });

        document.addEventListener('languagesUpdated', () => {
            this.loadLanguagesFilter();
            this.loadTranslations();
        });

        this.addTableEventListeners();
    }

    addTableEventListeners() {
        this.translationTableBody.addEventListener('click', async (e) => {
            const target = e.target;
            if (target.classList.contains('edit-translation-btn')) {
                await this.handleEditTranslation(target);
            } else if (target.classList.contains('delete-translation-btn')) {
                await this.handleDeleteTranslation(target);
            }
        });
    }

    async loadTranslations() {
        try {
            const type = this.currentType;
            const languageCode = this.filterLanguageSelect.value;
            const queryParams = new URLSearchParams({ type });
            if (languageCode) {
                queryParams.append('languageCode', languageCode);
            }
            
            const response = await apiGet(`/api/translations?${queryParams}`);
            this.displayTranslations(response.data);
        } catch (error) {
            showMessage(error.message, 'error', 'translation');
        }
    }

    displayTranslations(translations) {
        this.translationTableBody.innerHTML = '';
        if (!translations || translations.length === 0) {
            this.translationTableBody.innerHTML = '<tr><td colspan="6">No translations found</td></tr>';
            return;
        }
        translations.forEach(translation => {
            const row = this.createTranslationRow(translation);
            this.translationTableBody.appendChild(row);
        });
    }

    createTranslationRow(translation) {
        const row = document.createElement('tr');
        const originalText = translation.category ? translation.category.name : 
                           (translation.foodItem ? translation.foodItem.name : '');
        
        row.innerHTML = `
            <td class="table__cell">${originalText}</td>
            <td class="table__cell">${translation.language.name}</td>
            <td class="table__cell">${translation.translatedText}</td>
            <td class="table__cell">${translation.category ? 'Category' : 'Food Item'}</td>
            <td class="table__cell">${new Date(translation.createdAt).toLocaleDateString()}</td>
            <td class="table__cell">
                <button class="edit-translation-btn" 
                        data-id="${translation.id}"
                        data-current-text="${translation.translatedText}">
                    Edit
                </button>
                <button class="delete-translation-btn" data-id="${translation.id}">
                    Delete
                </button>
            </td>
        `;
        
        return row;
    }

    async handleEditTranslation(button) {
        const id = button.dataset.id;
        const currentText = button.dataset.currentText;
        const newText = prompt('Enter new translation:', currentText);
        
        if (newText && newText !== currentText) {
            try {
                await apiPut(`/api/translations/${id}`, { translatedText: newText });
                showMessage('Translation updated successfully', 'success', 'translation');
                await this.loadTranslations();
            } catch (error) {
                showMessage(error.message, 'error', 'translation');
            }
        }
    }

    async handleDeleteTranslation(button) {
        const id = button.dataset.id;
        if (confirm('Are you sure you want to delete this translation?')) {
            try {
                await apiDelete(`/api/translations/${id}`);
                showMessage('Translation deleted successfully', 'success', 'translation');
                await this.loadTranslations();
            } catch (error) {
                showMessage(error.message, 'error', 'translation');
            }
        }
    }

    updateTranslationTargets() {
        this.loadTranslations();
    }
}
</file>

<file path="packages/backend/public/js/utils.js">
export function showMessage(message, type = 'info', section = null) {
    const messageArea = section ? 
        document.querySelector(`#${section}Section .message-area`) : 
        document.getElementById('messageArea');
    
    if (!messageArea) return;

    const messageElement = document.createElement('div');
    messageElement.className = `message message--${type}`;
    messageElement.textContent = message;
    
    messageArea.innerHTML = '';
    messageArea.appendChild(messageElement);

    if (type === 'success') {
        setTimeout(() => messageElement.remove(), 5000);
    }
}

export function clearMessages(section = null) {
    const messageArea = section ? 
        document.querySelector(`#${section}Section .message-area`) : 
        document.getElementById('messageArea');
    
    if (messageArea) {
        messageArea.innerHTML = '';
    }
}

export async function apiGet(endpoint) {
    try {
        const response = await fetch(endpoint);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
    } catch (error) {
        console.error('API Get Error:', error);
        throw error;
    }
}

export async function apiPost(endpoint, data) {
    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data),
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
    } catch (error) {
        console.error('API Post Error:', error);
        throw error;
    }
}

export async function apiPut(endpoint, data) {
    try {
        const response = await fetch(endpoint, {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data),
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
    } catch (error) {
        console.error('API Put Error:', error);
        throw error;
    }
}

export async function apiDelete(endpoint) {
    try {
        const response = await fetch(endpoint, {
            method: 'DELETE',
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
    } catch (error) {
        console.error('API Delete Error:', error);
        throw error;
    }
}

export function formatDate(dateString) {
    const date = new Date(dateString);
    return new Intl.DateTimeFormat('default', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
    }).format(date);
}
</file>

<file path="packages/backend/public/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Food Pantry Management - Test UI</title>
    <link rel="stylesheet" href="css/styles.css" />
</head>
<body>
    <h1>Food Pantry Management - Test UI</h1>

    <!-- Global Settings -->
    <div id="settingsSection" class="section">
        <h2>Global Settings</h2>
        <div class="message-area"></div>
        <div class="form__group">
            <label for="globalUpperLimit">Global Upper Limit for "No Limit" Items:</label>
            <input type="number" id="globalUpperLimit" value="40" min="1">
            <button id="saveGlobalLimit">Save</button>
        </div>
        <p class="message message--note">
            This setting is now stored in the backend. Adjust it and click "Save" to persist.
            The "No Limit" items will consider this upper limit for future features.
        </p>
    </div>

    <!-- Language Management Section -->
    <div id="languageSection" class="section">
        <h2>Language Management</h2>
        <div class="message-area"></div>
        <p class="message message--warning">
            Note: Language support varies by region and complexity. AI translations may contain
            errors and should be reviewed for accuracy.
        </p>
        
        <div class="language-grid">
            <!-- Languages will be dynamically populated here -->
        </div>
        
        <button id="updateLanguages">Update Language Settings</button>
        
        <div id="activeLanguages">
            <h3>Active Languages</h3>
            <table class="table">
                <thead>
                    <tr>
                        <th class="table__header">Code</th>
                        <th class="table__header">Name</th>
                        <th class="table__header">Status</th>
                    </tr>
                </thead>
                <tbody id="languageTableBody">
                    <!-- Active languages will be loaded here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Category Management Section -->
    <div id="categorySection" class="section">
        <h2>Category Management</h2>
        <div class="message-area"></div>
        <form id="categoryForm">
            <div class="form__group">
                <label for="categoryName">Category Name:</label>
                <input type="text" id="categoryName" name="categoryName" required>
            </div>
            <input type="hidden" id="categoryId">
            <button type="submit">Add Category</button>
            <button type="button" id="resetForm">Clear Form</button>
        </form>
        <div id="categoryList">
            <h3>Categories</h3>
            <table class="table">
                <thead>
                    <tr>
                        <th class="table__header">Name</th>
                        <th class="table__header">Created</th>
                        <th class="table__header">Actions</th>
                    </tr>
                </thead>
                <tbody id="categoryTableBody">
                    <!-- Categories will be loaded here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Food Items Section -->
    <div id="foodItemSection" class="section">
        <h2>Food Item Management</h2>
        <div class="message-area"></div>
        <form id="foodItemForm">
            <div class="form__group">
                <label for="foodItemName">Item Name:</label>
                <input type="text" id="foodItemName" name="foodItemName" required>
            </div>
            <div class="form__group">
                <label for="foodItemCategory">Category:</label>
                <select id="foodItemCategory" required></select>
            </div>
            <div class="form__group">
                <label for="foodItemInStock">In Stock:</label>
                <input type="checkbox" id="foodItemInStock" name="foodItemInStock" checked>
            </div>
            <div class="form__group">
                <h4>Status Flags</h4>
                <div class="toggle-group">
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemMustGo" name="mustGo">
                        Must Go
                    </label>
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemLowSupply" name="lowSupply">
                        Low Supply
                    </label>
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemReadyToEat" name="readyToEat">
                        Ready to Eat
                    </label>
                </div>
            </div>
            <div class="form__group">
                <h4>Dietary Flags</h4>
                <div class="toggle-group">
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemKosher" name="kosher">
                        Kosher
                    </label>
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemHalal" name="halal">
                        Halal
                    </label>
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemVegetarian" name="vegetarian">
                        Vegetarian
                    </label>
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemVegan" name="vegan">
                        Vegan
                    </label>
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemGlutenFree" name="glutenFree">
                        Gluten Free
                    </label>
                    <label class="toggle-group__label">
                        <input type="checkbox" id="foodItemOrganic" name="organic">
                        Organic
                    </label>
                </div>
            </div>
            <div class="form__group">
                <h4>Item Limit</h4>
                <div class="limit-options">
                    <label>
                        <input type="radio" name="limitType" value="perHousehold" checked>
                        Per Household
                    </label>
                    <label>
                        <input type="radio" name="limitType" value="perPerson">
                        Per Person
                    </label>
                    <div>
                        <label for="itemLimitValue">Limit Value:</label>
                        <input type="number" id="itemLimitValue" min="0" value="0">
                        <p class="message message--note">
                            Set to 0 for no limit. Global Upper Limit applies as a maximum threshold.
                        </p>
                    </div>
                </div>
            </div>
            <input type="hidden" id="foodItemId">
            <button type="submit">Add Food Item</button>
            <button type="button" id="resetFoodItemForm">Clear Form</button>
        </form>
        <div id="foodItemList">
            <h3>Food Items</h3>
            <table class="table">
                <thead>
                    <tr>
                        <th class="table__header">Name</th>
                        <th class="table__header">Category</th>
                        <th class="table__header">Status</th>
                        <th class="table__header">Dietary</th>
                        <th class="table__header">Limit</th>
                        <th class="table__header">Created</th>
                        <th class="table__header">Actions</th>
                    </tr>
                </thead>
                <tbody id="foodItemTableBody">
                    <!-- Food items will be loaded here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Translations Section -->
    <div id="translationSection" class="section">
        <h2>Translation Management</h2>
        <div class="message-area"></div>
        <p class="message message--note">
            Translations are automatically generated for all active languages.
            Manual edits may be overwritten during automated translation updates.
        </p>
        
        <div class="filter-controls">
            <div class="translation-type">
                <label>
                    <input type="radio" name="translationType" value="category" checked>
                    Categories
                </label>
                <label>
                    <input type="radio" name="translationType" value="foodItem">
                    Food Items
                </label>
            </div>
    
            <div class="language-filter">
                <label for="filterLanguage">Filter By Language:</label>
                <select id="filterLanguage">
                    <option value="">All Languages</option>
                </select>
            </div>
        </div>
    
        <div id="translationList">
            <table class="table">
                <thead>
                    <tr>
                        <th class="table__header">Original Text</th>
                        <th class="table__header">Language</th>
                        <th class="table__header">Translation</th>
                        <th class="table__header">Type</th>
                        <th class="table__header">Created</th>
                        <th class="table__header">Actions</th>
                    </tr>
                </thead>
                <tbody id="translationTableBody"></tbody>
            </table>
        </div>
    </div>

    <!-- Load main.js as a module, which will import other JS modules -->
    <script type="module" src="js/main.js"></script>
</body>
</html>
</file>

<file path="packages/backend/src/config/languageConfig.ts">
export const LanguageConfig = {
    DEFAULT_LANGUAGE: 'en',
    SUPPORTED_LANGUAGES: [
        { code: 'ar', name: 'Arabic' },
        { code: 'bn', name: 'Bengali' },
        { code: 'de', name: 'German' },
        { code: 'en', name: 'English' },
        { code: 'es', name: 'Spanish' },
        { code: 'fr', name: 'French' },
        { code: 'hi', name: 'Hindi' },
        { code: 'id', name: 'Indonesian' },
        { code: 'it', name: 'Italian' },
        { code: 'ja', name: 'Japanese' },
        { code: 'ko', name: 'Korean' },
        { code: 'ms', name: 'Malay' },
        { code: 'pt', name: 'Portuguese' },
        { code: 'ru', name: 'Russian' },
        { code: 'th', name: 'Thai' },
        { code: 'tr', name: 'Turkish' },
        { code: 'uk', name: 'Ukrainian' },
        { code: 'ur', name: 'Urdu' },
        { code: 'vi', name: 'Vietnamese' },
        { code: 'zh', name: 'Chinese' }
    ]
};

export const isValidLanguageCode = (code: string): boolean => {
    return LanguageConfig.SUPPORTED_LANGUAGES.some(lang => lang.code === code);
};

export const getLanguageName = (code: string): string => {
    const language = LanguageConfig.SUPPORTED_LANGUAGES.find(lang => lang.code === code);
    return language ? language.name : code;
};
</file>

<file path="packages/backend/src/middleware/errorHandler.ts">
import { Request, Response, NextFunction } from 'express';
import { ApiError, isApiError } from '../utils/ApiError';
import { SettingsValidationError } from '../utils/ApiError';

export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  // Handle known ApiError types
  if (isApiError(err)) {
    return res.status(err.statusCode).json({
      success: false,
      status: err.statusCode,
      message: err.message,
      stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
  }

  // Handle settings-specific errors
  if (err instanceof SettingsValidationError) {
    return res.status(400).json({
      success: false,
      status: 400,
      message: err.message,
      stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
  }

  // Handle unknown errors
  return res.status(500).json({
    success: false,
    status: 500,
    message: 'Internal Server Error',
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
  });
};
</file>

<file path="packages/backend/src/middleware/requestLogger.ts">
import { Request, Response, NextFunction } from 'express';

export const requestLogger = (req: Request, res: Response, next: NextFunction) => {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] ${req.method} ${req.url}`);
  next();
};
</file>

<file path="packages/backend/src/routes/categoryRoutes.ts">
import { Router } from 'express';
import { CategoryService } from '../services/CategoryService';
import { ApiResponse } from '../utils/ApiResponse';
import { ApiError } from '../utils/ApiError';

const router = Router();
const categoryService = new CategoryService();

// GET /categories
router.get('/', async (req, res, next) => {
    try {
        const categories = await categoryService.findAll();
        res.json(ApiResponse.success(categories));
    } catch (error) {
        next(error);
    }
});

// GET /categories/:id
router.get('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid category ID');
        }

        const category = await categoryService.findById(id);
        if (!category) {
            throw new ApiError(404, 'Category not found');
        }

        res.json(ApiResponse.success(category));
    } catch (error) {
        next(error);
    }
});

// POST /categories
router.post('/', async (req, res, next) => {
    try {
        const { name } = req.body;
        if (!name || name.trim() === '') {
            return res.status(400).json(ApiResponse.error('Category name is required'));
        }

        const category = await categoryService.create({ name });
        res.status(201).json(ApiResponse.success(category, 'Category created successfully'));
    } catch (error) {
        next(error);
    }
});

// PUT /categories/:id
router.put('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid category ID');
        }

        const { name } = req.body;
        if (!name || name.trim() === '') {
            return res.status(400).json(ApiResponse.error('Category name is required'));
        }

        const category = await categoryService.update(id, { name });
        res.json(ApiResponse.success(category, 'Category updated successfully'));
    } catch (error) {
        next(error);
    }
});

// DELETE /categories/:id
router.delete('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid category ID');
        }

        await categoryService.delete(id);
        res.json(ApiResponse.success(null, 'Category deleted successfully'));
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="packages/backend/src/routes/foodItemRoutes.ts">
import { Router } from 'express';
import { FoodItemService } from '../services/FoodItemService';
import { ApiResponse } from '../utils/ApiResponse';
import { ApiError } from '../utils/ApiError';

const router = Router();
const foodItemService = new FoodItemService();

// GET /food-items
router.get('/', async (req, res, next) => {
  try {
    const { categoryId, includeOutOfStock, page, limit } = req.query;
    
    const params = {
      categoryId: categoryId ? parseInt(categoryId as string) : undefined,
      includeOutOfStock: includeOutOfStock === 'true',
      page: page ? parseInt(page as string) : 1,
      limit: limit ? parseInt(limit as string) : 50
    };

    const items = await foodItemService.findAll(params);
    return res.json(ApiResponse.success(items));
  } catch (error) {
    next(error);
  }
});

// GET /food-items/:id
router.get('/:id', async (req, res, next) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      throw new ApiError(400, 'Invalid food item ID');
    }

    const foodItem = await foodItemService.findById(id);
    res.json(ApiResponse.success(foodItem));
  } catch (error) {
    next(error);
  }
});

// POST /food-items
router.post('/', async (req, res, next) => {
  try {
    const { 
      name, 
      categoryId,
      itemLimit,
      inStock,
      mustGo,
      lowSupply,
      kosher,
      halal,
      vegetarian,
      vegan,
      glutenFree,
      organic,
      readyToEat,
      customFields 
    } = req.body;

    if (!name || typeof name !== 'string') {
      throw new ApiError(400, 'Name is required and must be a string');
    }

    if (!categoryId || typeof categoryId !== 'number') {
      throw new ApiError(400, 'Valid category ID is required');
    }

    const foodItem = await foodItemService.create({
      name,
      categoryId,
      itemLimit,
      inStock,
      mustGo,
      lowSupply,
      kosher,
      halal,
      vegetarian,
      vegan,
      glutenFree,
      organic,
      readyToEat,
      customFields
    });

    res.status(201).json(ApiResponse.success(foodItem, 'Food item created successfully'));
  } catch (error) {
    next(error);
  }
});

// PUT /food-items/:id
router.put('/:id', async (req, res, next) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      throw new ApiError(400, 'Invalid food item ID');
    }

    console.log('Update Food Item - Request Body:', req.body);
    console.log('Update Food Item - ID:', id);

    // Check if the item exists
    const existingItem = await foodItemService.findById(id);
    if (!existingItem) {
      throw new ApiError(404, 'Food item not found');
    }

    console.log('Existing Item Found:', existingItem);

    // Type check categoryId
    if (req.body.categoryId && typeof req.body.categoryId !== 'number') {
      console.log('Invalid categoryId type:', typeof req.body.categoryId);
      throw new ApiError(400, 'Category ID must be a number');
    }

    // Validate update data
    const updateData = {
      name: req.body.name,
      categoryId: req.body.categoryId,
      itemLimit: req.body.itemLimit,
      limitType: req.body.limitType,
      inStock: req.body.inStock,
      mustGo: req.body.mustGo,
      lowSupply: req.body.lowSupply,
      kosher: req.body.kosher,
      halal: req.body.halal,
      vegetarian: req.body.vegetarian,
      vegan: req.body.vegan,
      glutenFree: req.body.glutenFree,
      organic: req.body.organic,
      readyToEat: req.body.readyToEat
    };

    console.log('Processed Update Data:', updateData);

    const foodItem = await foodItemService.update(id, updateData);
    console.log('Update Successful:', foodItem);

    res.json(ApiResponse.success(foodItem, 'Food item updated successfully'));
  } catch (error) {
    console.error('Update Error:', error);
    next(error);
  }
});

// DELETE /food-items/:id
router.delete('/:id', async (req, res, next) => {
  try {
    const id = parseInt(req.params.id);
    if (isNaN(id)) {
      throw new ApiError(400, 'Invalid food item ID');
    }

    // Check if the item exists
    const existingItem = await foodItemService.findById(id);
    if (!existingItem) {
      throw new ApiError(404, 'Food item not found');
    }

    await foodItemService.delete(id);
    res.json(ApiResponse.success(null, 'Food item deleted successfully'));
  } catch (error) {
    next(error);
  }
});

export default router;
</file>

<file path="packages/backend/src/routes/languageRoutes.ts">
import { Router } from 'express';
import { PrismaClient } from '@prisma/client';
import { ApiResponse } from '../utils/ApiResponse';
import { ApiError } from '../utils/ApiError';

const router = Router();
const prisma = new PrismaClient();

// GET /api/languages
router.get('/', async (req, res, next) => {
    try {
        const languages = await prisma.language.findMany({
            orderBy: { code: 'asc' }
        });
        res.json(ApiResponse.success(languages));
    } catch (error) {
        next(error);
    }
});

// POST /api/languages/bulk
router.post('/bulk', async (req, res, next) => {
    try {
        const { languages } = req.body;
        
        if (!Array.isArray(languages)) {
            throw new ApiError(400, 'Invalid languages data');
        }

        // Deactivate all languages first
        await prisma.language.updateMany({
            data: { active: false }
        });

        // Upsert each language
        const operations = languages.map(lang => 
            prisma.language.upsert({
                where: { code: lang.code },
                update: { 
                    name: lang.name,
                    active: true
                },
                create: {
                    code: lang.code,
                    name: lang.name,
                    active: true
                }
            })
        );

        await prisma.$transaction(operations);

        const updatedLanguages = await prisma.language.findMany({
            where: { active: true },
            orderBy: { code: 'asc' }
        });

        res.json(ApiResponse.success(updatedLanguages, 'Languages updated successfully'));
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="packages/backend/src/routes/settingsRoutes.ts">
import { Router } from 'express';
import { PrismaClient } from '@prisma/client';
import { ApiResponse } from '../utils/ApiResponse';
import { SettingsValidationError } from '../utils/ApiError';

const router = Router();
const prisma = new PrismaClient();

// GET /api/settings
router.get('/', async (req, res, next) => {
    try {
        const settings = await prisma.settings.findUnique({
            where: { id: 1 }
        });

        // If no settings exist, return default value of 10
        if (!settings) {
            return res.json(ApiResponse.success({
                globalUpperLimit: 10
            }));
        }

        res.json(ApiResponse.success({
            globalUpperLimit: settings.globalUpperLimit
        }));
    } catch (error) {
        next(error);
    }
});

// POST /api/settings
router.post('/', async (req, res, next) => {
    try {
        const { globalUpperLimit } = req.body;

        // Validate input
        if (globalUpperLimit === undefined || globalUpperLimit === null) {
            throw new SettingsValidationError('Global upper limit is required');
        }

        if (typeof globalUpperLimit !== 'number' || !Number.isInteger(globalUpperLimit)) {
            throw new SettingsValidationError('Global upper limit must be an integer');
        }

        if (globalUpperLimit < 1) {
            throw new SettingsValidationError('Global upper limit must be at least 1');
        }

        const settings = await prisma.settings.upsert({
            where: { id: 1 },
            update: {
                globalUpperLimit,
                updatedAt: new Date()
            },
            create: {
                globalUpperLimit,
                id: 1
            }
        });

        res.json(ApiResponse.success(settings, 'Settings updated successfully'));
    } catch (error) {
        next(error);
    } finally {
        await prisma.$disconnect(); // Ensure Prisma disconnects after handling the request
    }
});

export default router;
</file>

<file path="packages/backend/src/routes/translationRoutes.ts">
import { Router } from 'express';
import { TranslationService } from '../services/TranslationService';
import { ApiResponse } from '../utils/ApiResponse';
import { ApiError } from '../utils/ApiError';

const router = Router();
const translationService = new TranslationService();

// GET /translations
router.get('/', async (req, res, next) => {
    try {
        const { languageCode, categoryId, foodItemId, type } = req.query;
        console.log('Translation query params:', { languageCode, categoryId, foodItemId, type });

        if (type && !['category', 'foodItem'].includes(type as string)) {
            throw new ApiError(400, 'Invalid type parameter. Must be either "category" or "foodItem"');
        }

        const params = {
            languageCode: languageCode as string,
            categoryId: categoryId ? parseInt(categoryId as string) : undefined,
            foodItemId: foodItemId ? parseInt(foodItemId as string) : undefined,
            type: type as 'category' | 'foodItem' | undefined
        };
        console.log('Processed params:', params);

        const translations = await translationService.findAll(params);
        console.log('Found translations:', translations);

        res.json(ApiResponse.success(translations));
    } catch (error) {
        console.error('Translation error:', error);
        next(error);
    }
});

// GET /translations/language/:languageCode
router.get('/language/:languageCode', async (req, res, next) => {
    try {
        const { languageCode } = req.params;
        const { categoryId, foodItemId } = req.query;

        const params = {
            categoryId: categoryId ? parseInt(categoryId as string) : undefined,
            foodItemId: foodItemId ? parseInt(foodItemId as string) : undefined
        };

        const translations = await translationService.findByLanguage(languageCode, params);
        res.json(ApiResponse.success(translations));
    } catch (error) {
        next(error);
    }
});

// POST /translations/category/:categoryId
router.post('/category/:categoryId', async (req, res, next) => {
    try {
        const categoryId = parseInt(req.params.categoryId);
        if (isNaN(categoryId)) {
            throw new ApiError(400, 'Invalid category ID');
        }

        const { languageCode, translatedText } = req.body;
        if (!languageCode || !translatedText) {
            throw new ApiError(400, 'Language code and translated text are required');
        }

        const translation = await translationService.createForCategory(categoryId, {
            languageCode,
            translatedText
        });

        res.status(201).json(ApiResponse.success(translation, 'Translation created successfully'));
    } catch (error) {
        next(error);
    }
});

// POST /translations/food-item/:foodItemId
router.post('/food-item/:foodItemId', async (req, res, next) => {
    try {
        const foodItemId = parseInt(req.params.foodItemId);
        if (isNaN(foodItemId)) {
            throw new ApiError(400, 'Invalid food item ID');
        }

        const { languageCode, translatedText } = req.body;
        if (!languageCode || !translatedText) {
            throw new ApiError(400, 'Language code and translated text are required');
        }

        const translation = await translationService.createForFoodItem(foodItemId, {
            languageCode,
            translatedText
        });

        res.status(201).json(ApiResponse.success(translation, 'Translation created successfully'));
    } catch (error) {
        next(error);
    }
});

// GET /translations/:id
router.get('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid translation ID');
        }

        const translation = await translationService.findById(id);
        res.json(ApiResponse.success(translation));
    } catch (error) {
        next(error);
    }
});

// PUT /translations/:id
router.put('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid translation ID');
        }

        const translation = await translationService.findById(id);
        if (!translation) {
            throw new ApiError(404, 'Translation not found');
        }

        const { translatedText } = req.body;
        if (!translatedText) {
            throw new ApiError(400, 'Translated text is required');
        }

        const updatedTranslation = await translationService.update(id, { translatedText });
        res.json(ApiResponse.success(updatedTranslation, 'Translation updated successfully'));
    } catch (error) {
        next(error);
    }
});

// DELETE /translations/:id
router.delete('/:id', async (req, res, next) => {
    try {
        const id = parseInt(req.params.id);
        if (isNaN(id)) {
            throw new ApiError(400, 'Invalid translation ID');
        }

        const translation = await translationService.findById(id);
        if (!translation) {
            throw new ApiError(404, 'Translation not found');
        }

        await translationService.delete(id);
        res.json(ApiResponse.success(null, 'Translation deleted successfully'));
    } catch (error) {
        next(error);
    }
});

export default router;
</file>

<file path="packages/backend/src/services/openai/__tests__/OpenAIService.test.ts">
import { OpenAIService } from '../OpenAIService';
import { ApiError } from '../../../utils/ApiError';

// Mock OpenAI responses
const mockCreateCompletion = jest.fn();
jest.mock('openai', () => ({
    OpenAI: jest.fn().mockImplementation(() => ({
        chat: {
            completions: {
                create: mockCreateCompletion
            }
        }
    }))
}));

describe('OpenAIService', () => {
    let service: OpenAIService;

    beforeEach(() => {
        process.env.OPENAI_API_KEY = 'test-key';
        process.env.OPENAI_MODEL = 'gpt-4o-mini';
        mockCreateCompletion.mockClear();
        service = new OpenAIService();
    });

    describe('initialization', () => {
        it('should initialize with valid API key', () => {
            expect(() => new OpenAIService()).not.toThrow();
        });

        it('should throw error when API key is missing', () => {
            delete process.env.OPENAI_API_KEY;
            expect(() => new OpenAIService()).toThrow('OpenAI API key is not configured');
        });
    });

    describe('translateText', () => {
        beforeEach(() => {
            mockCreateCompletion.mockResolvedValue({
                choices: [{ message: { content: 'manzana', role: 'assistant' } }]
            });
        });

        it('should translate text successfully', async () => {
            const result = await service.translateText('apple', 'es', 'foodItem');
            expect(result).toBe('manzana');
            expect(mockCreateCompletion).toHaveBeenCalledWith(expect.objectContaining({
                temperature: 0.3,
                max_tokens: 100
            }));
        });

        it('should handle empty responses', async () => {
            mockCreateCompletion.mockResolvedValue({
                choices: [{ message: { content: '', role: 'assistant' } }]
            });
            await expect(service.translateText('apple', 'es', 'foodItem'))
                .rejects
                .toThrow('Translation failed - empty response');
        });

        it('should handle API errors', async () => {
            mockCreateCompletion.mockRejectedValue(new Error('API Error'));
            await expect(service.translateText('apple', 'es', 'foodItem'))
                .rejects
                .toThrow('Translation failed: API Error');
        });
    });

    describe('testConnection', () => {
        it('should return true for successful connection', async () => {
            mockCreateCompletion.mockResolvedValue({
                choices: [{ message: { content: 'OK', role: 'assistant' } }]
            });
            const result = await service.testConnection();
            expect(result).toBe(true);
        });

        it('should return false for failed connection', async () => {
            mockCreateCompletion.mockRejectedValue(new Error('Connection failed'));
            const result = await service.testConnection();
            expect(result).toBe(false);
        });
    });

    describe('bulkTranslate', () => {
        const testItems = [
            { id: 1, text: 'apple' },
            { id: 2, text: 'banana' }
        ];

        beforeEach(() => {
            mockCreateCompletion
                .mockResolvedValueOnce({
                    choices: [{ message: { content: 'manzana', role: 'assistant' } }]
                })
                .mockResolvedValueOnce({
                    choices: [{ message: { content: 'pltano', role: 'assistant' } }]
                });
        });

        it('should translate multiple items successfully', async () => {
            const results = await service.bulkTranslate(testItems, 'es', 'foodItem');
            expect(results).toEqual([
                { id: 1, translation: 'manzana' },
                { id: 2, translation: 'pltano' }
            ]);
        });

        it('should handle partial failures in bulk translation', async () => {
            mockCreateCompletion
                .mockResolvedValueOnce({
                    choices: [{ message: { content: 'manzana', role: 'assistant' } }]
                })
                .mockRejectedValueOnce(new Error('API Error'));

            const results = await service.bulkTranslate(testItems, 'es', 'foodItem');
            expect(results).toEqual([
                { id: 1, translation: 'manzana' },
                { id: 2, translation: '' }
            ]);
        });

        it('should respect rate limiting with delays', async () => {
            const startTime = Date.now();
            await service.bulkTranslate(testItems, 'es', 'foodItem');
            const duration = Date.now() - startTime;
            expect(duration).toBeGreaterThanOrEqual(200); // At least 200ms delay
        });
    });
});
</file>

<file path="packages/backend/src/services/openai/OpenAIService.ts">
import { OpenAI } from 'openai';
import { ApiError } from '../../utils/ApiError';
import { LanguageConfig, getLanguageName } from '../../config/languageConfig';

export class OpenAIService {
    private client: OpenAI;
    private readonly maxRetries = 3;
    private readonly retryDelay = 1000; // 1 second

    constructor() {
        if (!process.env.OPENAI_API_KEY) {
            throw new ApiError(500, 'OpenAI API key is not configured');
        }
        this.client = new OpenAI({ 
            apiKey: process.env.OPENAI_API_KEY,
            maxRetries: this.maxRetries
        });
    }

    async translateText(
        text: string, 
        targetLanguage: string, 
        context: 'category' | 'foodItem'
    ): Promise<string> {
        const languageName = getLanguageName(targetLanguage);
        
        try {
            const systemPrompt = this.buildSystemPrompt(context, languageName);
            const response = await this.client.chat.completions.create({
                model: process.env.OPENAI_MODEL || 'gpt-4o-mini',
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: text }
                ],
                temperature: 0.3, // Lower temperature for more consistent translations
                max_tokens: 100  // Limit response length for efficiency
            });

            const translation = response.choices[0]?.message?.content?.trim();
            if (!translation) {
                throw new ApiError(500, 'Translation failed - empty response');
            }

            return translation;
        } catch (error) {
            console.error('Translation error:', error);
            throw new ApiError(500, `Translation failed: ${(error as Error).message}`);
        }
    }

    private buildSystemPrompt(context: 'category' | 'foodItem', languageName: string): string {
        const contextPrompts = {
            category: `You are a professional translator specializing in food categories. 
                      Translate the following category name to ${languageName}. 
                      Keep the translation concise and commonly used in food contexts.`,
            foodItem: `You are a professional translator specializing in food items. 
                      Translate the following food item name to ${languageName}. 
                      Use the most common term that would be recognized by native speakers.`
        };

        return contextPrompts[context];
    }

    async testConnection(): Promise<boolean> {
        try {
            const response = await this.client.chat.completions.create({
                model: process.env.OPENAI_MODEL || 'gpt-4o-mini',
                messages: [
                    { role: 'system', content: 'Respond with "OK" if you can read this.' },
                    { role: 'user', content: 'Connection test' }
                ],
                max_tokens: 5
            });
            
            return response.choices[0]?.message?.content?.includes('OK') ?? false;
        } catch (error) {
            console.error('OpenAI connection test failed:', error);
            return false;
        }
    }

    async bulkTranslate(
        items: Array<{ id: number; text: string }>, 
        targetLanguage: string, 
        context: 'category' | 'foodItem'
    ): Promise<Array<{ id: number; translation: string }>> {
        const results = [];
        
        for (const item of items) {
            try {
                const translation = await this.translateText(item.text, targetLanguage, context);
                results.push({ id: item.id, translation });
                // Add small delay between requests to respect rate limits
                await new Promise(resolve => setTimeout(resolve, 200));
            } catch (error) {
                console.error(`Translation failed for item ${item.id}:`, error);
                results.push({ id: item.id, translation: '' });
            }
        }

        return results;
    }
}
</file>

<file path="packages/backend/src/services/CategoryService.ts">
import { PrismaClient, Category } from '@prisma/client';
import { ApiError } from '../utils/ApiError';
import { TranslationService } from './TranslationService';
import { ErrorTypes, ErrorMessages } from '../utils/errorConstants';
import { handleServiceError } from '../utils/errorHandler';

export class CategoryService {
    private prisma: PrismaClient;
    private translationService: TranslationService;

    constructor() {
        this.prisma = new PrismaClient();
        this.translationService = new TranslationService();
    }

    async create(data: { name: string }): Promise<Category> {
        try {
            const category = await this.prisma.category.create({
                data,
                include: {
                    translations: {
                        include: {
                            language: true
                        }
                    }
                }
            });

            this.translationService.generateAutomaticTranslations(category.id, 'category')
                .catch(error => console.error('Translation generation failed:', error));

            return category;
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.CREATE_ERROR('category'));
        }
    }

    async findAll(): Promise<Category[]> {
        try {
            return await this.prisma.category.findMany({
                include: {
                    translations: {
                        include: {
                            language: true
                        }
                    }
                }
            });
        } catch (error) {
            throw handleServiceError(error, 'Error fetching categories');
        }
    }

    async findById(id: number): Promise<Category | null> {
        try {
            const category = await this.prisma.category.findUnique({
                where: { id },
                include: {
                    translations: {
                        include: {
                            language: true
                        }
                    }
                }
            });

            if (!category) {
                throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.CATEGORY_NOT_FOUND);
            }

            return category;
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.CATEGORY_NOT_FOUND);
        }
    }

    async update(id: number, data: { name: string }): Promise<Category> {
        try {
            const existingCategory = await this.findById(id);

            const updated = await this.prisma.category.update({
                where: { id },
                data,
                include: {
                    translations: {
                        include: {
                            language: true
                        }
                    }
                }
            });

            if (existingCategory && data.name !== existingCategory.name) {
                this.translationService.generateAutomaticTranslations(id, 'category')
                    .catch(error => console.error('Translation update failed:', error));
            }

            return updated;
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.UPDATE_ERROR('category'));
        }
    }

    async delete(id: number): Promise<void> {
        try {
            await this.findById(id);
            await this.prisma.category.delete({ where: { id } });
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.DELETE_ERROR('category'));
        }
    }
}
</file>

<file path="packages/backend/src/services/FoodItemService.ts">
import { PrismaClient, FoodItem, Prisma } from '@prisma/client';
import { ApiError } from '../utils/ApiError';
import { TranslationService } from './TranslationService';
import { ErrorTypes, ErrorMessages } from '../utils/errorConstants';
import { handleServiceError } from '../utils/errorHandler';

type FoodItemCreateInput = Prisma.FoodItemCreateInput;
type FoodItemUpdateInput = Prisma.FoodItemUpdateInput;

export class FoodItemService {
  private prisma: PrismaClient;
  private translationService: TranslationService;
  private testMode: boolean;

  constructor(testMode = false) {
    this.prisma = new PrismaClient();
    this.translationService = new TranslationService();
    this.testMode = testMode;
  }

  private async generateTranslations(foodItemId: number): Promise<void> {
    if (this.testMode) return;
    try {
      await this.translationService.generateAutomaticTranslations(foodItemId, 'foodItem');
    } catch (error) {
      console.error(`Failed to generate translations for food item ${foodItemId}:`, error);
    }
  }

  async create(data: {
    name: string;
    categoryId: number;
    imageUrl?: string;
    thumbnailUrl?: string;
    itemLimit?: number;
    limitType?: string;
    inStock?: boolean;
    mustGo?: boolean;
    lowSupply?: boolean;
    kosher?: boolean;
    halal?: boolean;
    vegetarian?: boolean;
    vegan?: boolean;
    glutenFree?: boolean;
    organic?: boolean;
    readyToEat?: boolean;
    customFields?: { key: string; value: string; }[];
  }): Promise<FoodItem> {
    try {
      const category = await this.prisma.category.findUnique({
        where: { id: data.categoryId }
      });

      if (!category) {
        throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_CATEGORY);
      }

      const { customFields, categoryId, ...foodItemData } = data;

      const createData: FoodItemCreateInput = {
        ...foodItemData,
        limitType: foodItemData.limitType || 'perHousehold',
        category: {
          connect: { id: categoryId }
        },
        customFields: customFields ? {
          create: customFields
        } : undefined
      };

      const foodItem = await this.prisma.foodItem.create({
        data: createData,
        include: {
          category: true,
          translations: {
            include: {
              language: true
            }
          },
          customFields: true
        }
      });

      this.generateTranslations(foodItem.id);

      return foodItem;
    } catch (error) {
      throw handleServiceError(error, ErrorMessages.CREATE_ERROR('food item'));
    }
  }

  async update(id: number, data: {
    name?: string;
    categoryId?: number;
    imageUrl?: string;
    thumbnailUrl?: string;
    itemLimit?: number;
    limitType?: string;
    inStock?: boolean;
    mustGo?: boolean;
    lowSupply?: boolean;
    kosher?: boolean;
    halal?: boolean;
    vegetarian?: boolean;
    vegan?: boolean;
    glutenFree?: boolean;
    organic?: boolean;
    readyToEat?: boolean;
    customFields?: { key: string; value: string; }[];
  }): Promise<FoodItem> {
    try {
      const existingItem = await this.prisma.foodItem.findUnique({
        where: { id },
        include: { customFields: true }
      });

      if (!existingItem) {
        throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.FOOD_ITEM_NOT_FOUND);
      }

      if (data.categoryId) {
        const category = await this.prisma.category.findUnique({
          where: { id: data.categoryId }
        });

        if (!category) {
          throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_CATEGORY);
        }
      }

      const { customFields, categoryId, ...updateData } = data;

      const prismaUpdateData: FoodItemUpdateInput = {
        ...updateData,
        ...(categoryId && {
          category: {
            connect: { id: categoryId }
          }
        })
      };

      const updatedItem = await this.prisma.foodItem.update({
        where: { id },
        data: prismaUpdateData,
        include: {
          category: true,
          translations: {
            include: {
              language: true
            }
          },
          customFields: true
        }
      });

      if (data.name && data.name !== existingItem.name) {
        this.generateTranslations(id);
      }

      return updatedItem;
    } catch (error) {
      throw handleServiceError(error, ErrorMessages.UPDATE_ERROR('food item'));
    }
  }

  async findById(id: number): Promise<FoodItem | null> {
    try {
      const item = await this.prisma.foodItem.findUnique({
        where: { id },
        include: {
          category: true,
          translations: {
            include: {
              language: true
            }
          }
        }
      });

      if (!item) {
        throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.FOOD_ITEM_NOT_FOUND);
      }

      return item;
    } catch (error) {
      throw handleServiceError(error, ErrorMessages.FOOD_ITEM_NOT_FOUND);
    }
  }

  async findAll(params: {
    categoryId?: number;
    includeOutOfStock?: boolean;
  } = {}): Promise<FoodItem[]> {
    try {
      const { categoryId, includeOutOfStock = true } = params;
      
      return await this.prisma.foodItem.findMany({
        where: {
          ...(categoryId && { categoryId }),
          ...(!includeOutOfStock && { inStock: true })
        },
        include: {
          category: true,
          translations: {
            include: {
              language: true
            }
          }
        }
      });
    } catch (error) {
      throw handleServiceError(error, 'Error fetching food items');
    }
  }

  async delete(id: number): Promise<void> {
    try {
      const existingItem = await this.findById(id);
      if (!existingItem) {
        throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.FOOD_ITEM_NOT_FOUND);
      }

      await this.prisma.foodItem.delete({
        where: { id }
      });
    } catch (error) {
      throw handleServiceError(error, ErrorMessages.DELETE_ERROR('food item'));
    }
  }
}
</file>

<file path="packages/backend/src/services/LanguageService.ts">
import { PrismaClient, Language } from '@prisma/client';
import { ApiError } from '../utils/ApiError';
import { TranslationService } from './TranslationService';

export class LanguageService {
    private prisma: PrismaClient;
    private translationService: TranslationService;

    constructor() {
        this.prisma = new PrismaClient();
        this.translationService = new TranslationService();
    }

    /**
     * Generates translations for all existing items when a language is activated
     */
    private async generateTranslationsForLanguage(languageCode: string): Promise<void> {
        try {
            // Get all categories and food items
            const [categories, foodItems] = await Promise.all([
                this.prisma.category.findMany(),
                this.prisma.foodItem.findMany()
            ]);

            // Generate translations for categories
            for (const category of categories) {
                await this.translationService.generateAutomaticTranslations(
                    category.id,
                    'category'
                ).catch(error => {
                    console.error(`Failed to translate category ${category.id} to ${languageCode}:`, error);
                });
            }

            // Generate translations for food items
            for (const item of foodItems) {
                await this.translationService.generateAutomaticTranslations(
                    item.id,
                    'foodItem'
                ).catch(error => {
                    console.error(`Failed to translate food item ${item.id} to ${languageCode}:`, error);
                });
            }
        } catch (error) {
            console.error(`Failed to generate translations for language ${languageCode}:`, error);
        }
    }

    /**
     * Adds a new language to the database.
     * Throws ApiError if the language code already exists.
     */
    async addLanguage(code: string, name?: string): Promise<Language> {
        if (!code || code.trim() === '') {
            throw new ApiError(400, 'Language code is required');
        }

        const existing = await this.prisma.language.findUnique({ where: { code } });
        if (existing) {
            throw new ApiError(400, `Language code '${code}' already exists`);
        }

        try {
            const lang = await this.prisma.language.create({
                data: {
                    code,
                    name: name || code.toUpperCase(),
                    active: true
                }
            });

            // Generate translations for new language asynchronously
            this.generateTranslationsForLanguage(code).catch(error => {
                console.error(`Failed to generate initial translations for ${code}:`, error);
            });

            return lang;
        } catch (error) {
            throw new ApiError(500, 'Error creating language');
        }
    }

    /**
     * Updates a language's active status or name.
     * Generates translations when a language is activated.
     */
    async update(id: number, data: { active?: boolean; name?: string }): Promise<Language> {
        try {
            const language = await this.prisma.language.update({
                where: { id },
                data
            });

            // If language is being activated, generate translations
            if (data.active === true) {
                this.generateTranslationsForLanguage(language.code).catch(error => {
                    console.error(`Failed to generate translations after activating ${language.code}:`, error);
                });
            }

            return language;
        } catch (error) {
            throw new ApiError(404, `Language with ID ${id} not found`);
        }
    }

    /**
     * Returns all languages.
     */
    async findAll(): Promise<Language[]> {
        try {
            return await this.prisma.language.findMany();
        } catch (error) {
            throw new ApiError(500, 'Error fetching languages');
        }
    }

    /**
     * Returns a language by code.
     * Throws ApiError if not found.
     */
    async findByCode(code: string): Promise<Language> {
        try {
            const lang = await this.prisma.language.findUnique({
                where: { code }
            });
            if (!lang) {
                throw new ApiError(404, `Language '${code}' not found`);
            }
            return lang;
        } catch (error) {
            if (error instanceof ApiError) throw error;
            throw new ApiError(500, 'Error fetching language');
        }
    }

    /**
     * Fetches all languages that are active.
     */
    async findActive(): Promise<Language[]> {
        try {
            return await this.prisma.language.findMany({
                where: { active: true }
            });
        } catch (error) {
            throw new ApiError(500, 'Error fetching active languages');
        }
    }

    /**
     * Regenerates all translations for a specific language
     */
    async regenerateAllTranslations(code: string): Promise<void> {
        const language = await this.findByCode(code);
        if (!language.active) {
            throw new ApiError(400, 'Cannot regenerate translations for inactive language');
        }

        await this.generateTranslationsForLanguage(code);
    }
}
</file>

<file path="packages/backend/src/services/TranslationService.ts">
import { PrismaClient } from '@prisma/client';
import { ApiError } from '../utils/ApiError';
import { OpenAIService } from './openai/OpenAIService';
import { LanguageConfig } from '../config/languageConfig';
import { ErrorTypes, ErrorMessages } from '../utils/errorConstants';
import { handleServiceError } from '../utils/errorHandler';

type ItemType = 'category' | 'foodItem';

interface CreateTranslationData {
    languageCode: string;
    translatedText: string;
    isAutomatic?: boolean;
}

export class TranslationService {
    private prisma: PrismaClient;
    private openAI: OpenAIService;

    constructor() {
        this.prisma = new PrismaClient();
        this.openAI = new OpenAIService();
    }

    async findAll(params: { 
        languageCode?: string; 
        categoryId?: number; 
        foodItemId?: number;
        type?: ItemType;
    }) {
        try {
            const whereClause: any = {
                AND: [
                    params.languageCode ? { language: { code: params.languageCode } } : {},
                    params.categoryId ? { categoryId: params.categoryId } : {},
                    params.foodItemId ? { foodItemId: params.foodItemId } : {}
                ]
            };

            if (params.type) {
                if (params.type === 'category') {
                    whereClause.AND.push({ categoryId: { not: null }, foodItemId: null });
                } else if (params.type === 'foodItem') {
                    whereClause.AND.push({ foodItemId: { not: null }, categoryId: null });
                }
            }

            return await this.prisma.translation.findMany({
                where: whereClause,
                include: { 
                    language: true,
                    category: true,
                    foodItem: true
                }
            });
        } catch (error) {
            throw handleServiceError(error, 'Error fetching translations');
        }
    }

    async findById(id: number) {
        try {
            const translation = await this.prisma.translation.findUnique({
                where: { id },
                include: { language: true }
            });

            if (!translation) {
                throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.TRANSLATION_NOT_FOUND);
            }

            return translation;
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.TRANSLATION_NOT_FOUND);
        }
    }

    async findByLanguage(languageCode: string, params: { categoryId?: number; foodItemId?: number }) {
        try {
            const language = await this.prisma.language.findFirst({
                where: { code: languageCode, active: true }
            });

            if (!language) {
                throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_LANGUAGE);
            }

            return await this.prisma.translation.findMany({
                where: {
                    languageId: language.id,
                    ...(params.categoryId && { categoryId: params.categoryId }),
                    ...(params.foodItemId && { foodItemId: params.foodItemId })
                },
                include: { language: true }
            });
        } catch (error) {
            throw handleServiceError(error, `Error fetching translations for language: ${languageCode}`);
        }
    }

    async createForCategory(categoryId: number, data: CreateTranslationData) {
        try {
            const category = await this.prisma.category.findUnique({
                where: { id: categoryId }
            });

            if (!category) {
                throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.CATEGORY_NOT_FOUND);
            }

            const language = await this.prisma.language.findFirst({
                where: { code: data.languageCode, active: true }
            });

            if (!language) {
                throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_LANGUAGE);
            }

            const existingTranslation = await this.prisma.translation.findFirst({
                where: {
                    categoryId,
                    languageId: language.id
                }
            });

            if (existingTranslation) {
                return this.update(existingTranslation.id, { 
                    translatedText: data.translatedText,
                    isAutomatic: data.isAutomatic ?? false
                });
            }

            return await this.prisma.translation.create({
                data: {
                    translatedText: data.translatedText,
                    categoryId,
                    languageId: language.id,
                    isAutomatic: data.isAutomatic ?? false
                },
                include: { language: true }
            });
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.CREATE_ERROR('category translation'));
        }
    }

    async createForFoodItem(foodItemId: number, data: CreateTranslationData) {
        try {
            const foodItem = await this.prisma.foodItem.findUnique({
                where: { id: foodItemId }
            });

            if (!foodItem) {
                throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages.FOOD_ITEM_NOT_FOUND);
            }

            const language = await this.prisma.language.findFirst({
                where: { code: data.languageCode, active: true }
            });

            if (!language) {
                throw new ApiError(ErrorTypes.VALIDATION, ErrorMessages.INVALID_LANGUAGE);
            }

            const existingTranslation = await this.prisma.translation.findFirst({
                where: {
                    foodItemId,
                    languageId: language.id
                }
            });

            if (existingTranslation) {
                return this.update(existingTranslation.id, { 
                    translatedText: data.translatedText,
                    isAutomatic: data.isAutomatic ?? false
                });
            }

            return await this.prisma.translation.create({
                data: {
                    translatedText: data.translatedText,
                    foodItemId,
                    languageId: language.id,
                    isAutomatic: data.isAutomatic ?? false
                },
                include: { language: true }
            });
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.CREATE_ERROR('food item translation'));
        }
    }

    async update(id: number, data: { translatedText: string; isAutomatic?: boolean }) {
        try {
            const translation = await this.findById(id);

            return await this.prisma.translation.update({
                where: { id },
                data: {
                    translatedText: data.translatedText,
                    isAutomatic: data.isAutomatic ?? translation.isAutomatic
                },
                include: { language: true }
            });
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.UPDATE_ERROR('translation'));
        }
    }

    async generateAutomaticTranslations(itemId: number, itemType: ItemType) {
        try {
            const item = itemType === 'category' 
                ? await this.prisma.category.findUnique({ where: { id: itemId } })
                : await this.prisma.foodItem.findUnique({ where: { id: itemId } });

            if (!item) {
                throw new ApiError(ErrorTypes.NOT_FOUND, ErrorMessages[itemType === 'category' ? 'CATEGORY_NOT_FOUND' : 'FOOD_ITEM_NOT_FOUND']);
            }

            const activeLanguages = await this.prisma.language.findMany({
                where: { active: true }
            });

            const results = [];
            for (const language of activeLanguages) {
                if (language.code === LanguageConfig.DEFAULT_LANGUAGE) continue;

                try {
                    const translation = await this.openAI.translateText(
                        item.name,
                        language.code,
                        itemType
                    );

                    const createMethod = itemType === 'category' 
                        ? this.createForCategory.bind(this)
                        : this.createForFoodItem.bind(this);

                    const savedTranslation = await createMethod(
                        itemId,
                        {
                            languageCode: language.code,
                            translatedText: translation,
                            isAutomatic: true
                        }
                    );

                    results.push(savedTranslation);
                } catch (error) {
                    console.error(`Failed translation for ${itemType} ${itemId} in ${language.code}:`, error);
                }
            }

            return results;
        } catch (error) {
            throw handleServiceError(error, 'Error generating automatic translations');
        }
    }

    async delete(id: number) {
        try {
            await this.findById(id);
            await this.prisma.translation.delete({
                where: { id }
            });
        } catch (error) {
            throw handleServiceError(error, ErrorMessages.DELETE_ERROR('translation'));
        }
    }
}
</file>

<file path="packages/backend/src/tests/utils/dbHelpers.ts">
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export const cleanDatabase = async () => {
  await prisma.translation.deleteMany({});
  await prisma.customField.deleteMany({});
  await prisma.foodItem.deleteMany({});
  await prisma.category.deleteMany({});
  await prisma.language.deleteMany({});
  await prisma.settings.deleteMany({});
};

export const disconnectDatabase = async () => {
  await cleanDatabase();
  await prisma.$disconnect();
};

export { prisma };
</file>

<file path="packages/backend/src/tests/utils/testFactories.ts">
import { prisma } from './dbHelpers';

export const createTestCategory = async (name = 'Test Category') => {
  return prisma.category.create({
    data: { name }
  });
};

export const createTestFoodItem = async (categoryId: number, data = {}) => {
  return prisma.foodItem.create({
    data: {
      name: 'Test Food Item',
      categoryId,
      inStock: true,
      itemLimit: 0,
      limitType: 'perHousehold',
      ...data
    }
  });
};

export const createTestLanguage = async (data = {}) => {
  return prisma.language.create({
    data: {
      code: 'en',
      name: 'English',
      active: true,
      ...data
    }
  });
};

export const createTestTranslation = async (data: {
  categoryId?: number;
  foodItemId?: number;
  languageId: number;
}) => {
  return prisma.translation.create({
    data: {
      translatedText: 'Test Translation',
      ...data
    }
  });
};
</file>

<file path="packages/backend/src/tests/utils/testHelpers.ts">
import { Express } from 'express';
import request from 'supertest';

export const expectSuccessResponse = (response: request.Response) => {
  expect(response.body.success).toBe(true);
  expect(response.body.data).toBeDefined();
};

export const expectErrorResponse = (response: request.Response) => {
  expect(response.body.success).toBe(false);
  expect(response.body.error).toBeDefined();
};

export const testCrudEndpoints = (app: Express, baseUrl: string, validPayload: any) => {
  describe('CRUD Operations', () => {
    let createdId: number;

    it('should create resource', async () => {
      const response = await request(app)
        .post(baseUrl)
        .send(validPayload)
        .expect(201);

      expectSuccessResponse(response);
      createdId = response.body.data.id;
    });

    it('should get all resources', async () => {
      const response = await request(app)
        .get(baseUrl)
        .expect(200);

      expectSuccessResponse(response);
      expect(Array.isArray(response.body.data)).toBe(true);
    });

    it('should get specific resource', async () => {
      const response = await request(app)
        .get(`${baseUrl}/${createdId}`)
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.id).toBe(createdId);
    });

    it('should update resource', async () => {
      const response = await request(app)
        .put(`${baseUrl}/${createdId}`)
        .send(validPayload)
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.id).toBe(createdId);
    });

    it('should delete resource', async () => {
      await request(app)
        .delete(`${baseUrl}/${createdId}`)
        .expect(200);

      await request(app)
        .get(`${baseUrl}/${createdId}`)
        .expect(404);
    });
  });
};
</file>

<file path="packages/backend/src/tests/categoryRoutes.test.ts">
import { createApp } from '../index';
import { cleanDatabase } from './utils/dbHelpers';
import { createTestCategory } from './utils/testFactories';
import { expectSuccessResponse, expectErrorResponse, testCrudEndpoints } from './utils/testHelpers';
import request from 'supertest';

describe('Category Routes', () => {
  const app = createApp();
  
  beforeEach(async () => {
    await cleanDatabase();
  });

  // Test all CRUD endpoints
  testCrudEndpoints(app, '/api/categories', { name: 'Test Category' });

  // Additional category-specific tests
  describe('Category Validations', () => {
    it('should reject empty category name', async () => {
      const response = await request(app)
        .post('/api/categories')
        .send({ name: '' })
        .expect(400);

      expectErrorResponse(response);
    });

    it('should handle duplicate category names', async () => {
      const category = await createTestCategory('Duplicate');
      
      const response = await request(app)
        .post('/api/categories')
        .send({ name: 'Duplicate' })
        .expect(400);

      expectErrorResponse(response);
    });
  });
});
</file>

<file path="packages/backend/src/tests/CategoryService.test.ts">
import { CategoryService } from '../services/CategoryService';
import { ApiError } from '../utils/ApiError';

describe('CategoryService', () => {
  let categoryService: CategoryService;

  beforeEach(() => {
    categoryService = new CategoryService();
  });

  describe('create', () => {
    it('should create a new category', async () => {
      const testData = { name: 'Test Category' };
      const result = await categoryService.create(testData);
      
      expect(result).toBeDefined();
      expect(result.name).toBe(testData.name);
      expect(result.id).toBeDefined();
    });
  });

  describe('findAll', () => {
    it('should return all categories', async () => {
      // Create test categories
      await categoryService.create({ name: 'Category 1' });
      await categoryService.create({ name: 'Category 2' });

      const categories = await categoryService.findAll();
      
      expect(categories).toBeDefined();
      expect(Array.isArray(categories)).toBe(true);
      expect(categories.length).toBeGreaterThanOrEqual(2);
    });
  });

  describe('findById', () => {
    it('should find category by id', async () => {
      const created = await categoryService.create({ name: 'Test Category' });
      const found = await categoryService.findById(created.id);
      
      expect(found).toBeDefined();
      expect(found?.id).toBe(created.id);
      expect(found?.name).toBe(created.name);
    });

    it('should throw ApiError if category not found', async () => {
      await expect(categoryService.findById(-1))
        .rejects
        .toThrow(ApiError);
    });
  });

  describe('update', () => {
    it('should update category', async () => {
      const created = await categoryService.create({ name: 'Original Name' });
      const updated = await categoryService.update(created.id, { name: 'Updated Name' });
      
      expect(updated).toBeDefined();
      expect(updated.id).toBe(created.id);
      expect(updated.name).toBe('Updated Name');
    });
  });

  describe('delete', () => {
    it('should delete category', async () => {
      const created = await categoryService.create({ name: 'To Delete' });
      
      await expect(categoryService.delete(created.id))
        .resolves
        .not
        .toThrow();

      await expect(categoryService.findById(created.id))
        .rejects
        .toThrow(ApiError);
    });
  });
});
</file>

<file path="packages/backend/src/tests/foodItemRoutes.test.ts">
import { createApp } from '../index';
import { cleanDatabase } from './utils/dbHelpers';
import { createTestCategory, createTestFoodItem } from './utils/testFactories';
import { expectSuccessResponse, expectErrorResponse, testCrudEndpoints } from './utils/testHelpers';
import request from 'supertest';

describe('Food Item Routes', () => {
  const app = createApp();
  let testCategoryId: number;
  
  beforeEach(async () => {
    await cleanDatabase();
    const category = await createTestCategory();
    testCategoryId = category.id;
  });

  const validPayload = {
    name: 'Test Food Item',
    categoryId: 0, // Will be set in beforeAll
    inStock: true,
    itemLimit: 0,
    limitType: 'perHousehold'
  };

  beforeAll(() => {
    // Update payload with actual category ID
    validPayload.categoryId = testCategoryId;
  });

  // Test all CRUD endpoints
  testCrudEndpoints(app, '/api/food-items', validPayload);

  describe('Food Item Validations', () => {
    it('should reject empty name', async () => {
      const response = await request(app)
        .post('/api/food-items')
        .send({ ...validPayload, name: '' })
        .expect(400);

      expectErrorResponse(response);
    });

    it('should reject invalid category', async () => {
      const response = await request(app)
        .post('/api/food-items')
        .send({ ...validPayload, categoryId: -1 })
        .expect(400);

      expectErrorResponse(response);
    });

    it('should validate limit type', async () => {
      const response = await request(app)
        .post('/api/food-items')
        .send({ ...validPayload, limitType: 'invalid' })
        .expect(400);

      expectErrorResponse(response);
    });
  });

  describe('Stock Filtering', () => {
    beforeEach(async () => {
      await createTestFoodItem(testCategoryId, { inStock: true });
      await createTestFoodItem(testCategoryId, { inStock: false });
    });

    it('should filter out-of-stock items by default', async () => {
      const response = await request(app)
        .get('/api/food-items')
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.every((item: any) => item.inStock)).toBe(true);
    });

    it('should include out-of-stock items when requested', async () => {
      const response = await request(app)
        .get('/api/food-items?includeOutOfStock=true')
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.some((item: any) => !item.inStock)).toBe(true);
    });
  });
});
</file>

<file path="packages/backend/src/tests/FoodItemService.test.ts">
import { FoodItemService } from '../services/FoodItemService';
import { ApiError } from '../utils/ApiError';
import { cleanDatabase } from './utils/dbHelpers';
import { createTestCategory, createTestFoodItem } from './utils/testFactories';

describe('FoodItemService', () => {
  let foodItemService: FoodItemService;
  let testCategoryId: number;

  beforeEach(async () => {
    foodItemService = new FoodItemService();
    await cleanDatabase();
    const category = await createTestCategory();
    testCategoryId = category.id;
  });

  describe('create', () => {
    it('should create a food item', async () => {
      const testData = {
        name: 'Test Food',
        categoryId: testCategoryId,
        inStock: true,
        itemLimit: 0,
        limitType: 'perHousehold'
      };
      const result = await foodItemService.create(testData);
      
      expect(result).toBeDefined();
      expect(result.name).toBe(testData.name);
      expect(result.categoryId).toBe(testCategoryId);
      expect(result.id).toBeDefined();
    });

    it('should validate category exists', async () => {
      const testData = {
        name: 'Test Food',
        categoryId: -1,
        inStock: true,
        itemLimit: 0,
        limitType: 'perHousehold'
      };
      await expect(foodItemService.create(testData)).rejects.toThrow(ApiError);
    });
  });

  describe('findAll', () => {
    it('should return all food items', async () => {
      await createTestFoodItem(testCategoryId, { name: 'Food 1' });
      await createTestFoodItem(testCategoryId, { name: 'Food 2' });

      const items = await foodItemService.findAll();
      expect(items.length).toBeGreaterThanOrEqual(2);
    });

    it('should filter out-of-stock items', async () => {
      await createTestFoodItem(testCategoryId, { name: 'In Stock', inStock: true });
      await createTestFoodItem(testCategoryId, { name: 'Out of Stock', inStock: false });

      const items = await foodItemService.findAll({ includeOutOfStock: false });
      expect(items.every(item => item.inStock)).toBe(true);
    });
  });

  describe('findById', () => {
    it('should find food item by id', async () => {
      const created = await createTestFoodItem(testCategoryId);
      const found = await foodItemService.findById(created.id);
      
      expect(found).toBeDefined();
      expect(found?.id).toBe(created.id);
    });

    it('should throw ApiError if not found', async () => {
      await expect(foodItemService.findById(-1)).rejects.toThrow(ApiError);
    });
  });

  describe('update', () => {
    it('should update food item', async () => {
      const created = await createTestFoodItem(testCategoryId);
      const updated = await foodItemService.update(created.id, { name: 'Updated Name' });
      
      expect(updated.name).toBe('Updated Name');
      expect(updated.id).toBe(created.id);
    });

    it('should validate category on update', async () => {
      const created = await createTestFoodItem(testCategoryId);
      await expect(foodItemService.update(created.id, { categoryId: -1 }))
        .rejects.toThrow(ApiError);
    });
  });

  describe('delete', () => {
    it('should delete food item', async () => {
      const created = await createTestFoodItem(testCategoryId);
      await foodItemService.delete(created.id);
      await expect(foodItemService.findById(created.id)).rejects.toThrow(ApiError);
    });
  });

  describe('limitType handling', () => {
    it('should handle per-household limits', async () => {
      const item = await createTestFoodItem(testCategoryId, {
        itemLimit: 5,
        limitType: 'perHousehold'
      });
      expect(item.limitType).toBe('perHousehold');
      expect(item.itemLimit).toBe(5);
    });

    it('should handle per-person limits', async () => {
      const item = await createTestFoodItem(testCategoryId, {
        itemLimit: 2,
        limitType: 'perPerson'
      });
      expect(item.limitType).toBe('perPerson');
      expect(item.itemLimit).toBe(2);
    });
  });
});
</file>

<file path="packages/backend/src/tests/languageRoutes.test.ts">
import request from 'supertest';
import { createApp } from '../index';
import { PrismaClient } from '@prisma/client';

describe('Language Routes', () => {
  const app = createApp();
  const prisma = new PrismaClient();

  beforeEach(async () => {
    await prisma.translation.deleteMany({});
    await prisma.foodItem.deleteMany({});
    await prisma.category.deleteMany({});
    await prisma.language.deleteMany({});
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  describe('POST /api/languages', () => {
    it('should create a new language', async () => {
      const response = await request(app)
        .post('/api/languages')
        .send({ code: 'fr', name: 'French' })
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.code).toBe('fr');
      expect(response.body.data.name).toBe('French');
    });

    it('should reject if code is missing', async () => {
      const response = await request(app)
        .post('/api/languages')
        .send({})
        .expect(400);

      expect(response.body.success).toBe(false);
    });

    it('should reject duplicates', async () => {
      await prisma.language.create({ data: { code: 'fr', name: 'French', active: true } });

      const response = await request(app)
        .post('/api/languages')
        .send({ code: 'fr', name: 'French' })
        .expect(400);

      expect(response.body.success).toBe(false);
    });
  });

  describe('GET /api/languages', () => {
    beforeEach(async () => {
      await prisma.language.create({
        data: { code: 'es', name: 'Spanish', active: true }
      });
      await prisma.language.create({
        data: { code: 'ru', name: 'Russian', active: true }
      });
    });

    it('should return all active languages', async () => {
      const response = await request(app)
        .get('/api/languages')
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(Array.isArray(response.body.data)).toBe(true);
      expect(response.body.data.length).toBe(2);
      const codes = response.body.data.map((l: any) => l.code);
      expect(codes).toContain('es');
      expect(codes).toContain('ru');
    });
  });
});
</file>

<file path="packages/backend/src/tests/limitType.test.ts">
import { PrismaClient } from '@prisma/client';
import { FoodItemService } from '../services/FoodItemService';

describe('FoodItem LimitType Tests', () => {
    let prisma: PrismaClient;
    let foodItemService: FoodItemService;
    let testCategoryId: number;

    beforeAll(async () => {
        prisma = new PrismaClient();
        foodItemService = new FoodItemService(true); // Enable test mode
        // Clear any existing data
        await prisma.translation.deleteMany();
        await prisma.foodItem.deleteMany();
        await prisma.category.deleteMany();
        
        const category = await prisma.category.create({
            data: { name: 'Test Category' }
        });
        testCategoryId = category.id;
    });

    afterEach(async () => {
        await prisma.translation.deleteMany();
        await prisma.foodItem.deleteMany();
    });

    afterAll(async () => {
        await prisma.$transaction([
            prisma.translation.deleteMany(),
            prisma.foodItem.deleteMany(),
            prisma.category.deleteMany()
        ]);
        await prisma.$disconnect();
    });

    it('creates food item with perPerson limitType', async () => {
        const foodItem = await foodItemService.create({
            name: 'Test Item',
            categoryId: testCategoryId,
            itemLimit: 2,
            limitType: 'perPerson'
        });

        expect(foodItem.limitType).toBe('perPerson');
    });

    it('defaults to perHousehold when limitType not specified', async () => {
        const foodItem = await foodItemService.create({
            name: 'Test Item 2',
            categoryId: testCategoryId
        });
        
        expect(foodItem.limitType).toBe('perHousehold');
    });

    it('updates limitType successfully', async () => {
        const foodItem = await foodItemService.create({
            name: 'Test Item 3',
            categoryId: testCategoryId,
            limitType: 'perHousehold'
        });
        
        const updated = await foodItemService.update(foodItem.id, {
            limitType: 'perPerson'
        });
        
        expect(updated.limitType).toBe('perPerson');
    });
});
</file>

<file path="packages/backend/src/tests/settings.test.ts">
describe('Settings API', () => {
    it('should get default settings', async () => {
        const response = await request(app)
            .get('/api/settings')
            .expect(200);
        
        expect(response.body.data.globalUpperLimit).toBeDefined();
    });

    it('should update settings', async () => {
        const response = await request(app)
            .post('/api/settings')
            .send({ globalUpperLimit: 50 })
            .expect(200);
        
        expect(response.body.data.globalUpperLimit).toBe(50);
    });
});
</file>

<file path="packages/backend/src/tests/settingsRoutes.test.ts">
import request from 'supertest';
import { createApp } from '../index';
import { PrismaClient } from '@prisma/client';

describe('Settings Routes', () => {
    const app = createApp();
    const prisma = new PrismaClient();

    beforeEach(async () => {
        await prisma.settings.deleteMany({});
    });

    afterAll(async () => {
        await prisma.$disconnect();
    });

    describe('GET /api/settings', () => {
        it('should return default settings when none exist', async () => {
            const response = await request(app)
                .get('/api/settings')
                .expect(200);

            expect(response.body).toEqual({
                success: true,
                data: { globalUpperLimit: 10 }
            });
        });

        it('should return existing settings', async () => {
            await prisma.settings.create({
                data: {
                    id: 1,
                    globalUpperLimit: 20
                }
            });

            const response = await request(app)
                .get('/api/settings')
                .expect(200);

            expect(response.body).toEqual({
                success: true,
                data: { globalUpperLimit: 20 }
            });
        });
    });

    describe('POST /api/settings', () => {
        it('should create new settings when none exist', async () => {
            const response = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 30 })
                .expect(200);

            expect(response.body).toEqual({
                success: true,
                data: expect.objectContaining({
                    id: 1,
                    globalUpperLimit: 30
                }),
                message: 'Settings updated successfully'
            });
        });

        it('should update existing settings', async () => {
            await prisma.settings.create({
                data: {
                    id: 1,
                    globalUpperLimit: 20
                }
            });

            const response = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 40 })
                .expect(200);

            expect(response.body).toEqual({
                success: true,
                data: expect.objectContaining({
                    id: 1,
                    globalUpperLimit: 40
                }),
                message: 'Settings updated successfully'
            });
        });

        it('should reject non-numeric global upper limit', async () => {
            const response = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 'invalid' })
                .expect(400);

            expect(response.body).toEqual({
                success: false,
                message: 'Global upper limit must be an integer',
                status: 400
            });
        });

        it('should reject negative global upper limit', async () => {
            const response = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: -1 })
                .expect(400);

            expect(response.body).toEqual({
                success: false,
                message: 'Global upper limit cannot be negative',
                status: 400
            });
        });

        it('should reject missing global upper limit', async () => {
            const response = await request(app)
                .post('/api/settings')
                .send({})
                .expect(400);

            expect(response.body).toEqual({
                success: false,
                message: 'Global upper limit is required',
                status: 400
            });
        });

        it('should reject decimal global upper limit', async () => {
            const response = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 10.5 })
                .expect(400);

            expect(response.body).toEqual({
                success: false,
                message: 'Global upper limit must be an integer',
                status: 400
            });
        });
    });

    describe('Settings persistence', () => {
        it('should maintain settings across requests', async () => {
            await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 50 })
                .expect(200);

            const response = await request(app)
                .get('/api/settings')
                .expect(200);

            expect(response.body).toEqual({
                success: true,
                data: { globalUpperLimit: 50 }
            });
        });

        it('should update updatedAt timestamp when modified', async () => {
            const createResponse = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 60 })
                .expect(200);

            const initialTimestamp = new Date(createResponse.body.data.updatedAt).getTime();

            // Wait a bit to ensure timestamp difference
            await new Promise(resolve => setTimeout(resolve, 1000));

            const updateResponse = await request(app)
                .post('/api/settings')
                .send({ globalUpperLimit: 70 })
                .expect(200);

            const updatedTimestamp = new Date(updateResponse.body.data.updatedAt).getTime();
            expect(updatedTimestamp).toBeGreaterThan(initialTimestamp);
        });
    });
});
</file>

<file path="packages/backend/src/tests/setup.ts">
import { cleanDatabase, disconnectDatabase } from './utils/dbHelpers';
import dotenv from 'dotenv';

// Load test environment variables
dotenv.config({ path: '.env.test' });

// Before all tests
beforeAll(async () => {
  await cleanDatabase();
});

// After all tests
afterAll(async () => {
  await disconnectDatabase();
});
</file>

<file path="packages/backend/src/tests/translationRoutes.test.ts">
import { createApp } from '../index';
import { cleanDatabase } from './utils/dbHelpers';
import { createTestCategory, createTestFoodItem, createTestLanguage, createTestTranslation } from './utils/testFactories';
import { expectSuccessResponse, expectErrorResponse } from './utils/testHelpers';
import request from 'supertest';

describe('Translation Routes', () => {
  const app = createApp();
  let testLanguageId: number;
  let testCategoryId: number;
  let testFoodItemId: number;

  beforeEach(async () => {
    await cleanDatabase();
    
    const language = await createTestLanguage();
    testLanguageId = language.id;
    
    const category = await createTestCategory();
    testCategoryId = category.id;
    
    const foodItem = await createTestFoodItem(category.id);
    testFoodItemId = foodItem.id;
  });

  describe('GET /api/translations/language/:languageCode', () => {
    beforeEach(async () => {
      await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });
      await createTestTranslation({
        foodItemId: testFoodItemId,
        languageId: testLanguageId
      });
    });

    it('should get translations by language code', async () => {
      const response = await request(app)
        .get('/api/translations/language/en')
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.length).toBe(2);
    });

    it('should filter by type', async () => {
      const response = await request(app)
        .get('/api/translations/language/en?type=category')
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.every((t: any) => t.categoryId)).toBe(true);
    });
  });

  describe('POST /api/translations/category/:categoryId', () => {
    it('should create category translation', async () => {
      const response = await request(app)
        .post(`/api/translations/category/${testCategoryId}`)
        .send({
          languageId: testLanguageId,
          translatedText: 'Test Translation'
        })
        .expect(201);

      expectSuccessResponse(response);
      expect(response.body.data.categoryId).toBe(testCategoryId);
    });

    it('should validate inputs', async () => {
      const response = await request(app)
        .post(`/api/translations/category/${testCategoryId}`)
        .send({
          languageId: -1,
          translatedText: ''
        })
        .expect(400);

      expectErrorResponse(response);
    });
  });

  describe('POST /api/translations/food-item/:foodItemId', () => {
    it('should create food item translation', async () => {
      const response = await request(app)
        .post(`/api/translations/food-item/${testFoodItemId}`)
        .send({
          languageId: testLanguageId,
          translatedText: 'Test Translation'
        })
        .expect(201);

      expectSuccessResponse(response);
      expect(response.body.data.foodItemId).toBe(testFoodItemId);
    });

    it('should validate inputs', async () => {
      const response = await request(app)
        .post(`/api/translations/food-item/${testFoodItemId}`)
        .send({
          languageId: -1,
          translatedText: ''
        })
        .expect(400);

      expectErrorResponse(response);
    });
  });

  describe('PUT /api/translations/:id', () => {
    it('should update translation', async () => {
      const translation = await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });

      const response = await request(app)
        .put(`/api/translations/${translation.id}`)
        .send({ translatedText: 'Updated Text' })
        .expect(200);

      expectSuccessResponse(response);
      expect(response.body.data.translatedText).toBe('Updated Text');
    });
  });

  describe('DELETE /api/translations/:id', () => {
    it('should delete translation', async () => {
      const translation = await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });

      await request(app)
        .delete(`/api/translations/${translation.id}`)
        .expect(200);

      // Verify deletion
      await request(app)
        .get(`/api/translations/${translation.id}`)
        .expect(404);
    });
  });
});
</file>

<file path="packages/backend/src/tests/TranslationService.test.ts">
import { TranslationService } from '../services/TranslationService';
import { ApiError } from '../utils/ApiError';
import { cleanDatabase } from './utils/dbHelpers';
import { createTestCategory, createTestFoodItem, createTestLanguage, createTestTranslation } from './utils/testFactories';

describe('TranslationService', () => {
  let translationService: TranslationService;
  let testLanguageId: number;
  let testCategoryId: number;
  let testFoodItemId: number;

  beforeEach(async () => {
    translationService = new TranslationService();
    await cleanDatabase();
    
    const language = await createTestLanguage();
    testLanguageId = language.id;
    
    const category = await createTestCategory();
    testCategoryId = category.id;
    
    const foodItem = await createTestFoodItem(category.id);
    testFoodItemId = foodItem.id;
  });

  describe('createForCategory', () => {
    it('should create category translation', async () => {
      const result = await translationService.createForCategory({
        categoryId: testCategoryId,
        languageId: testLanguageId,
        translatedText: 'Test Translation'
      });

      expect(result).toBeDefined();
      expect(result.categoryId).toBe(testCategoryId);
      expect(result.languageId).toBe(testLanguageId);
    });

    it('should validate category exists', async () => {
      await expect(translationService.createForCategory({
        categoryId: -1,
        languageId: testLanguageId,
        translatedText: 'Test'
      })).rejects.toThrow(ApiError);
    });
  });

  describe('createForFoodItem', () => {
    it('should create food item translation', async () => {
      const result = await translationService.createForFoodItem({
        foodItemId: testFoodItemId,
        languageId: testLanguageId,
        translatedText: 'Test Translation'
      });

      expect(result).toBeDefined();
      expect(result.foodItemId).toBe(testFoodItemId);
      expect(result.languageId).toBe(testLanguageId);
    });

    it('should validate food item exists', async () => {
      await expect(translationService.createForFoodItem({
        foodItemId: -1,
        languageId: testLanguageId,
        translatedText: 'Test'
      })).rejects.toThrow(ApiError);
    });
  });

  describe('findByLanguage', () => {
    beforeEach(async () => {
      await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });
      await createTestTranslation({
        foodItemId: testFoodItemId,
        languageId: testLanguageId
      });
    });

    it('should find all translations for language', async () => {
      const translations = await translationService.findByLanguage(testLanguageId);
      expect(translations.length).toBe(2);
    });

    it('should filter by type', async () => {
      const categoryTranslations = await translationService.findByLanguage(
        testLanguageId,
        'category'
      );
      expect(categoryTranslations.every(t => t.categoryId !== null)).toBe(true);

      const foodItemTranslations = await translationService.findByLanguage(
        testLanguageId,
        'foodItem'
      );
      expect(foodItemTranslations.every(t => t.foodItemId !== null)).toBe(true);
    });
  });

  describe('update', () => {
    it('should update translation text', async () => {
      const translation = await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });

      const updated = await translationService.update(
        translation.id,
        'Updated Text'
      );
      
      expect(updated.translatedText).toBe('Updated Text');
    });
  });

  describe('delete', () => {
    it('should delete translation', async () => {
      const translation = await createTestTranslation({
        categoryId: testCategoryId,
        languageId: testLanguageId
      });

      await translationService.delete(translation.id);
      
      const translations = await translationService.findByLanguage(testLanguageId);
      expect(translations.find(t => t.id === translation.id)).toBeUndefined();
    });
  });
});
</file>

<file path="packages/backend/src/utils/ApiError.ts">
export class ApiError extends Error {
  public isOperational: boolean;

  constructor(
    public statusCode: number,
    message: string,
    isOperational = true,
    stack = ''
  ) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;

    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

/**
 * Custom error class for settings-related validation errors.
 * Inherits from ApiError with a fixed status code of 400.
 */
export class SettingsValidationError extends ApiError {
  constructor(message: string) {
    super(400, message);
  }
}

/**
 * Type guard to identify ApiError instances.
 */
export const isApiError = (error: unknown): error is ApiError => {
  return error instanceof ApiError;
};
</file>

<file path="packages/backend/src/utils/ApiResponse.ts">
export class ApiResponse {
  public readonly success: boolean;
  public readonly data: any;
  public readonly message?: string;
  public readonly pagination?: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
  };

  constructor(success: boolean, data: any, message?: string, pagination?: any) {
      this.success = success;
      this.data = data;
      this.message = message;
      this.pagination = pagination;
  }

  static success(data: any, message?: string, pagination?: any): ApiResponse {
      return new ApiResponse(true, data, message, pagination);
  }

  static error(message: string): ApiResponse {
      return new ApiResponse(false, null, message);
  }

  static paginated(items: any[], page: number, limit: number, total: number): ApiResponse {
      const totalPages = Math.ceil(total / limit);
      return new ApiResponse(true, items, undefined, { page, limit, total, totalPages });
  }
}
</file>

<file path="packages/backend/src/utils/errorConstants.ts">
export const ErrorTypes = {
  VALIDATION: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  INTERNAL: 500
} as const;

export const ErrorMessages = {
  // Entity not found
  CATEGORY_NOT_FOUND: 'Category not found',
  FOOD_ITEM_NOT_FOUND: 'Food item not found',
  TRANSLATION_NOT_FOUND: 'Translation not found',
  LANGUAGE_NOT_FOUND: 'Language not found',
  SETTING_NOT_FOUND: 'Setting not found',

  // Invalid inputs
  INVALID_CATEGORY: 'Invalid category ID',
  INVALID_LANGUAGE: 'Invalid or inactive language code',
  INVALID_LIMIT_TYPE: 'Invalid limit type',
  
  // Operation errors
  CREATE_ERROR: (entity: string) => `Error creating ${entity}`,
  UPDATE_ERROR: (entity: string) => `Error updating ${entity}`,
  DELETE_ERROR: (entity: string) => `Error deleting ${entity}`,
  TRANSLATION_ERROR: (lang: string) => `Error generating translation for language: ${lang}`
} as const;
</file>

<file path="packages/backend/src/utils/errorHandler.ts">
import { ApiError } from './ApiError';
import { ErrorTypes } from './errorConstants';
import { Prisma } from '@prisma/client';

export const handleServiceError = (error: unknown, defaultMessage: string): never => {
  console.error('Service Error:', error);

  if (error instanceof ApiError) {
    throw error;
  }

  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    // Handle specific Prisma errors
    switch (error.code) {
      case 'P2002':
        throw new ApiError(ErrorTypes.VALIDATION, 'Unique constraint failed');
      case 'P2003':
        throw new ApiError(ErrorTypes.VALIDATION, 'Foreign key constraint failed');
      case 'P2025':
        throw new ApiError(ErrorTypes.NOT_FOUND, 'Record not found');
      default:
        throw new ApiError(ErrorTypes.INTERNAL, defaultMessage);
    }
  }

  throw new ApiError(ErrorTypes.INTERNAL, defaultMessage);
};
</file>

<file path="packages/backend/src/index.ts">
import dotenv from 'dotenv';
dotenv.config(); // Call this first, before importing anything else that relies on env vars

import express from 'express';
import cors from 'cors';
import { requestLogger } from './middleware/requestLogger';
import { errorHandler } from './middleware/errorHandler';
import { ApiResponse } from './utils/ApiResponse';
import categoryRoutes from './routes/categoryRoutes';
import foodItemRoutes from './routes/foodItemRoutes';
import translationRoutes from './routes/translationRoutes';
import languageRoutes from './routes/languageRoutes';
import settingsRoutes from './routes/settingsRoutes';
import path from 'path';

// Create and configure express app
export const createApp = () => {
    const app = express();

    // Middleware
    app.use(cors());
    app.use(express.json());
    app.use(requestLogger);

    // Serve static files from public directory
    app.use(express.static(path.join(__dirname, '../public')));

    // Routes
    app.use('/api/categories', categoryRoutes);
    app.use('/api/food-items', foodItemRoutes);
    app.use('/api/translations', translationRoutes);
    app.use('/api/languages', languageRoutes);
    app.use('/api/settings', settingsRoutes);    // Add this line

    // Basic health check endpoint
    app.get('/health', (req, res) => {
        res.status(200).json(ApiResponse.success({
            uptime: process.uptime(),
            timestamp: new Date().toISOString()
        }));
    });

    // Error handling middleware (must be after all other middleware and routes)
    app.use(errorHandler);
    return app;
};

// Only start the server if this file is run directly
if (require.main === module) {
    const app = createApp();
    const PORT = process.env.PORT || 3000;
    app.listen(PORT, () => {
        console.log(`Server running on port ${PORT}`);
    });
}
</file>

<file path="packages/backend/.env.example">
DATABASE_URL="file:../../data/food-pantry.db"
OPENAI_API_KEY="your-api-key-here"
</file>

<file path="packages/backend/jest-setup.js">
const { TextEncoder, TextDecoder } = require('util');
global.TextEncoder = TextEncoder;
global.TextDecoder = TextDecoder;
</file>

<file path="packages/backend/jest.config.js">
module.exports = {
    projects: [
        {
            displayName: 'backend',
            testEnvironment: 'node',
            testMatch: [
                '<rootDir>/src/tests/*.test.ts',
                '<rootDir>/src/services/**/*.test.ts'
            ],
            transform: {
                '^.+\\.(ts|tsx)$': 'ts-jest'
            },
            setupFilesAfterEnv: [
                '<rootDir>/src/tests/setup.ts'
            ],
            moduleNameMapper: {
                '^@/(.*)$': '<rootDir>/src/$1'
            }
        },
        {
            displayName: 'frontend',
            testEnvironment: 'jsdom',
            testMatch: [
                '<rootDir>/src/tests/frontend/*.test.js'
            ],
            transform: {
                '^.+\\.(js|jsx)$': 'babel-jest'
            },
            setupFilesAfterEnv: [
                '<rootDir>/src/tests/frontend/setup.js'
            ]
        }
    ],
    collectCoverage: true,
    coverageDirectory: 'coverage',
    coverageReporters: ['text', 'lcov'],
    testTimeout: 30000,
    detectOpenHandles: true
}
</file>

<file path="packages/backend/package.json">
{
    "name": "@sql-react-app/backend",
    "version": "0.1.0",
    "private": true,
    "scripts": {
        "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
        "build": "tsc",
        "start": "node dist/index.js",
        "prisma:generate": "prisma generate",
        "prisma:migrate": "prisma migrate deploy",
        "prisma:studio": "prisma studio",
        "test": "jest",
        "test:watch": "jest --watch",
        "test:coverage": "jest --coverage",
        "test:unit": "jest src/tests/limitType.test.ts",
        "test:frontend": "jest src/tests/frontend/",
        "lint": "eslint . --ext .ts"
    },
    "dependencies": {
        "@prisma/client": "^6.1.0",
        "cors": "^2.8.5",
        "dotenv": "^16.3.1",
        "express": "^4.18.2",
        "express-validator": "^7.0.1",
        "openai": "^4.76.0",
        "winston": "^3.11.0"
    },
    "devDependencies": {
        "@babel/core": "^7.26.0",
        "@babel/plugin-transform-modules-commonjs": "^7.26.3",
        "@babel/preset-env": "^7.26.0",
        "@babel/preset-typescript": "^7.26.0",
        "@types/cors": "^2.8.17",
        "@types/express": "^4.17.21",
        "@types/jest": "^29.5.11",
        "@types/node": "^20.10.4",
        "@types/supertest": "^6.0.2",
        "@typescript-eslint/eslint-plugin": "^6.13.2",
        "@typescript-eslint/parser": "^6.13.2",
        "babel-jest": "^29.7.0",
        "eslint": "^8.55.0",
        "jest": "^29.7.0",
        "jest-environment-jsdom": "^29.7.0",
        "prisma": "^6.1.0",
        "supertest": "^7.0.0",
        "ts-jest": "^29.1.1",
        "ts-node-dev": "^2.0.0",
        "typescript": "^5.3.3"
    }
}
</file>

<file path="packages/backend/tsconfig.json">
{
    "compilerOptions": {
      "target": "es2020",
      "module": "commonjs",
      "lib": ["es2020"],
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "outDir": "dist",
      "rootDir": "src",
      "experimentalDecorators": true,
      "emitDecoratorMetadata": true,
      "resolveJsonModule": true
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "dist"]
  }
</file>

<file path="packages/frontend/package.json">
{
    "name": "@sql-react-app/frontend",
    "version": "0.1.0",
    "private": true,
    "dependencies": {
      "react": "^18.2.0",
      "react-dom": "^18.2.0"
    },
    "devDependencies": {
      "@types/react": "^18.2.0",
      "@types/react-dom": "^18.2.0",
      "typescript": "^5.3.3"
    }
}
</file>

<file path=".gitignore">
packages/backend/.env
node_modules
*.log
node_modules/
data/
</file>

<file path=".repomixignore">
*.log
packages/backend/.env
node_modules
*.log
node_modules/
data/
</file>

<file path="CHANGELOG.md">
<<<<<<< HEAD
=======
# Changelog
All notable changes to this project will be documented in this file.

The format follows [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]
- React-based user interface
- Production deployment configuration
- Full system integration testing

## [0.5.5] - 2024-12-21
### Added
- **LimitType** field to **FoodItem** model  
- Test suite for FoodItem limitType functionality  
- **Test mode** for FoodItemService  
- Additional test coverage for OpenAIService  
- Improved documentation for modular JavaScript structure

### Fixed
- Food item update functionality  
- Translation generation during testing  
- TypeScript validation in FoodItemService  
- Documentation formatting inconsistencies  
- **Food Items table display** and CRUD in Test UI (Edit/Delete now functional)

## [0.5.3] - 2024-12-18
### Added
- Local development environment setup
- Working database configuration for local SQLite
- Test data initialization process
- Updated documentation for local setup

### Changed
- Messages now display within their respective sections instead of global header
- Fixed category dropdown in Food Item Management
- Improved language filter to show all available languages

### Fixed
- Package dependency issues for local development
- Database path configuration for cross-platform compatibility
- Git tracking of sensitive information

## [0.5.2] - 2024-12-11
### Fixed
- Translation type classification in UI (categories vs. food items)
- Original text display in translation management
- Language filter dropdown initialization
- Translation filtering by type

### Added
- Automatic language filter updates when language settings change
- Event-based synchronization between language and translation managers

### Changed
- Improved translation type handling in backend service
- Enhanced translation filtering logic

## [0.5.1] - 2024-12-06
### Added
- Language model for managing supported languages
- Comprehensive language management system
- Improved translation validation and error handling
- Complete test coverage for language management
- Non-null assertions for type safety
- Paginated response utility

### Changed
- Updated translation schema to support language relationships
- Enhanced error handling with standardized responses
- Improved test setup with proper database cleanup
- Updated API documentation for language endpoints

### Fixed
- Language uniqueness constraint handling
- Translation relationship type safety
- Category validation for empty names
- Response status code consistency

## [0.5.0] - 2024-12-06
### Added
- OpenAI-powered translation system using gpt-4o-mini model
- Cost-effective automated translations
- Multiple language support
- Seamless UI integration

### Fixed
- Translation loading error after food item deletion

### Changed
- Translation system from manual to automated

## [0.4.0] - 2024-12-03
### Added
- Test UI for validating backend functionality
- Category management interface
- Food item management with dietary and status flags
- Translation management interface
- Basic CSS styling for usability
- Complete CRUD operations for all entities
- Form validation and error handling
- Status and dietary attribute display

### Fixed
- Food items visibility when out of stock
- JSON parsing in food item edit functionality

### Known Issues
- Translation loading error after food item deletion

## [0.1.1] - 2024-12-02
### Added
- Complete backend implementation:
  - Category, FoodItem, and Translation services with CRUD operations
  - RESTful API endpoints with validation
  - Comprehensive test coverage (56 tests)
  - Structured error handling
  - Request logging middleware

### Changed
- Enhanced project structure:
  - Separate route handlers
  - Service layer abstraction
  - Utility classes for errors and responses
- Improved type safety with TypeScript
- Updated documentation with API endpoints

## [0.1.0] - 2024-11-29
### Added
- Initial project setup:
  - Prisma ORM integration
  - Database schema for:
    - Categories and food items
    - Multi-language translations
    - Dietary attributes
    - Custom fields
  - Development environment configuration
  - SQLite database initialization
- Documentation setup:
  - README structure
  - Development roadmap
  - MIT License

### Changed
- Repository reset for fresh implementation
- Updated technical stack documentation
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 MattGeiger

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
  "name": "wth-food-shopping-lists",
  "version": "1.0.0",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "dev": "npm run dev --workspace=@sql-react-app/backend",
    "build": "npm run build --workspace=@sql-react-app/backend",
    "test": "npm run test --workspace=@sql-react-app/backend",
    "lint": "npm run lint --workspace=@sql-react-app/backend"
  },
  "devDependencies": {
    "@types/jsdom": "^21.1.7",
    "jsdom": "^25.0.1",
    "typescript": "^5.3.3"
  }
}
</file>

<file path="project-tree.txt">
.
 CHANGELOG.md
 LICENSE
 README.md
 package-lock.json
 package.json
 packages
  backend
   babel.config.js
   jest-setup.js
   jest.config.js
   package.json
   prisma
    migrations
     20241130003245_init
      migration.sql
     20241207052011_add_language_model_and_make_language_id_optional
      migration.sql
     20241209004222_add_settings_model
      migration.sql
     20241220064500_add_limit_type
      migration.sql
     migration_lock.toml
    schema.prisma
   project-tree.txt
   public
    css
     components
      forms.css
      languages.css
      messages.css
      tables.css
     layout
      sections.css
     styles.css
    index.html
    js
        categories.js
        foodItems.js
        languages.js
        main.js
        settings.js
        translations.js
        utils.js
   src
    config
     languageConfig.ts
    index.ts
    middleware
     errorHandler.ts
     requestLogger.ts
    routes
     categoryRoutes.ts
     foodItemRoutes.ts
     languageRoutes.ts
     settingsRoutes.ts
     translationRoutes.ts
    services
     CategoryService.ts
     FoodItemService.ts
     LanguageService.ts
     TranslationService.ts
     openai
         OpenAIService.ts
         __tests__
             OpenAIService.test.ts
    tests
     CategoryService.test.ts
     FoodItemService.test.ts
     TranslationService.test.ts
     categoryRoutes.test.ts
     foodItemRoutes.test.ts
     frontend
      __mocks__
       fileMock.js
       styleMock.js
      categories.test.js
      foodItems.test.js
      languages.test.js
      settings.test.js
      setup.js
      translations.test.js
      utils
          mockHelpers.js
          testFactories.js
     languageRoutes.test.ts
     limitType.test.ts
     settings.test.ts
     settingsRoutes.test.ts
     setup.ts
     translationRoutes.test.ts
     utils
         dbHelpers.ts
         testFactories.ts
         testHelpers.ts
    utils
        ApiError.ts
        ApiResponse.ts
        errorConstants.ts
        errorHandler.ts
   tsconfig.json
  frontend
      package.json
 project-tree.txt

28 directories, 76 files
</file>

<file path="README.md">
# SQL-React-App

A web application providing food pantry inventory management through a SQL database backend with automated translations via OpenAI integration.

## Project Overview

This application is designed to:
- Manage food pantry inventory items and categories  
- Support multiple languages through automated translations  
- Track dietary restrictions and food attributes  
- Offer a responsive, user-friendly interface

### Key Features

#### Implemented
- **Database Management**  
  - SQL backend using Prisma ORM  
  - Category and food item CRUD operations  
  - Language management system  
  - Translation relationships  
  - Dietary attribute tracking  
  - Custom fields for flexibility  
  - Comprehensive error handling

- **API Endpoints**  
  - Categories API with validation  
  - Food Items API (now returning an array instead of paginated by default)  
  - Languages API for localization  
  - Translations API with relationships  
  - Settings API for global configuration  
  - Standardized response formatting

#### Planned
- **React Frontend**  
  - Rewrite the test UI in React  
  - Incorporate TypeScript throughout  
  - Full system integration tests  
  - Production deployment configuration

## Technical Stack

### Backend
- SQLite database
- Prisma ORM
- Node.js / Express
- TypeScript
- Jest testing framework
- Standardized error handling

### Frontend (Current)
- Test UI using plain HTML + modular JavaScript
- Uses `fetch`-based utilities (`apiGet`, `apiPost`, etc.)
- Focused on verifying backend routes and data flow

### Frontend (Future Plans)
- React with TypeScript
- Component-based UI
- Enhanced styling and user experience

## Development Status

- **Repository Setup**: Complete  
- **Development Environment**: Complete  
- **Backend Implementation**: Ongoing  
- **Test UI Development**: Ongoing  
- **OpenAI Integration**: Complete  
- **Language Management System**: Complete  
- **Translation System**: Complete  
- **Backend Testing Setup**: Mostly complete  
- **React Setup**: Planned  
- **React UI Development**: Planned  
- **System Integration**: Planned  
- **Documentation**: Ongoing  

## Getting Started

### Prerequisites

- **Node.js** v14+  
- **npm** or **yarn**  
- **SQLite 3**  
- **Git**

### Initial Setup

1. **Clone the repository**:
   ```bash
   git clone https://github.com/MattGeiger/WTH_App_V5.git
   cd WTH_App_V5

	2.	Install dependencies:

npm install
cd packages/backend
npm install


	3.	Configure environment:

cp .env.example .env
# Edit .env with your settings


	4.	Initialize database:

npx prisma generate
npx prisma migrate dev



Development
	1.	Start the backend server:

npm run dev


	2.	Run tests:

npm test               # Run all tests
npm run test:unit      # Run a specific test suite
npm run test:watch     # Run tests in watch mode
npm run test:coverage  # Generate coverage report


	3.	Access the API:
		API: http://localhost:3000
		Test UI: http://localhost:3000/index.html

API Documentation

Categories

GET    /api/categories
POST   /api/categories
GET    /api/categories/:id
PUT    /api/categories/:id
DELETE /api/categories/:id

Food Items

GET    /api/food-items
POST   /api/food-items
GET    /api/food-items/:id
PUT    /api/food-items/:id
DELETE /api/food-items/:id

Languages

GET    /api/languages
POST   /api/languages
PUT    /api/languages/:id
DELETE /api/languages/:id

Translations

GET    /api/translations
GET    /api/translations/language/:languageCode
POST   /api/translations/category/:categoryId
POST   /api/translations/food-item/:foodItemId
PUT    /api/translations/:id
DELETE /api/translations/:id

Settings

GET    /api/settings
POST   /api/settings

Contributing

This project is in active development. Refer to the Current Branch Goals in the CHANGELOG for ongoing work.

License

This project is licensed under the MIT License - see the LICENSE file for details.
</file>

<file path="repomix.config.json">
{
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  }
}
</file>

</repository_files>
